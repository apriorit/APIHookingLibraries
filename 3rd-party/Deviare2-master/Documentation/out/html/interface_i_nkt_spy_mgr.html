<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Deviare v2: INktSpyMgr Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="nektrastyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Deviare v2
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('interface_i_nkt_spy_mgr.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interface_i_nkt_spy_mgr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">INktSpyMgr Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is central Deviare interface. It exposes methods for initializing and configuring the interception engine; working with hooks, agents and custom DLLs; and obtaining interfaces to access to process, memory and similar system objects.  
 <a href="interface_i_nkt_spy_mgr.html#details">More...</a></p>

<p><code>import&quot;<a class="el" href="_deviare_c_o_m_8idl_source.html">DeviareCOM.idl</a>&quot;;</code></p>

<p>Inherits <a class="el" href="interface_i_nkt_object.html">INktObject</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff26f5648f3056461e1ba8b49b6c2ecc"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#aff26f5648f3056461e1ba8b49b6c2ecc">SettingOverride</a> ([in] BSTR setting, [in] LONG newValue)</td></tr>
<tr class="memdesc:aff26f5648f3056461e1ba8b49b6c2ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides a Deviare engine setting.  <a href="#aff26f5648f3056461e1ba8b49b6c2ecc">More...</a><br /></td></tr>
<tr class="separator:aff26f5648f3056461e1ba8b49b6c2ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d543b479d027fbe710595670d7c7c"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#afd0d543b479d027fbe710595670d7c7c">DatabasePath</a> ([in] BSTR newValue)</td></tr>
<tr class="memdesc:afd0d543b479d027fbe710595670d7c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the database path.  <a href="#afd0d543b479d027fbe710595670d7c7c">More...</a><br /></td></tr>
<tr class="separator:afd0d543b479d027fbe710595670d7c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfb2b31ca5c7092209e6da169942d25"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a6bfb2b31ca5c7092209e6da169942d25">AgentPath</a> ([out, retval] BSTR *pVal)</td></tr>
<tr class="memdesc:a6bfb2b31ca5c7092209e6da169942d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the agent DLL path.  <a href="#a6bfb2b31ca5c7092209e6da169942d25">More...</a><br /></td></tr>
<tr class="separator:a6bfb2b31ca5c7092209e6da169942d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89d53d61133662baae06c196137dd3b"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#aa89d53d61133662baae06c196137dd3b">AgentPath</a> ([in] BSTR newValue)</td></tr>
<tr class="memdesc:aa89d53d61133662baae06c196137dd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the agent DLL path (read-only after initialization).  <a href="#aa89d53d61133662baae06c196137dd3b">More...</a><br /></td></tr>
<tr class="separator:aa89d53d61133662baae06c196137dd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175c32dc94e608c22a7b42da93d2bf4"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a5175c32dc94e608c22a7b42da93d2bf4">Initialize</a> ([out, retval] LONG *pVal)</td></tr>
<tr class="memdesc:a5175c32dc94e608c22a7b42da93d2bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Spy Manager system.  <a href="#a5175c32dc94e608c22a7b42da93d2bf4">More...</a><br /></td></tr>
<tr class="separator:a5175c32dc94e608c22a7b42da93d2bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9df1004e5e6e2d44dd0975c4aab4d99"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#ad9df1004e5e6e2d44dd0975c4aab4d99">Processes</a> ([out, retval] <a class="el" href="interface_i_nkt_processes_enum.html">INktProcessesEnum</a> **ppProcsEnum)</td></tr>
<tr class="memdesc:ad9df1004e5e6e2d44dd0975c4aab4d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the currently running processes.  <a href="#ad9df1004e5e6e2d44dd0975c4aab4d99">More...</a><br /></td></tr>
<tr class="separator:ad9df1004e5e6e2d44dd0975c4aab4d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ad3139833d3e91774475a20b0466a3"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a00ad3139833d3e91774475a20b0466a3">Hooks</a> ([out, retval] <a class="el" href="interface_i_nkt_hooks_enum.html">INktHooksEnum</a> **ppHooksEnum)</td></tr>
<tr class="memdesc:a00ad3139833d3e91774475a20b0466a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a hook enumerator object representing the existent hooks on this engine instance.  <a href="#a00ad3139833d3e91774475a20b0466a3">More...</a><br /></td></tr>
<tr class="separator:a00ad3139833d3e91774475a20b0466a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9b037c2fe58be5ab48bcd0ffd5e7e8"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#aaa9b037c2fe58be5ab48bcd0ffd5e7e8">CreateHooksCollection</a> ([out, retval] <a class="el" href="interface_i_nkt_hooks_enum.html">INktHooksEnum</a> **ppHooksColl)</td></tr>
<tr class="memdesc:aaa9b037c2fe58be5ab48bcd0ffd5e7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a hook collection object. Collections of hooks are a convenience feature for grouping several hooks in one manageable interface.  <a href="#aaa9b037c2fe58be5ab48bcd0ffd5e7e8">More...</a><br /></td></tr>
<tr class="separator:aaa9b037c2fe58be5ab48bcd0ffd5e7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4566f4a2e83409be783658eb2fa68de7"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a4566f4a2e83409be783658eb2fa68de7">CreateHook</a> ([in] VARIANT func, [in] LONG hookFlags, [out, retval] <a class="el" href="interface_i_nkt_hook.html">INktHook</a> **ppHook)</td></tr>
<tr class="memdesc:a4566f4a2e83409be783658eb2fa68de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a hook to intercept the provided function name or an <a class="el" href="interface_i_nkt_exported_function.html" title="Exposes methods for accessing exported functions. ">INktExportedFunction</a> compatible object.  <a href="#a4566f4a2e83409be783658eb2fa68de7">More...</a><br /></td></tr>
<tr class="separator:a4566f4a2e83409be783658eb2fa68de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceba92965a3615860fe674b6c8be47ad"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#aceba92965a3615860fe674b6c8be47ad">CreateHookForAddress</a> ([in] my_ssize_t addr, [in] BSTR functionName, [in] LONG hookFlags, [out, retval] <a class="el" href="interface_i_nkt_hook.html">INktHook</a> **ppHook)</td></tr>
<tr class="memdesc:aceba92965a3615860fe674b6c8be47ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a hook to intercept a function specified by its memory address.  <a href="#aceba92965a3615860fe674b6c8be47ad">More...</a><br /></td></tr>
<tr class="separator:aceba92965a3615860fe674b6c8be47ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b47205814f75e7bfae6b88dd518caa3"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a6b47205814f75e7bfae6b88dd518caa3">DestroyHook</a> ([in] <a class="el" href="interface_i_nkt_hook.html">INktHook</a> *hook)</td></tr>
<tr class="memdesc:a6b47205814f75e7bfae6b88dd518caa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a hook.  <a href="#a6b47205814f75e7bfae6b88dd518caa3">More...</a><br /></td></tr>
<tr class="separator:a6b47205814f75e7bfae6b88dd518caa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca4ab2125935247bc01f80175a5d6c6"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a1ca4ab2125935247bc01f80175a5d6c6">LoadAgent</a> ([in] VARIANT procOrId)</td></tr>
<tr class="memdesc:a1ca4ab2125935247bc01f80175a5d6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the agent DLL in the target process.  <a href="#a1ca4ab2125935247bc01f80175a5d6c6">More...</a><br /></td></tr>
<tr class="separator:a1ca4ab2125935247bc01f80175a5d6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f652d23e914219cb2be441852e95d02"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a1f652d23e914219cb2be441852e95d02">UnloadAgent</a> ([in] VARIANT procOrId)</td></tr>
<tr class="memdesc:a1f652d23e914219cb2be441852e95d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces agent unload from the target process.  <a href="#a1f652d23e914219cb2be441852e95d02">More...</a><br /></td></tr>
<tr class="separator:a1f652d23e914219cb2be441852e95d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2538cb91b479817f7a2ad0dc3fa875ea"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a2538cb91b479817f7a2ad0dc3fa875ea">LoadCustomDll</a> ([in] VARIANT procOrId, [in] BSTR dllFileName, [in, defaultvalue(<a class="el" href="_deviare_c_o_m_8idl.html#ac82a9cd23697dce53b75650d565d08c5">MY_VARIANT_TRUE</a>)] VARIANT_BOOL unloadOnAgentShutdown, [in, defaultvalue(<a class="el" href="_deviare_c_o_m_8idl.html#aa653314cc120a0d2157582fc6311ecd8">MY_VARIANT_FALSE</a>)] VARIANT_BOOL sync, [out, retval] LONG *pActionId)</td></tr>
<tr class="memdesc:a2538cb91b479817f7a2ad0dc3fa875ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a custom DLL in a target process.  <a href="#a2538cb91b479817f7a2ad0dc3fa875ea">More...</a><br /></td></tr>
<tr class="separator:a2538cb91b479817f7a2ad0dc3fa875ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f4decc71498f0ca3fcfc07dfff6ec"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a149f4decc71498f0ca3fcfc07dfff6ec">UnloadCustomDll</a> ([in] VARIANT procOrId, [in] BSTR dllFileName, [in, defaultvalue(<a class="el" href="_deviare_c_o_m_8idl.html#aa653314cc120a0d2157582fc6311ecd8">MY_VARIANT_FALSE</a>)] VARIANT_BOOL sync, [out, retval] LONG *pVal)</td></tr>
<tr class="memdesc:a149f4decc71498f0ca3fcfc07dfff6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads a custom DLL from a target process.  <a href="#a149f4decc71498f0ca3fcfc07dfff6ec">More...</a><br /></td></tr>
<tr class="separator:a149f4decc71498f0ca3fcfc07dfff6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0b4bcdf78e512fbe3f5223750078d8"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#adb0b4bcdf78e512fbe3f5223750078d8">CallCustomApi</a> ([in] VARIANT procOrId, [in] BSTR dllFileName, [in] BSTR apiToCall, [in, defaultvalue(NULL)] VARIANT *params, [in, defaultvalue(<a class="el" href="_deviare_c_o_m_8idl.html#aa653314cc120a0d2157582fc6311ecd8">MY_VARIANT_FALSE</a>)] VARIANT_BOOL sync, [out, retval] LONG *pVal)</td></tr>
<tr class="memdesc:adb0b4bcdf78e512fbe3f5223750078d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a custom API in the target process.  <a href="#adb0b4bcdf78e512fbe3f5223750078d8">More...</a><br /></td></tr>
<tr class="separator:adb0b4bcdf78e512fbe3f5223750078d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e386f540e163a33546234af9d2b93d"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a61e386f540e163a33546234af9d2b93d">ProcessFromPID</a> ([in] LONG pid, [out, retval] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> **ppProc)</td></tr>
<tr class="memdesc:a61e386f540e163a33546234af9d2b93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a process object from the specified process ID.  <a href="#a61e386f540e163a33546234af9d2b93d">More...</a><br /></td></tr>
<tr class="separator:a61e386f540e163a33546234af9d2b93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9d932ad922c0007abbdd48c8e33751"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a6e9d932ad922c0007abbdd48c8e33751">ProcessMemoryFromPID</a> ([in] LONG pid, [out, retval] <a class="el" href="interface_i_nkt_process_memory.html">INktProcessMemory</a> **ppProcMem)</td></tr>
<tr class="memdesc:a6e9d932ad922c0007abbdd48c8e33751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a process memory reader/writer object from the specified process id.  <a href="#a6e9d932ad922c0007abbdd48c8e33751">More...</a><br /></td></tr>
<tr class="separator:a6e9d932ad922c0007abbdd48c8e33751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600a156b323a475170bbfe9143a34db2"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a600a156b323a475170bbfe9143a34db2">CreateProcess</a> ([in] BSTR imagePath, [in, defaultvalue(<a class="el" href="_deviare_c_o_m_8idl.html#aa653314cc120a0d2157582fc6311ecd8">MY_VARIANT_FALSE</a>)] VARIANT_BOOL suspended, [out, defaultvalue(NULL)] VARIANT *continueEvent, [out, retval] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> **ppProc)</td></tr>
<tr class="memdesc:a600a156b323a475170bbfe9143a34db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new process.  <a href="#a600a156b323a475170bbfe9143a34db2">More...</a><br /></td></tr>
<tr class="separator:a600a156b323a475170bbfe9143a34db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0855ed445315c92821815bc730af8ff0"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a0855ed445315c92821815bc730af8ff0">CreateProcessWithLogon</a> ([in] BSTR imagePath, [in] BSTR userName, [in] BSTR password, [in, defaultvalue(<a class="el" href="_deviare_c_o_m_8idl.html#aa653314cc120a0d2157582fc6311ecd8">MY_VARIANT_FALSE</a>)] VARIANT_BOOL suspended, [out, defaultvalue(NULL)] VARIANT *continueEvent, [out, retval] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> **ppProc)</td></tr>
<tr class="memdesc:a0855ed445315c92821815bc730af8ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new process under an arbitrary user impersonation.  <a href="#a0855ed445315c92821815bc730af8ff0">More...</a><br /></td></tr>
<tr class="separator:a0855ed445315c92821815bc730af8ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dce12ed83afab1c9a45cc1c181839d"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a21dce12ed83afab1c9a45cc1c181839d">CreateProcessWithToken</a> ([in] BSTR imagePath, [in] my_ssize_t token, [in, defaultvalue(<a class="el" href="_deviare_c_o_m_8idl.html#aa653314cc120a0d2157582fc6311ecd8">MY_VARIANT_FALSE</a>)] VARIANT_BOOL suspended, [out, defaultvalue(NULL)] VARIANT *continueEvent, [out, retval] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> **ppProc)</td></tr>
<tr class="memdesc:a21dce12ed83afab1c9a45cc1c181839d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new process under an arbitrary user impersonation.  <a href="#a21dce12ed83afab1c9a45cc1c181839d">More...</a><br /></td></tr>
<tr class="separator:a21dce12ed83afab1c9a45cc1c181839d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745364cf0fd339a951507dae0cabb322"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a745364cf0fd339a951507dae0cabb322">ResumeProcess</a> ([in] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> *pProc, [in] VARIANT continueEvent)</td></tr>
<tr class="memdesc:a745364cf0fd339a951507dae0cabb322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a suspended process created with CreateProcess, CreateProcessWithToken or CreateProcessWithLogon functions.  <a href="#a745364cf0fd339a951507dae0cabb322">More...</a><br /></td></tr>
<tr class="separator:a745364cf0fd339a951507dae0cabb322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b7e836e1c53ae158209c5081ddb6d5"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a90b7e836e1c53ae158209c5081ddb6d5">TerminateProcess</a> ([in] VARIANT procOrId, [in] LONG exitCode)</td></tr>
<tr class="memdesc:a90b7e836e1c53ae158209c5081ddb6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate an existing running process.  <a href="#a90b7e836e1c53ae158209c5081ddb6d5">More...</a><br /></td></tr>
<tr class="separator:a90b7e836e1c53ae158209c5081ddb6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af4304aeb96a4059d2084f68fbbf3be"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a9af4304aeb96a4059d2084f68fbbf3be">FindProcessId</a> ([in] BSTR name, [out, retval] LONG *pVal)</td></tr>
<tr class="memdesc:a9af4304aeb96a4059d2084f68fbbf3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the process id from the specified image name.  <a href="#a9af4304aeb96a4059d2084f68fbbf3be">More...</a><br /></td></tr>
<tr class="separator:a9af4304aeb96a4059d2084f68fbbf3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2177789fa08404dd86bf9bb54184e0"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#ace2177789fa08404dd86bf9bb54184e0">RealFilePath</a> ([in] BSTR name, [out, retval] BSTR *pVal)</td></tr>
<tr class="memdesc:ace2177789fa08404dd86bf9bb54184e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complete filesystem path of the file.  <a href="#ace2177789fa08404dd86bf9bb54184e0">More...</a><br /></td></tr>
<tr class="separator:ace2177789fa08404dd86bf9bb54184e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c1541c346d17bdef88e75583662ac4"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a03c1541c346d17bdef88e75583662ac4">DbObjects</a> ([in] LONG platformBits, [out, retval] <a class="el" href="interface_i_nkt_db_objects_enum.html">INktDbObjectsEnum</a> **ppObjsEnum)</td></tr>
<tr class="memdesc:a03c1541c346d17bdef88e75583662ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a database-object enumerator.  <a href="#a03c1541c346d17bdef88e75583662ac4">More...</a><br /></td></tr>
<tr class="separator:a03c1541c346d17bdef88e75583662ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9204af29a551aa2b37d77daf8b603081"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a9204af29a551aa2b37d77daf8b603081">DbFunctions</a> ([in] LONG platformBits, [out, retval] <a class="el" href="interface_i_nkt_db_objects_enum.html">INktDbObjectsEnum</a> **ppFuncsEnum)</td></tr>
<tr class="memdesc:a9204af29a551aa2b37d77daf8b603081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a database-function enumerator.  <a href="#a9204af29a551aa2b37d77daf8b603081">More...</a><br /></td></tr>
<tr class="separator:a9204af29a551aa2b37d77daf8b603081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206c63a2bfcc1333945fff42288414f9"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a206c63a2bfcc1333945fff42288414f9">DbModules</a> ([in] LONG platformBits, [out, retval] <a class="el" href="interface_i_nkt_db_modules_enum.html">INktDbModulesEnum</a> **ppModsEnum)</td></tr>
<tr class="memdesc:a206c63a2bfcc1333945fff42288414f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a database modules enumerator.  <a href="#a206c63a2bfcc1333945fff42288414f9">More...</a><br /></td></tr>
<tr class="separator:a206c63a2bfcc1333945fff42288414f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1739721ca4962821e29dddd076fb8864"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a1739721ca4962821e29dddd076fb8864">ProcessHandle</a> ([in] VARIANT procOrId, [in] LONG desiredAccess, [out, retval] my_ssize_t *pVal)</td></tr>
<tr class="memdesc:a1739721ca4962821e29dddd076fb8864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a process handle.  <a href="#a1739721ca4962821e29dddd076fb8864">More...</a><br /></td></tr>
<tr class="separator:a1739721ca4962821e29dddd076fb8864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e229bc57db32466405c380fee4a16b5"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#a9e229bc57db32466405c380fee4a16b5">ProcessMemory</a> ([in] VARIANT procOrId, [out, retval] <a class="el" href="interface_i_nkt_process_memory.html">INktProcessMemory</a> **ppProcMem)</td></tr>
<tr class="separator:a9e229bc57db32466405c380fee4a16b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fe9193a7aa0d6954833e9b6862c301"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_spy_mgr.html#ab7fe9193a7aa0d6954833e9b6862c301">GetWindowProc</a> ([in] VARIANT procOrId, [in] my_ssize_t hWnd, [out, retval] my_ssize_t *ppWndProc)</td></tr>
<tr class="memdesc:ab7fe9193a7aa0d6954833e9b6862c301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address for a window procedure in a specific process.  <a href="#ab7fe9193a7aa0d6954833e9b6862c301">More...</a><br /></td></tr>
<tr class="separator:ab7fe9193a7aa0d6954833e9b6862c301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interface_i_nkt_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interface_i_nkt_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="interface_i_nkt_object.html">INktObject</a></td></tr>
<tr class="memitem:ae8181e051fa9823d5bc3136bc543b195 inherit pub_methods_interface_i_nkt_object"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_object.html#ae8181e051fa9823d5bc3136bc543b195">UserData</a> ([out, retval] my_ssize_t *pVal)</td></tr>
<tr class="memdesc:ae8181e051fa9823d5bc3136bc543b195 inherit pub_methods_interface_i_nkt_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a user-defined custom data.  <a href="#ae8181e051fa9823d5bc3136bc543b195">More...</a><br /></td></tr>
<tr class="separator:ae8181e051fa9823d5bc3136bc543b195 inherit pub_methods_interface_i_nkt_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313aea97450ff5a26135bdcdb43f5284 inherit pub_methods_interface_i_nkt_object"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_object.html#a313aea97450ff5a26135bdcdb43f5284">UserData</a> ([in] my_ssize_t newValue)</td></tr>
<tr class="memdesc:a313aea97450ff5a26135bdcdb43f5284 inherit pub_methods_interface_i_nkt_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user-defined custom data.  <a href="#a313aea97450ff5a26135bdcdb43f5284">More...</a><br /></td></tr>
<tr class="separator:a313aea97450ff5a26135bdcdb43f5284 inherit pub_methods_interface_i_nkt_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a98e869d5385b1813b5a4c16e980161 inherit pub_methods_interface_i_nkt_object"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_object.html#a0a98e869d5385b1813b5a4c16e980161">InterfaceError</a> ([out, retval] LONG *pVal)</td></tr>
<tr class="memdesc:a0a98e869d5385b1813b5a4c16e980161 inherit pub_methods_interface_i_nkt_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error code raised when this object was created.  <a href="#a0a98e869d5385b1813b5a4c16e980161">More...</a><br /></td></tr>
<tr class="separator:a0a98e869d5385b1813b5a4c16e980161 inherit pub_methods_interface_i_nkt_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97be6fc89d3f5d535a7dfc4408459720 inherit pub_methods_interface_i_nkt_object"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_object.html#a97be6fc89d3f5d535a7dfc4408459720">DeviareId</a> ([out, retval] my_ssize_t *pVal)</td></tr>
<tr class="memdesc:a97be6fc89d3f5d535a7dfc4408459720 inherit pub_methods_interface_i_nkt_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of the object.  <a href="#a97be6fc89d3f5d535a7dfc4408459720">More...</a><br /></td></tr>
<tr class="separator:a97be6fc89d3f5d535a7dfc4408459720 inherit pub_methods_interface_i_nkt_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03024f208e03a68af13250c9680218f inherit pub_methods_interface_i_nkt_object"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_object.html#ac03024f208e03a68af13250c9680218f">ToString</a> ([out, retval] BSTR *pVal)</td></tr>
<tr class="memdesc:ac03024f208e03a68af13250c9680218f inherit pub_methods_interface_i_nkt_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string representation of the object.  <a href="#ac03024f208e03a68af13250c9680218f">More...</a><br /></td></tr>
<tr class="separator:ac03024f208e03a68af13250c9680218f inherit pub_methods_interface_i_nkt_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644e78b6a4cc1a802264d497d325e62d inherit pub_methods_interface_i_nkt_object"><td class="memItemLeft" align="right" valign="top">HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_nkt_object.html#a644e78b6a4cc1a802264d497d325e62d">GetObjectFromDeviareId</a> ([in] my_ssize_t devId, [out, retval] IDispatch **ppDisp)</td></tr>
<tr class="memdesc:a644e78b6a4cc1a802264d497d325e62d inherit pub_methods_interface_i_nkt_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an object given its id.  <a href="#a644e78b6a4cc1a802264d497d325e62d">More...</a><br /></td></tr>
<tr class="separator:a644e78b6a4cc1a802264d497d325e62d inherit pub_methods_interface_i_nkt_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is central Deviare interface. It exposes methods for initializing and configuring the interception engine; working with hooks, agents and custom DLLs; and obtaining interfaces to access to process, memory and similar system objects. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6bfb2b31ca5c7092209e6da169942d25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::AgentPath </td>
          <td>(</td>
          <td class="paramtype">[out, retval] BSTR *&#160;</td>
          <td class="paramname"><em>pVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the agent DLL path. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The agent DLL path is read-only after engine initialization.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVal</td><td>Pointer to string to receive the agent DLL path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_OUTOFMEMORY</code> if provided string buffer has insufficient space. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="aa89d53d61133662baae06c196137dd3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::AgentPath </td>
          <td>(</td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the agent DLL path (read-only after initialization). </p>
<dl class="section remark"><dt>Remarks</dt><dd>The agent DLL path is read-only after engine initialization.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValue</td><td>The new value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_INVALIDARG</code> is the provided string is not valid. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="adb0b4bcdf78e512fbe3f5223750078d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::CallCustomApi </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>procOrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>dllFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>apiToCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in, defaultvalue(NULL)] VARIANT *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] LONG *&#160;</td>
          <td class="paramname"><em>pVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a custom API in the target process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">procOrId</td><td>A variant containing either a process identifier (PID) or a pointer to a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dllFileName</td><td>Filename of the DLL file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">apiToCall</td><td>The API function to call. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params</td><td>A pointer to an array of variants with the parameters to pass. Supported element types are single or arrays of 1, 2, 4 or 8-byte integers, signed or unsigned. In terms of Win32 VARIANT VT constants: VT_Ix, VT_UIx and VT_Ix|VT_ARRAY, VT_IUx|VT_ARRAY, where x=1,2,4 or 8. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sync</td><td><code>TRUE</code> to call in synchronous mode. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVal</td><td>A pointer to receive a cookie identifying this call in completion event, during asynchronous mode. For sync operation, this is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if any pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if procOrId does not contain a LONG integer representing a PID (or compatible type), or a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface pointer. </dd>
<dd>
<code>E_INVALIDARG</code> if parameter array contains a variant with one or more unsupported types. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4566f4a2e83409be783658eb2fa68de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::CreateHook </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>hookFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_hook.html">INktHook</a> **&#160;</td>
          <td class="paramname"><em>ppHook</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a hook to intercept the provided function name or an <a class="el" href="interface_i_nkt_exported_function.html" title="Exposes methods for accessing exported functions. ">INktExportedFunction</a> compatible object. </p>
<p>The function names should be passed in the format "[dll]![function name]" (example: "kernel32.dll!CreateFileW").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">func</td><td>A variant containing either a function name string or a pointer to a <a class="el" href="interface_i_nkt_exported_function.html" title="Exposes methods for accessing exported functions. ">INktExportedFunction</a> interface. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hookFlags</td><td>The hook flags. Any combination is allowed. See <a class="el" href="_deviare_c_o_m_8idl.html#a4033c264d8769a1cb135e6ffde8160e1">eNktHookFlags</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppHook</td><td>A pointer to receive the created hook.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL, or VARIANT contains a null pointer. </dd>
<dd>
<code>E_INVALIDARG</code> if variant type is not VT_BSTR (string), VT_DISPATCH or VT_UNKNOWN (<a class="el" href="interface_i_nkt_exported_function.html" title="Exposes methods for accessing exported functions. ">INktExportedFunction</a> compatible). </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="aceba92965a3615860fe674b6c8be47ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::CreateHookForAddress </td>
          <td>(</td>
          <td class="paramtype">[in] my_ssize_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>functionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>hookFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_hook.html">INktHook</a> **&#160;</td>
          <td class="paramname"><em>ppHook</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a hook to intercept a function specified by its memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">addr</td><td>The memory address related to the function to intercept. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">functionName</td><td>An optional function name to associate to this hook. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">hookFlags</td><td>The hook flags. See <a class="el" href="_deviare_c_o_m_8idl.html#a4033c264d8769a1cb135e6ffde8160e1">eNktHookFlags</a> enumeration. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppHook</td><td>A pointer to receive the created hook.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa9b037c2fe58be5ab48bcd0ffd5e7e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::CreateHooksCollection </td>
          <td>(</td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_hooks_enum.html">INktHooksEnum</a> **&#160;</td>
          <td class="paramname"><em>ppHooksEnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a hook collection object. Collections of hooks are a convenience feature for grouping several hooks in one manageable interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppHooksEnum</td><td>A pointer to receive the <a class="el" href="interface_i_nkt_hooks_enum.html" title="Exposes methods for enumerating INktHook based collections. ">INktHooksEnum</a> enumerator interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a600a156b323a475170bbfe9143a34db2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::CreateProcess </td>
          <td>(</td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>imagePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL&#160;</td>
          <td class="paramname"><em>suspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, defaultvalue(NULL)] VARIANT *&#160;</td>
          <td class="paramname"><em>continueEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> **&#160;</td>
          <td class="paramname"><em>ppProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">imagePath</td><td>Full pathname of the image file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">suspended</td><td>If <code>TRUE</code>, process is created on suspended state. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">continueEvent</td><td>If process was created in suspended state, this is a pointer to receive a cookie to supply the ResumeProcess method to resume the process execution. Can be NULL if suspended parameter is <code>FALSE</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppProc</td><td>If successful, a pointer to receive the <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface identifying the new process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a0855ed445315c92821815bc730af8ff0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::CreateProcessWithLogon </td>
          <td>(</td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>imagePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>userName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL&#160;</td>
          <td class="paramname"><em>suspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, defaultvalue(NULL)] VARIANT *&#160;</td>
          <td class="paramname"><em>continueEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> **&#160;</td>
          <td class="paramname"><em>ppProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new process under an arbitrary user impersonation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">imagePath</td><td>Full pathname of the image file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">userName</td><td>User name of the user the new process will belong to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">password</td><td>Password of the user. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">suspended</td><td>If <code>TRUE</code>, process is created on suspended state. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">continueEvent</td><td>If process was created in suspended state, this is a pointer to receive a cookie to supply the ResumeProcess method to resume the process execution. Can be NULL if suspended parameter is <code>FALSE</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppProc</td><td>If successful, a pointer to receive the <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface identifying the new process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_INVALIDARG</code> if userName and/or password argument(s) are invalid; or the token is an invalid handle. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd>
<dd>
<code>NKT_DVERR_NotSupported</code> this operation is not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="a21dce12ed83afab1c9a45cc1c181839d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::CreateProcessWithToken </td>
          <td>(</td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>imagePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] my_ssize_t&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL&#160;</td>
          <td class="paramname"><em>suspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, defaultvalue(NULL)] VARIANT *&#160;</td>
          <td class="paramname"><em>continueEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> **&#160;</td>
          <td class="paramname"><em>ppProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new process under an arbitrary user impersonation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">imagePath</td><td>Full pathname of the image file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">token</td><td>Token handle that belongs to the logged used. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">password</td><td>Password of the user. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">suspended</td><td>If <code>TRUE</code>, process is created on suspended state. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">continueEvent</td><td>If process was created in suspended state, this is a pointer to receive a cookie to supply the ResumeProcess method to resume the process execution. Can be NULL if suspended parameter is <code>FALSE</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppProc</td><td>If successful, a pointer to receive the <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface identifying the new process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_INVALIDARG</code> if userName and/or password argument(s) are invalid. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd>
<dd>
<code>NKT_DVERR_NotSupported</code> this operation is not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="afd0d543b479d027fbe710595670d7c7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::DatabasePath </td>
          <td>(</td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the database path. </p>
<p>Set the database path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVal</td><td>Pointer to String to receive the database path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The database path is read-only after engine initialization.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_OUTOFMEMORY</code> if provided string buffer has insufficient space. </dd>
<dd>
<code>E_FAIL</code> on general error.</dd></dl>
<p>[propget, helpstring("Get/Set the database path (read-only after initialization)"), id(dispidNktSpyMgrDatabasePath)] HRESULT DatabasePath([out, retval] BSTR *pVal);</p>
<p>/**</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newValue</td><td>The new value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The database path is read-only after engine initialization.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_INVALIDARG</code> is the provided string is not valid. </dd>
<dd>
<code>NKT_DVERR_AlreadyInitialized</code> if the engine is already initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9204af29a551aa2b37d77daf8b603081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::DbFunctions </td>
          <td>(</td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>platformBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_db_objects_enum.html">INktDbObjectsEnum</a> **&#160;</td>
          <td class="paramname"><em>ppFuncsEnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a database-function enumerator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">platformBits</td><td>The platform bits. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppFuncsEnum</td><td>A pointer to receive the enumerator interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if specified bitness is not 32/64, or not valid for the current architecture. </dd>
<dd>
<code>E_OUTOFMEMORY</code> if provided string buffer is insufficient. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a206c63a2bfcc1333945fff42288414f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::DbModules </td>
          <td>(</td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>platformBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_db_modules_enum.html">INktDbModulesEnum</a> **&#160;</td>
          <td class="paramname"><em>ppModsEnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a database modules enumerator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">platformBits</td><td>The platform bits. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppModsEnum</td><td>A pointer to receive the enumerator interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if specified bitness is not 32/64, or not valid for the current architecture. </dd>
<dd>
<code>E_OUTOFMEMORY</code> if provided string buffer is insufficient. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a03c1541c346d17bdef88e75583662ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::DbObjects </td>
          <td>(</td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>platformBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_db_objects_enum.html">INktDbObjectsEnum</a> **&#160;</td>
          <td class="paramname"><em>ppObjsEnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a database-object enumerator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">platformBits</td><td>The platform bits. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppObjsEnum</td><td>A pointer to receive the enumerator interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if specified bitness is not 32/64, or not valid for the current architecture. </dd>
<dd>
<code>E_OUTOFMEMORY</code> if provided string buffer is insufficient. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b47205814f75e7bfae6b88dd518caa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::DestroyHook </td>
          <td>(</td>
          <td class="paramtype">[in] <a class="el" href="interface_i_nkt_hook.html">INktHook</a> *&#160;</td>
          <td class="paramname"><em>hook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a hook. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hook</td><td>A pointer to the hook object to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9af4304aeb96a4059d2084f68fbbf3be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::FindProcessId </td>
          <td>(</td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] LONG *&#160;</td>
          <td class="paramname"><em>pVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the process id from the specified image name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The image name. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVal</td><td>Pointer to receive the PID value, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7fe9193a7aa0d6954833e9b6862c301"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::GetWindowProc </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>procOrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] my_ssize_t&#160;</td>
          <td class="paramname"><em>hWnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] my_ssize_t *&#160;</td>
          <td class="paramname"><em>ppWndProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the address for a window procedure in a specific process. </p>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a00ad3139833d3e91774475a20b0466a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::Hooks </td>
          <td>(</td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_hooks_enum.html">INktHooksEnum</a> **&#160;</td>
          <td class="paramname"><em>ppHooksEnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a hook enumerator object representing the existent hooks on this engine instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppHooksEnum</td><td>A pointer to receive the <a class="el" href="interface_i_nkt_hooks_enum.html" title="Exposes methods for enumerating INktHook based collections. ">INktHooksEnum</a> enumerator interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a5175c32dc94e608c22a7b42da93d2bf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::Initialize </td>
          <td>(</td>
          <td class="paramtype">[out, retval] LONG *&#160;</td>
          <td class="paramname"><em>pVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the Spy Manager system. </p>
<p>This method MUST be called before using any instance of <a class="el" href="interface_i_nkt_spy_mgr.html" title="This is central Deviare interface. It exposes methods for initializing and configuring the intercepti...">INktSpyMgr</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pVal</td><td>0 on success, eNktErrorCodes or regular HRESULT error code on fail. Common codes: <code>E_FILENOTFOUND</code> if database files could not be found. For 64-bit applications, both 32bit and 64-bit Database AND Agent DLLs are required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For performance oriented applications, we recommend to switch to multithreaded-apartment mode before Deviare initialization. For C++ applications, it's enough to call:</dd></dl>
<p><code>CoInitializeEx(NULL, COINIT_MULTITHREADED)</code>;</p>
<p>For C# use the <code></code>[MTAThread] attribute.</p>
<p>For more information on threading apartment, please check your programming language and/or library reference. Note that MTA-threading mode may be incompatible and/or provoke unexpected side effects when used with some COM and .NET components. For example, WinForms applications do not support MTA.</p>
<dl class="section return"><dt>Returns</dt><dd>S_OK on success or E_FAIL on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ca4ab2125935247bc01f80175a5d6c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::LoadAgent </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>procOrId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the agent DLL in the target process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procOrId</td><td>A variant containing either a process identifier (PID) or a pointer to a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if variant does not contain a LONG integer representing a PID (or compatible type), or a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface pointer. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a2538cb91b479817f7a2ad0dc3fa875ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::LoadCustomDll </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>procOrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>dllFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in, defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL&#160;</td>
          <td class="paramname"><em>unloadOnAgentShutdown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] LONG *&#160;</td>
          <td class="paramname"><em>pActionId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a custom DLL in a target process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">procOrId</td><td>A variant containing either a process identifier (PID) or a pointer to a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dllFileName</td><td>Filename of the DLL file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">unloadOnAgentShutdown</td><td>If <code>TRUE</code>, the DLL will be automatically unloaded when Agent shuts down; remains loaded in the target process otherwise. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sync</td><td><code>TRUE</code> to call in synchronous mode. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pActionId</td><td>A pointer to receive a cookie identifying this call in completion event, during asynchronous mode. In a synchronous operation, this is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The DLL to load must export a set of functions identified by the following C signatures:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> HRESULT (WINAPI *lpfnUserFunc0)();</div><div class="line"><span class="keyword">typedef</span> HRESULT (WINAPI *lpfnUserFunc1)(SIZE_T nParam1);</div><div class="line"><span class="keyword">typedef</span> HRESULT (WINAPI *lpfnUserFunc2)(SIZE_T nParam1, SIZE_T nParam2);</div><div class="line"><span class="keyword">typedef</span> HRESULT (WINAPI *lpfnUserFunc3)(SIZE_T nParam1, SIZE_T nParam2, SIZE_T nParam3);</div><div class="line"><span class="keyword">typedef</span> HRESULT (WINAPI *lpfnUserFunc4)(SIZE_T nParam1, SIZE_T nParam2, SIZE_T nParam3, SIZE_T nParam4);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if variant does not contain a LONG integer representing a PID (or compatible type), or a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface pointer. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9df1004e5e6e2d44dd0975c4aab4d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::Processes </td>
          <td>(</td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_processes_enum.html">INktProcessesEnum</a> **&#160;</td>
          <td class="paramname"><em>ppProcsEnum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the currently running processes. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The engine updates this list at an approximate rate of 10 times per second.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ppProcsEnum</td><td>A pointer to receive the <a class="el" href="interface_i_nkt_processes_enum.html" title="Exposes methods for enumerating a INktProcess collection. ">INktProcessesEnum</a> enumerator interface to retrieve the running processes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a61e386f540e163a33546234af9d2b93d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::ProcessFromPID </td>
          <td>(</td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> **&#160;</td>
          <td class="paramname"><em>ppProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a process object from the specified process ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pid</td><td>The process identifier. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppProc</td><td>A pointer to receive the <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if the specified PID is not valid. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1739721ca4962821e29dddd076fb8864"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::ProcessHandle </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>procOrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>desiredAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] my_ssize_t *&#160;</td>
          <td class="paramname"><em>pVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a process handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">procOrId</td><td>A variant containing either a process identifier (PID) or a pointer to a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">desiredAccess</td><td>The desired access mode. If you specify NULL, the default security descriptor is used. See <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx">Process Security and Access Rights</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVal</td><td>A pointer to receive a pointer-sized handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_INVALIDARG</code> if variant does not contain a LONG integer representing a PID (or compatible type), or a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface pointer. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized or the handle cannot be obtained using the selected access mode. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e229bc57db32466405c380fee4a16b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::ProcessMemory </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>procOrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_process_memory.html">INktProcessMemory</a> **&#160;</td>
          <td class="paramname"><em>ppProcMem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e9d932ad922c0007abbdd48c8e33751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::ProcessMemoryFromPID </td>
          <td>(</td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] <a class="el" href="interface_i_nkt_process_memory.html">INktProcessMemory</a> **&#160;</td>
          <td class="paramname"><em>ppProcMem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a process memory reader/writer object from the specified process id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">pid</td><td>The process identifier. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ppProcMem</td><td>A pointer to receive the <a class="el" href="interface_i_nkt_process_memory.html" title="Exposes methods for accessing process memory. ">INktProcessMemory</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if the specified PID is not valid. </dd>
<dd>
<code>E_OUTOFMEMORY</code> is process memory object cannot be accessed or created. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="ace2177789fa08404dd86bf9bb54184e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::RealFilePath </td>
          <td>(</td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] BSTR *&#160;</td>
          <td class="paramname"><em>pVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the complete filesystem path of the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The name of the file. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pVal</td><td>A pointer to string to receive the full path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if provided filename is invalid. </dd>
<dd>
<code>E_OUTOFMEMORY</code> if provided string buffer is insufficient. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a745364cf0fd339a951507dae0cabb322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::ResumeProcess </td>
          <td>(</td>
          <td class="paramtype">[in] <a class="el" href="interface_i_nkt_process.html">INktProcess</a> *&#160;</td>
          <td class="paramname"><em>pProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>continueEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a suspended process created with CreateProcess, CreateProcessWithToken or CreateProcessWithLogon functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pProc</td><td>A pointer to the process object to resume. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">continueEvent</td><td>The continue-event cookie obtained from the process creation call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if the continueEvent cookie is invalid or the variant contains an unsupported type. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="aff26f5648f3056461e1ba8b49b6c2ecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::SettingOverride </td>
          <td>(</td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>setting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overrides a Deviare engine setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">setting</td><td>Name of setting to override. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newValue</td><td>New value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The following settings are available:</dd></dl>
<table class="doxtable">
<tr>
<th>Setting </th><th>Meaning </th><th>Default  </th></tr>
<tr>
<td><code>SpyMgrDebugLevelMask</code> </td><td>A set of flags affecting SpyMgr component debugging output. See "Debug Flags" below </td><td>0 </td></tr>
<tr>
<td><code>SpyMgrAgentLevelMask</code> </td><td>A set of flags affecting agent component debugging output. See "Debug Flags" below </td><td>0 </td></tr>
<tr>
<td><code>SpyMgrMemMgrPoolMaxAge</code> </td><td>The time in milliseconds a free block will remain in memory until released to the operating system </td><td>10000 </td></tr>
<tr>
<td><code>SpyMgrTransportMaxInUseMessageCount</code> </td><td>Reserved </td><td>Reserved </td></tr>
<tr>
<td><code>SpyMgrTransportMaxFreeBufferList</code> </td><td>Reserved </td><td>Reserved </td></tr>
<tr>
<td><code>SpyMgrMemMgrPoolCheckFrequency</code> </td><td>The frequency where the LRU blocks are checked and discarded </td><td>128 </td></tr>
<tr>
<td><code>SpyMgrTransportMessageDelay</code> </td><td>Time in milliseconds in message delivery in order to keep memory usage low until more buffers became available. SpyMgrMaxInUseTransportMessageCount and AgentMaxInUseTransportMessageCount sets the maximum message count to send/receive before starting the delay operation </td><td>50 </td></tr>
<tr>
<td><code>AgentMemMgrPoolMaxAge</code> </td><td>Reserved </td><td>Reserved </td></tr>
<tr>
<td><code>AgentMemMgrPoolCheckFrequency</code> </td><td>Reserved </td><td>Reserved </td></tr>
<tr>
<td><code>AgentTransportMaxFreeBufferList</code> </td><td>Reserved </td><td>Reserved </td></tr>
<tr>
<td><code>AgentTransportMaxInUseMessageCount</code> </td><td>Reserved </td><td>Reserved </td></tr>
<tr>
<td><code>AgentTransportMessageDelay</code> </td><td>Time in milliseconds in message delivery in order to keep memory usage low until more buffers became available. SpyMgrMaxInUseTransportMessageCount and AgentMaxInUseTransportMessageCount sets the maximum message count to send/receive before starting the delay operation </td><td>50 </td></tr>
<tr>
<td><code>AgentLoadTimeout</code> </td><td>Time in milliseconds to wait for agent loading </td><td>10000 </td></tr>
</table>
<p>Unless you need specific application requeriments, Deviare is by default optimized for most usage scenarios.</p>
<p>Debug Flags available:</p>
<ul>
<li>Tools = <code>0x00000008</code> </li>
<li>Transport = <code>0x00000010</code> </li>
<li>Engine = <code>0x00000020</code> </li>
<li>Agent = <code>0x00000040</code> </li>
<li>HookEngine = <code>0x00000080</code> </li>
<li>HookEnginePreCall = <code>0x00000100</code> </li>
<li>HookEnginePostCall = <code>0x00000200</code> </li>
<li>Error = <code>0x00000400</code> </li>
<li>Warning = <code>0x00000800</code> </li>
<li>dlInformation = <code>0x00002000</code> </li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if BSTR parameter is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if specified parameter is invalid does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a90b7e836e1c53ae158209c5081ddb6d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::TerminateProcess </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>procOrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] LONG&#160;</td>
          <td class="paramname"><em>exitCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate an existing running process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procOrId</td><td>A variant containing either a process identifier (PID) or a pointer to a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface. </td></tr>
    <tr><td class="paramname">exitCode</td><td>The exit code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_INVALIDARG</code> if variant does not contain a LONG integer representing a PID (or compatible type), or a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface pointer. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f652d23e914219cb2be441852e95d02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::UnloadAgent </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>procOrId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces agent unload from the target process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">procOrId</td><td>A variant containing either a process identifier (PID) or a pointer to a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if variant does not contain a LONG integer representing a PID (or compatible type), or a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface pointer. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
<a class="anchor" id="a149f4decc71498f0ca3fcfc07dfff6ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HRESULT INktSpyMgr::UnloadCustomDll </td>
          <td>(</td>
          <td class="paramtype">[in] VARIANT&#160;</td>
          <td class="paramname"><em>procOrId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in] BSTR&#160;</td>
          <td class="paramname"><em>dllFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[out, retval] LONG *&#160;</td>
          <td class="paramname"><em>pVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unloads a custom DLL from a target process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">procOrId</td><td>A variant containing either a process identifier (PID) or a pointer to a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dllFileName</td><td>Filename of the DLL file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sync</td><td><code>TRUE</code> to call in synchronous mode. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pActionId</td><td>A pointer to receive a cookie identifying this call in completion event, during asynchronous mode. In a synchronous operation, this is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>S_OK</code> on success. </dd>
<dd>
<code>E_POINTER</code> if pointer argument is NULL. </dd>
<dd>
<code>E_INVALIDARG</code> if variant does not contain a LONG integer representing a PID (or compatible type), or a <a class="el" href="interface_i_nkt_process.html" title="Exposes methods for accessing system processes. ">INktProcess</a> interface pointer. </dd>
<dd>
<code>E_ACCESSDENIED</code> if engine is not initialized. </dd>
<dd>
<code>E_FAIL</code> on general error. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<br>
<br>
<p align = "right">Developed by <a href="http://www.nektra.com" target="_blank">Nektra Advanced Computing</a></p>
<script type="text/javascript"> 
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script> 
<script type="text/javascript"> 
try {
var pageTracker = _gat._getTracker("UA-562204-2");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>