/*! \mainpage Deviare API HOOK 
 * 
 * \section intro_sec Introduction 
 * 
 * Deviare API is a professional API hook engine that was designed to create end user products.
 * Intercepting applications is a complex task which can take place in many different scenarios.
 * We continually test all these scenarios to avoid unpleasent crashes that might cause the end
 * user to uninstall your product. Most popular Hook engines do not address these issues.
 * Although they work in many situations, a trully professional hook engine must work in all
 * situations. Nektra's Deviare API is a generic API interception engine. Its main difference
 * from other hook engines is that it allows you to intercept different functions with a single
 * handler and decide which functions to hook at runtime. To intercept APIs with any other
 * product you have to write a specific handler that runs in the target process context.
 * 
 * Deviare API provides a COM interface supported by most programming languages such as C++,
 * Delphi, VB, VB.SCRIPT, VB.NET, C# and Python.
 *
 * <a href="http://wiki.nektra.com/Quickstart_v.2.0">Quick Start</a>   
 */

/*
 * Copyright (C) 2010-2015 Nektra S.A., Buenos Aires, Argentina.
 * All rights reserved. Contact: http://www.nektra.com
 *
 *
 * This file is part of Deviare
 *
 *
 * Commercial License Usage
 * ------------------------
 * Licensees holding valid commercial Deviare licenses may use this file
 * in accordance with the commercial license agreement provided with the
 * Software or, alternatively, in accordance with the terms contained in
 * a written agreement between you and Nektra.  For licensing terms and
 * conditions see http://www.nektra.com/licensing/. Use the contact form
 * at http://www.nektra.com/contact/ for further information.
 *
 *
 * GNU General Public License Usage
 * --------------------------------
 * Alternatively, this file may be used under the terms of the GNU General
 * Public License version 3.0 as published by the Free Software Foundation
 * and appearing in the file LICENSE.GPL included in the packaging of this
 * file.  Please visit http://www.gnu.org/copyleft/gpl.html and review the
 * information to ensure the GNU General Public License version 3.0
 * requirements will be met.
 *
 **/

//VERY IMPORTANT NOTE: I don't know the reason (may be the inheritance of interfaces) but the
//-------------------  proxy/stub code generated is broken with the default /Oicf MIDL compiler
//                     switch. BE SURE to add "/Os" to the additional options in the MIDL settings.
//                     Also set the "Generate stubless proxy" to NO and put inside a comment the
//                     "#define USE_STUBLESS_PROXY" sentence in 'DllDataX.c'
//                     With these settings now an object can be successfully marshalled between
//                     two STA threads.

import "oaidl.idl";
import "ocidl.idl";

#include "idl_size_t.h"
#include "disp_ids.h"
#include "idl_csharp_support.h"

#define MY_VARIANT_FALSE   0 //avoid midl compiler errors
#define MY_VARIANT_TRUE   -1 //in defaultvalue values

//-----------------------------------------------------------

interface INktObject;
interface INktSpyMgr;
interface INktProcess;
interface INktProcessEnum;
interface INktModule;
interface INktModulesEnum;
interface INktExportedFunction;
interface INktExportedFunctionsEnum;
interface INktHook;
interface INktHooksEnum;
interface INktParam;
interface INktParamsEnum;
interface INktHookCallInfo;
interface INktProcessMemory;
interface INktStackTrace;
interface INktDbObject;
interface INktDbObjectsEnum;
interface INktDbModule;
interface INktDbModulesEnum;
interface INktTools;
interface INktHookCallInfoPlugin;
interface INktHookInfo;
interface INktStructPEFileHeader;
interface INktStructPEOptionalHeader;
interface INktStructPESections;
interface INktPdbFunctionSymbol;

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \enum eNktErrorCodes
 *
 * \brief	Represents Deviare library error codes.
 */

typedef [v1_enum] enum eNktErrorCodes {
  /// Occurs when when the Deviare database cannot be loaded.
  errCannotLoadDatabase      = 0x8A320001L, //NKT_DVERR_CannotLoadDatabase,
 /// Occurs when NktSpyMgr was already running and another instance is trying to be initialized. 
 /// Only one instance of Deviare manager is allowed per-process.
  errOnlyOneInstance         = 0x8A320002L, //NKT_DVERR_OnlyOneInstance,
  /// Occurs when communication protocol between agent and manager differ. 
  errProtocolVersionMismatch = 0x8A320003L, //NKT_DVERR_ProtocolVersionMismatch,
  /// Occurs when invalid data was transmitted between Deviare agent and manager.
  errInvalidTransportData    = 0x8A320004L, //NKT_DVERR_InvalidTransportData,
  /// Occurs when a file, process or referenced handle was not found.
  errNotFound                = 0x80070490L, //NKT_DVERR_NotFound,
  /// Occurs when arithmetic overflow occurs.
  errArithmeticOverflow      = 0x80070216L, //NKT_DVERR_ArithmeticOverflow,
  /// Occurs when a file, process, handle or object already exists.
  errAlreadyExists           = 0x800700B7L, //NKT_DVERR_AlreadyExists,
  /// Occurs when a NktSpyMgr instance was already initialized.
  errAlreadyInitialized      = 0x800704DFL, //NKT_DVERR_AlreadyInitialized,
  /// Occurs when an asynchronous operation was cancelled.
  errCancelled               = 0x800704C7L, //NKT_DVERR_Cancelled,
  /// Occurs when an internal exception was raised.
  errExceptionRaised         = 0x80020009L, //NKT_DVERR_ExceptionRaised,
  /// Occurs when a hook is inactive.
  errHookIsInactive          = 0x8A320005L, //NKT_DVERR_HookIsInactive,
  /// Occurs due to unfinished copy operation in ansynchronous or overlapped mode.
  errPartialCopy             = 0x8007012BL, //NKT_DVERR_PartialCopy,
  /// Occurs when a general failure is triggered.
  errFail                    = 0x80004005L, //E_FAIL,
  /// Occurs when memory is exhausted.
  errOutOfMemory             = 0x8007000EL, //E_OUTOFMEMORY,
  /// Occurs to inform that a function is not implemented in the interface.
  errNotImpl                 = 0x80004001L, //E_NOTIMPL,
  /// Occurs for invalid or out of range arguments.
  errInvalidArg              = 0x80070057L, //E_INVALIDARG,
  /// Occurs when an invalid or null pointer was referenced.
  errPointer                 = 0x80004003L, //E_POINTER
} eNktErrorCodes;

/**
 * \enum eNktHookState
 *
 * \brief	Represents hook states for a specific process.
 */

typedef [v1_enum] enum eNktHookState {
  /// <b>Inactive state.</b> \n
  /// Indicates that the hook was not activated for the specified process.
  stInactive=0, 
  /// <b>Activating state.</b> \n
  /// Indicates that the hook is being activated.
  stActivating, 
  /// <b>Active state.</b> \n
  /// Indicates that the hook is active for the specified process and intercepting function calls.
  stActive, 
  /// <b>Disabled state.</b> \n
  /// Indicates that a hook is disabled for the specified process.
  stDisabled, 
  /// <b>Removed state.</b> \n
  /// Indicates that the hook is not attached to the specified process.
  stRemoved, 
  /// <b>NotAvailable state.</b> \n
  /// Indicates that the hook is attached to the specified process, but the function or address is temporarily unavailable (i.e. the process did not load the hook's target dll yet).
  stNotAvailable, 
  /// <b>NotFound state.</b> \n
  /// Indicates that the specified hook does not exists.
  stNotFound=-1, 
  /// <b>Error state.</b> \n
  /// Indicates that an error occurred while instantiating the hook.
  stError=-2
} eNktHookState;

/**
 * \enum eNktHookFlags
 *
 * \brief Represents ::INktHook properties.
 */

typedef [v1_enum] enum eNktHookFlags {
  /// AutoHookChildProcess flag.\n
  /// If this flag is set, processes created by the attached processes will also be attached.
  flgAutoHookChildProcess=0x0001,
  /// RestrictAutoHookToSameExecutable flag. This flag can only be used in combination with the 
  /// AutoHookChildProcess flag.\n
  /// If this flag is set, child processes will be auto-attached only if they have the same name as 
  /// their parent.
  flgRestrictAutoHookToSameExecutable=0x0002,
  /// AutoHookActive flag.\n
  /// If this flag is set, attached processes will be automatically hooked without the need of calling 
  /// ::INktHook::Hook.
  flgAutoHookActive=0x0004,
  /// AsyncCallbacks flag.\n
  /// If this flag is set, hooked function calls will be attended, but the caller process 
  /// will not pause its execution until returning from the @link 
  /// Deviare2::DNktHookEvents::OnFunctionCalled OnFunctionCalled @endlink event handler. In other words, 
  /// if this flag is set, there's no guarantee on what the hooked process context will be when the
  /// handler is called (i.e. inspecting the caller process memory in an asynchronous
  /// handler is likely to lead to inconsistencies).
  flgAsyncCallbacks=0x0008,
  /// OnlyPreCall flag.\n
  /// If this flag is set, Deviare will trigger the @link Deviare2::DNktHookEvents::OnFunctionCalled 
  /// OnFunctionCalled @endlink event only before a hooked function is called.
  /// /// Also, custom handlers or plugins will only receive the @link 
  /// Deviare2::DNktHookEvents::OnFunctionCalled OnFunctionCalled @endlink event only before a hooked 
  /// function is called.
  flgOnlyPreCall=0x0010,
  /// OnlyPostCall flag.
  /// If this flag is set, Deviare will trigger the @link Deviare2::DNktHookEvents::OnFunctionCalled OnFunctionCalled @endlink event only after a hooked function is called.
  /// Also, custom handlers or plugins will only receive the @link Deviare2::DNktHookEvents::OnFunctionCalled OnFunctionCalled @endlink event only after a hooked function is called.
  flgOnlyPostCall=0x0020,
  /// DontCheckAddress flag.\n
  /// If this flag is set, when creating an ::INktHook for a specific address will not be 
  /// submitted to a memory address validity check.
  flgDontCheckAddress=0x0040,
  /// DontCallIfLoaderLocked flag.\n
  /// If this flag is set, the @link Deviare2::DNktHookEvents::OnFunctionCalled OnFunctionCalled @endlink event will not be triggered while the <a href="http://blogs.msdn.com/b/mgrier/archive/2005/06/18/430409.aspx">DLL Loader</a> lock is taken. \n
  /// NOTE: Events filtered by this flag will <b>not</b> be scheduled to be triggered when the <a href="http://blogs.msdn.com/b/mgrier/archive/2005/06/18/430409.aspx">DLL Loader</a> lock is released.
  flgDontCallIfLoaderLocked=0x0080,
  /// DontCallCustomHandlersOnLdrLock flag.\n
  /// If this flag is set, custom handlers or plugins will not be called while the <a href="http://blogs.msdn.com/b/mgrier/archive/2005/06/18/430409.aspx">DLL Loader</a> lock is taken. \n
  /// NOTE: Calls filtered by this flag will <b>not</b> be scheduled to be triggered when the <a href="http://blogs.msdn.com/b/mgrier/archive/2005/06/18/430409.aspx">DLL Loader</a> lock is released.
  flgDontCallCustomHandlersOnLdrLock=0x0100,
  /// Only32Bits flag.\n
  /// If this flag is set, only 32-bit processes are hooked.
  flgOnly32Bits=0x0200,
  /// Only64Bits flag.\n
  /// If this flag is set, only 64-bit processes are hooked.
  flgOnly64Bits=0x0400,
  /// AddressIsOffset flag.\n
  /// The specified address is an offset inside the containing module.
  flgAddressIsOffset=0x0800,
  /// InvalidateCache flag.\n
  /// Invalidates the processor cache
  flgInvalidateCache=0x1000,
  /// DontSkipJumps flag.\n
  /// Don't skip initial JMP opcodes that may be found on function being hooked
  flgDontSkipJumps=0x2000,
  /// DisableStackWalk flag.\n
  /// Don't retrieve stack information
  flgDisableStackWalk=0x4000
} eNktHookFlags;

/**
 * \enum eNktHookCustomHandlerFlags
 *
 * \brief	Represents custom hook properties.
 */

typedef [v1_enum] enum eNktHookCustomHandlerFlags {
  /// DontCallIfLoaderLocked flag.
  /// Keeps the custom hook from being called when a process is loading a dll.
  flgChDontCallIfLoaderLocked=0x0001,
  flgChDisableExceptionChecks=0x0002
} eNktHookCustomHandlerFlags;

/**
 * \enum eNktSearchMode
 *
 * \brief	Represents search modes when looking for modules and exports by memory address.
 */

typedef [v1_enum] enum eNktSearchMode {
  /// ExactMatch mode. \n
  /// Matches modules or exports whose initial memory position equals the specified memory address.
  smExactMatch=0,
  /// FindContaining mode.\n
  /// Matches the module or export to which the specified memory address belongs.
  smFindContaining, 
  /// GetNearest match mode. \n
  /// Same as the FindContaining mode, but extending the module and export ending bounds to the beginning of the next module or export.
  smGetNearest
} eNktSearchMode;

/**
 * \enum eNktRegister
 *
 * \brief	Represents the processor registers.
 */

typedef [v1_enum] enum eNktRegister {
  /// This value does not correspond to any register. Variables with no register information are in the stack.
  asmRegNone=0,
  /// The EAX register.
  asmRegEax=1, 
  /// The EBX register.
  asmRegEbx=2, 
  /// The ECX register.
  asmRegEcx=3, 
  /// The EDX register.
  asmRegEdx=4,
  /// The EAX and the EDX registers paired. This is useful for some operations (i.e. when an operation result is a double).
  asmRegEaxEdxPair=5, 
  /// The st0 register.
  asmRegSt0=6,
  /// the ESP register.
  asmRegEsp=7, 
  /// The EBP register.
  asmRegEbp=8, 
  /// The EIP register.
  asmRegEip=9, 
  /// The ESI register.
  asmRegEsi=10,
  /// The EDI register.
  asmRegEdi=11,
  //----
  /// The RAX register.
  asmRegRax=1,
  /// The RBX register.
  asmRegRbx=2,
  /// The RCX register.
  asmRegRcx=3,
  /// The RDX register.
  asmRegRdx=4,
  /// The R8 register.
  asmRegR8=5,
  /// The R9 register.
  asmRegR9=6,
  /// The R10 register.
  asmRegR10=7,
  /// The R11 register.
  asmRegR11=8,
  /// The XMM0 register.
  asmRegXmm0=9, 
  /// The XMM1 register.
  asmRegXmm1=10, 
  /// The XMM2 register.
  asmRegXmm2=11, 
  /// The XMM3 register.
  asmRegXmm3=12,
  /// The RSP register.
  asmRegRsp=13, 
  /// The RBP register.
  asmRegRbp=14,  
  /// The RIP register.
  asmRegRip=15,
  /// The RSI register.
  asmRegRsi=16,
  /// The RDI register.
  asmRegRdi=17
} eNktRegister;

/**
 * \enum eNktProtection
 *
 * \brief	Represents memory page protection properties. \n
 *			For detailed information on memory management, visit <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366779(v=vs.85).aspx">this link</a>.
 */

typedef [v1_enum] enum eNktProtection {
  /// Execute flag.\n
  /// This flag is set if executing code from this page is allowed.
  protExecute      = 0x01,
  /// Read flag.\n
  /// This flag is set if reading from this page is allowed.
  protRead         = 0x02,
  /// Write flag.\n
  /// This flag is set if writing to this page is allowed.
  protWrite        = 0x04,
  /// WriteCopy flag.\n
  /// This flag is set if the page is marked as <a href="http://en.wikipedia.org/wiki/Copy-on-write">copy on write</a>.
  protIsWriteCopy  = 0x08,
  /// Guard flag.\n
  /// This flag is set if the page is marked as <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366549(v=vs.85).aspx">guard</a>.
  protGuard        = 0x10,
  /// NoCache flag.\n
  /// This flag is set if the page is marked as not cacheable.
  protNoCache      = 0x20,
  /// WriteCombine flag.\n
  /// This flag is set if the page is marked as <a href="http://en.wikipedia.org/wiki/Write-combining">write-combine</a>.
  protWriteCombine = 0x40
} eNktProtection;

/**
 * \enum eNktDboFundamentalType
 *
 * \brief	Represents <a href="http://msdn.microsoft.com/en-us/library/cc953fe1(v=vs.71).aspx">C++ fundamental types</a>. 
 *			Equivalencies for C# can be found <a href="http://msdn.microsoft.com/en-us/library/4xwz0t37(v=vs.71).aspx">here</a>.
 */

typedef [v1_enum] enum eNktDboFundamentalType {
  /// Does not represent any type. \n
  /// This is the type for ::INktDbObject implementors which do not belong to any basic type or were invalidly cast.
  ftNone=0, 
  /// Represents the <b>signed char</b> C++ fundamental type. Its equivalent in C# is <b>sbyte</b>.
  ftSignedByte, 
  /// Represents the <b>unsigned char</b> C++ fundamental type. Its equivalent in C# is <b>byte</b>.
  ftUnsignedByte, 
  /// Represents the <b>signed short</b> C++ fundamental type. Its equivalents in C# are <b>short</b> and <b>char</b>.
  ftSignedWord, 
  /// Represents the <b>unsigned short</b> C++ fundamental type. Its equivalent in C# is <b>ushort</b>.
  ftUnsignedWord,
  /// Represents the <b>signed int</b> C++ fundamental type. Its equivalent in C# is <b>int</b>.
  ftSignedDoubleWord,
  /// Represents the <b>unsigned int</b> C++ fundamental type. Its equivalent in C# is <b>uint</b>.
  ftUnsignedDoubleWord, 
  /// Represents the <b>signed long long</b> C++ fundamental type. Its equivalent in C# is <b>long</b>.
  ftSignedQuadWord, 
  /// Represents the <b>unsigned long long</b> C++ fundamental type. Its equivalent in C# is <b>ulong</b>.
  ftUnsignedQuadWord,
  /// Represents the <b>float</b> C++ fundamental type. Its equivalent in C# is <b>float</b>.
  ftFloat, 
  /// Represents the <b>double</b> C++ fundamental type. Its equivalent in C# is <b>double</b>.
  ftDouble,
  /// Represents the <b>long double</b> C++ fundamental type. Its equivalent in C# is <b>double</b>.
  ftLongDouble, 
  /// Represents the <b>void</b> C++ fundamental type. Its equivalent in C# is <b>void</b>.
  ftVoid, 
  /// Represents the <b>char</b> C++ fundamental type. Its equivalents in C# are <b>char</b> and <b>sbyte</b>.\n
  /// Take into account that the C++ compiler default directive 
  /// is to interpret <b>char</b> variables as <b>signed char</b> 
  /// variables, but this can be changed with a compilation flag.
  ftAnsiChar, 
  /// Represents the <b>short</b> C++ fundamental type. Its equivalents in C# are <b>char</b> and <b>ushort</b>.\n
  /// Take into account that the C++ compiler default directive 
  /// is to interpret <b>short</b> variables as <b>signed short</b> 
  /// variables, but this can be changed with a compilation flag.
  ftWideChar
} eNktDboFundamentalType;

/**
 * \enum eNktDboClass
 *
 * \brief	Represents the ::INktDbObject classes. ::INktParam implementors also make use of this Enum, since they wrap an ::INktDbObject implementor internally.
 */

typedef [v1_enum] enum eNktDboClass {
  /// Null class. \n
  /// This is the class for ::INktDbObject implementors returned by an unsuccessful query to the DB. This value should not be returned by an ::INktParam unless it is the result of an invalid cast.
  clsNull=-1, 
  /// Fundamental class. \n
  /// ::INktParam implementors in this class represent basic types (i.e. int, bool, int64, etc).
  clsFundamental=0, 
  /// Struct class.
  clsStruct,
  /// Union class.
  clsUnion, 
  /// Array class.
  clsArray, 
  /// Pointer class.
  clsPointer, 
  /// Reference class.
  clsReference,
  /// Enumeration class. \n
  /// ::INktDbObject implementors in this class represent a whole Enum type, while ::INktParam implementors represent a sole member of a given Enum type.
  clsEnumeration, 
  /// Function class. \n
  /// This member is not valid for ::INktParam implementors.
  clsFunction, 
  /// FunctionType class.
  clsFunctionType,
  /// ClassConstructor class. \n
  /// ::INktDbObject implementors in this class represent class constructor functions.
  clsClassConstructor, 
  /// ClassDestructor class. \n
  /// ::INktDbObject implementors in this class represent class destructor functions.
  clsClassDestructor, 
  /// ClassOperatorMethod class. \n
  /// ::INktDbObject implementors in this class represent class operator functions.
  clsClassOperatorMethod, 
  /// ClassMethod class. \n
  ///  ::INktDbObject implementors in this class represent class method functions.
  clsClassMethod,
  /// ClassConverter class. \n
  /// ::INktDbObject implementors in this class represent class converter functions.
  clsClassConverter
} eNktDboClass;

/**
 * \typedef	eNktDboCallingConvention
 *
 * \brief	Represents <a href="http://en.wikipedia.org/wiki/Calling_conventions">function calling conventions</a>.
 */

typedef [v1_enum] enum eNktDboCallingConvention {
  /// Calling convention not available. This value is usually returned when the calling convention is not available in the Deviare DB.
  ccNA=-1,
  /// stdcall calling convention. For more information, visit <a href="http://en.wikipedia.org/wiki/X86_calling_conventions#stdcall">this link</a>.
  ccStdCall=0, 
  /// cdecl calling convention. For more information, visit <a href="http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">this link</a>.
  ccCDecl=1,
  /// fastcall calling convention. For more information, visit <a href="http://en.wikipedia.org/wiki/X86_calling_conventions#fastcall">this link</a>.
  ccFastCall=2, 
  /// thiscall calling convention. For more information, visit <a href="http://en.wikipedia.org/wiki/X86_calling_conventions#thiscall">this link</a>.
  ccThisCall=3
} eNktDboCallingConvention;

/**
 * \enum eNktDboFunctionFlags
 *
 * \brief	Represents ::INktDbObject function flags. This flags are relevant only if the ::INktDbObject implementor belongs to the ::clsFunction class. \n
 *			NOTE: Actual functions may not behave as specified by these flags, since these flags only reflect the function declarations.
 */

typedef [v1_enum] enum eNktDboFunctionFlags {
  /// IsPure flag. \n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "pure" attribute.
  fflgIsPure=0x10, 
  /// IsThrow flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "throw" attribute.
  fflgIsThrow=0x20, 
  /// IsNoThrow flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "nothrow" attribute.
  fflgIsNoThrow=0x40, 
  /// IsNoReturn flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "noreturn" attribute.
  fflgIsNoReturn=0x80,
  /// IsConst flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "const" attribute.
  fflgIsConst=0x100, 
  /// IsDeprecated flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "deprecated" attribute.
  fflgIsDeprecated=0x200, 
  /// IsNonNull flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "nonnull" attribute.
  fflgIsNonNull=0x400, 
  /// IsMalloc flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "malloc" attribute.
  fflgIsMalloc=0x800,
  /// IsExternal flag. \n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared as external.
  fflgIsExternal=0x1000, 
  /// IsDllImport flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "dllimport" attribute.
  fflgIsDllImport=0x2000, 
  /// IsDllExport flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "dllexport" attribute.
  fflgIsDllExport=0x4000, 
  /// IsFormat flag.\n
  /// This flag is set if the function represented by the ::INktDbObject implementor was declared with a "format" attribute.
  fflgIsFormat=0x8000
} eNktDboFunctionFlags;

/**
 * \enum eNktDboStructUnionFlags
 *
 * \brief	Represents class, struct and union properties.
 */

typedef [v1_enum] enum eNktDboStructUnionFlags {

  /// HasConstructor flag. \n
  /// This flag is set if the class, struct or union has an explicit constructor.
  suflgHasConstructor=0x10, 
  /// HasDestructor flag. \n
  /// This flag is set if the class, struct or union has an explicit destructor.
  suflgHasDestructor=0x20,
  /// HasVirtual flag. \n
  /// This flag is set if the class, struct or union has at least one member declared as virtual.
  suflgHasVirtual=0x40, 
  /// HasInheritance flag. \n
  /// This flag is set if the class, struct or union inherits from some other class, struct or union.
  suflgHasInheritance=0x80
} eNktDboStructUnionFlags;

/**
 * \enum eNktDboItemFlags
 *
 * \brief	Represents pointer, reference, and variable properties. Therefore, these properties are only valid for ::INktDbObject and ::INktParam implementors with class ::clsPointer, ::clsReference, ::clsEnumeration, ::clsFundamental or ::clsArray.
 */

typedef [v1_enum] enum eNktDboItemFlags {
  /// IsVolatile flag.\n
  /// This flag is set if the pointer, reference or variable represented by the ::INktDbObject or ::INktParam implementor was declared as volatile.
  iflgIsVolatile=0x1, 
  /// IsConstant flag.\n
  /// This flag is set if the pointer, reference or variable represented by the ::INktDbObject or ::INktParam implementor was declared as constant.
  iflgIsConstant=0x2
} eNktDboItemFlags;

/**
 * \enum eNktDboItemMemberType
 *
 * \brief	Represents class and struct member access modifiers.
 */

typedef [v1_enum] enum eNktDboItemMemberType {
  /// This is the default member access modifier.
  mtNA=-1, 
  /// If a class or struct member is <b>Public</b>, then it is visible to any other class.
  mtPublic=0x10, 
  /// If a class or struct member is <b>Private</b>, then it is only visible to its own class.
  mtPrivate=0x20, 
  /// If a class or struct member is <b>Protected</b>, then it is only visible to its own class and its subclasses. 
  mtProtected=0x40
} eNktDboItemMemberType;

//-----------------------------------------------------------
//-----------------------------------------------------------


/**
 * \interface	INktObject
 *
 * \brief	Exposes the base methods of the Deviare object hierarchy.
 *
 * 
 * 
 */

[
  object,
  uuid(3B886748-DC9B-43B0-B761-68DAD9E5484F),
  dual, local,
  nonextensible,
  helpstring("INktObject Interface"),
  pointer_default(unique)
]
interface INktObject : IDispatch
{
  /**
   * \fn	HRESULT INktObject::UserData([out, retval] my_ssize_t *pVal);
   *
   * \brief	Gets a user-defined custom data.
   *
   * \param [in,out]	pVal	A pointer to store the referenced data. Cannot be null.
   *
   * \return S_OK on success or E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get a user-defined custom data"),
   id(dispidNktObjectUserData)]
  HRESULT UserData([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktObject::UserData([in] my_ssize_t newValue);
   *
   * \brief	Sets a user-defined custom data.
   *
   * \param	newValue	The value to store.
   *
   * \return S_OK.
   */

  [propput, helpstring("Set a user-defined custom data"),
   id(dispidNktObjectUserData)]
  HRESULT UserData([in] my_ssize_t newValue);

  /**
   * \fn	HRESULT INktObject::InterfaceError([out, retval] LONG *pVal);
   *
   * \brief	Get the error code raised when this object was created.
   *
   * \param [in,out] pVal	A pointer to store the error code. Cannot be NULL.
   *
   * \return S_OK on success, E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the error code raised when this object was created"),
   id(dispidNktObjectInterfaceError)]
  HRESULT InterfaceError([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktObject::DeviareId([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the id of the object.
   *
   * \param [in,out]	pVal	A pointer to store the identifier. Cannot be NULL.
   *
   * \return S_OK on success
   * \return E_POINTER if pVal is NULL.
   *
   */

  [propget, helpstring("Get the id of the object"),
   id(dispidNktObjectDeviareId)]
  HRESULT DeviareId([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktObject::ToString([out, retval] BSTR *pVal);
   *
   * \brief	Get the string representation of the object.
   *
   * \param [in,out]	pVal	A pointer to a BSTR to store the string. Cannot be NULL.
   *
   * \return S_OK on success
   * \return E_OUTOFMEMORY if pVal points to a string with insufficient space
   * \return E_POINTER if pVal is NULL.
   *
   */

  [helpstring("Get the string representation of the object"),
   id(dispidNktObjectToString)]
  HRESULT ToString([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktObject::GetObjectFromDeviareId([in] my_ssize_t devId, [out,
   * 		retval] IDispatch **ppDisp);
   *
   * \brief	Retrieves an object given its id.
   *
   * \param	devId			  	Identifier for the Deviare Object to retrieve.
   * \param [in,out]	ppDisp	A pointer to an IDispatch interface to store the object. This cannot be NULL. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppDisp is NULL.
   *
   * \remarks If devId is not a valid identifier, ppDisp will be set to NULL.
   */

  [helpstring("Retrieves an object given its id"),
   id(dispidNktObjectGetObjectFromDeviareId)]
  HRESULT GetObjectFromDeviareId([in] my_ssize_t devId, [out, retval] IDispatch **ppDisp);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktProcess
 *
 * \brief	Exposes methods for accessing system processes.
 *
 * 
 * 
 */

[
  object,
  uuid(32EC8909-95FE-483c-A5BA-BEE86470C210),
  dual, local,
  nonextensible,
  helpstring("INktProcess Interface"),
  pointer_default(unique)
]
interface INktProcess : INktObject
{
  /**
   * \fn	HRESULT INktProcess::Id([out, retval] LONG *pVal);
   *
   * \brief	Get the id of process (PID).
   *
   * \param [in,out]	pVal	A pointer to store the PID. Cannot be NULL.
   *
   * \return \c S_OK on success or \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the id of process"),
   id(dispidNktProcessId)]
  HRESULT Id([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktProcess::ParentId([out, retval] LONG *pVal);
   *
   * \brief	Get the id of parent process.
   *
   * \param [in,out]	pVal	A pointer to store the parent process PID. Cannot be NULL.
   *
   * \return \c S_OK on success or \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the id of parent process"),
   id(dispidNktProcessParentId)]
  HRESULT ParentId([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktProcess::PlatformBits([out, retval] LONG *pVal);
   *
   * \brief	Get the platform bits of the process.
   *
   * \param [in,out]	pVal	A pointer to store the platform bitness data. Cannot be NULL.
   *
   * \return \c S_OK on success or \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the platform bits of the process"),
   id(dispidNktProcessPlatformBits)]
  HRESULT PlatformBits([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktProcess::ThreadsCount([out, retval] LONG *pVal);
   *
   * \brief	Get the threads count in the process.
   *
   * \param [in,out]	pVal	A pointer to store the process thread count. Cannot be NULL.
   *
   * \return \c S_OK on success or \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the threads count in the process"),
   id(dispidNktProcessThreadsCount)]
  HRESULT ThreadsCount([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktProcess::PriorityBaseClass([out, retval] LONG *pVal);
   *
   * \brief	Get the priority base class of the process.
   *
   * \param [in,out]	pVal	A pointer to store the process thread count. Cannot be NULL.
   *
   * \return \c S_OK on success or \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the priority base class of the process"),
   id(dispidNktProcessPriorityBaseClass)]
  HRESULT PriorityBaseClass([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktProcess::Path([out, retval] BSTR *pVal);
   *
   * \brief	Get the executable file full path.
   *
   * \param [in,out]	pVal	A pointer to a BSTR string to store the path. Cannot be NULL.
   *
   * \return \c S_OK on success
   * \return \c E_OUTOFMEMORY if pVal points to a string with insufficient space
   * \return \c E_POINTER if pVal is NULL.
   *
   */
  [propget, helpstring("Get the executable file full path"),
   id(dispidNktProcessPath)]
  HRESULT Path([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktProcess::Name([out, retval] BSTR *pVal);
   *
   * \brief	Get the executable file name.
   *
   * \param [in,out]	pVal	A pointer to a BSTR string to store the name. Cannot be NULL.
   *
   * \return \c S_OK on success
   * \return \c E_OUTOFMEMORY if pVal points to a string with insufficient space
   * \return \c E_POINTER if pVal is NULL.
   *
   */
  [propget, helpstring("Get the executable file name"),
   id(dispidNktProcessName)]
  HRESULT Name([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktProcess::UserName([out, retval] BSTR *pVal);
   *
   * \brief	Get the name of the user owning who created the process.
   *
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return \c S_OK on success
   * \return \c E_OUTOFMEMORY if pVal points to a string with insufficient space
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the name of the user owning who created the process"),
   id(dispidNktProcessUserName)]
  HRESULT UserName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktProcess::DomainName([out, retval] BSTR *pVal);
   *
   * \brief	Get the domain where the process was created.
   *
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return \c S_OK on success
   * \return \c E_OUTOFMEMORY if pVal points to a string with insufficient space
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the domain where the process was created"),
   id(dispidNktProcessDomainName)]
  HRESULT DomainName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktProcess::LogonSID([out, retval] BSTR *pVal);
   *
   * \brief	Get the sid of the user owning who created the process.
   *
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return \c S_OK on success
   * \return \c E_OUTOFMEMORY if pVal points to a string with insufficient space
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the sid of the user owning who created the process"),
   id(dispidNktProcessLogonSID)]
  HRESULT LogonSID([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktProcess::Icon([out, retval] IPicture** icon);
   *
   * \brief	Get process icon.
   *
   * \param [in,out]	icon	Pointer to IPicture interface receiving the process icon.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on unknown error.
   * \return \c E_POINTER if pointer argument is NULL.
   *
   */

  [propget, helpstring("Get process icon"),
   id(dispidNktProcessIcon)]
  HRESULT Icon([out, retval] IPicture** icon);

  /**
   * \fn	HRESULT INktProcess::DefaultIcon([out, retval] IPicture** icon);
   *
   * \brief	Get the default process icon.
   *
   * \param [in,out]	icon	Pointer to IPicture interface receiving the process icon.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on unknown error.
   * \return \c E_POINTER if pointer argument is NULL.
   *
   */

  [propget, helpstring("Get default process icon"),
   id(dispidNktProcessDefaultIcon)]
  HRESULT DefaultIcon([out, retval] IPicture** icon);

  /**
   * \fn	HRESULT INktProcess::IsActive([in, defaultvalue(1000)] LONG waitTimeMs, [out,
   * 		retval] VARIANT_BOOL *pVal);
   *
   * \brief	Checks if the process is active.
   *
   * \param	waitTimeMs			The wait time in milliseconds.
   * \param [in,out]	pVal	Pointer to store the boolean value .Cannot be null.
   *
   * \return \c S_OK on success 
   * \return \c E_INVALIDARG if provided wait time argument is not valid.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Checks if the process is active"),
   id(dispidNktProcessIsActive)]
  HRESULT IsActive([in, defaultvalue(1000)] LONG waitTimeMs, [out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktProcess::Terminate([in, defaultvalue(0)] LONG exitCode);
   *
   * \brief	Terminates the process.
   *
   * \param	exitCode	The exit code.
   *
   * \return S_OK on success or \c E_FAIL on general failure.
   */

  [helpstring("Terminates the process"),
   id(dispidNktProcessTerminate)]
  HRESULT Terminate([in, defaultvalue(0)] LONG exitCode);

  /**
   * \fn	HRESULT INktProcess::Modules([out, retval] INktModulesEnum **ppModEnum);
   *
   * \brief	Get the modules of the process.
   *
   * \param [in,out]	ppModEnum	A pointer to INktModulesEnum* enumerator. Cannot be NULL.
   *
   * \return S_OK on success or \c E_POINTER if ppModEnum is NULL.
   */

  [helpstring("Get the modules of the process"),
   id(dispidNktProcessModules)]
  HRESULT Modules([out, retval] INktModulesEnum **ppModEnum);

  /**
   * \fn	HRESULT INktProcess::ModuleByName([in] BSTR name, [out, retval] INktModule **ppMod);
   *
   * \brief	Find the module with the provided name.
   *
   * \param	name			 	String containing the module name to search for.
   * \param [in,out]	ppMod	Pointer to store the matching module, if any. Cannot be NULL.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if ppMod is NULL.
   * \return \c E_INVALIDARG if name argument points to a NULL or empty string.
   * \return \c NKT_DVERR_NotFound if there is no match.
   */

  [helpstring("Find the module with the provided name"),
   id(dispidNktProcessModuleByName)]
  HRESULT ModuleByName([in] BSTR name, [out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktProcess::ModuleByAddress([in] my_ssize_t addr,
   * 		[in] eNktSearchMode searchMode, [out, retval] INktModule **ppMod);
   *
   * \brief	Find the module where the provided address belongs to.
   *
   * \param	addr			 	The address to match.
   * \param	searchMode		 	The search mode.
   * \param [in,out]	ppMod	Pointer to store the matching module, if any. Cannot be NULL.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if ppMod is NULL.
   * \return \c NKT_DVERR_NotFound if there is no match.
   */

  [helpstring("Find the module where the provided address belongs to"),
   id(dispidNktProcessModuleByAddress)]
  HRESULT ModuleByAddress([in] my_ssize_t addr, [in] eNktSearchMode searchMode,
                          [out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktProcess::FunctionByName([in] BSTR name, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find the exported function with the provided name.
   *
   * \param	name				 	The function name to search for.
   * \param [in,out]	ppExpFunc	Pointer to store the matching function, if any. Cannot be NULL..
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if ppExpFunc is NULL.
   * \return \c E_INVALIDARG if name is NULL or empty.
   * \return \c NKT_DVERR_NotFound if there is no match.
   *
   */

  [helpstring("Find the exported function with the provided name"),
   id(dispidNktProcessFunctionByName)]
  HRESULT FunctionByName([in] BSTR name, [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktProcess::FunctionByAddress([in] my_ssize_t addr,
   * 		[in] eNktSearchMode searchMode, [out, retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find the exported function where the provided address belongs to.
   *
   * \param	addr				 	The address to search for.
   * \param	searchMode			 	The search mode to use.
   * \param [in,out]	ppExpFunc	Pointer to store the matching function, if any. Cannot be NULL..
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if ppExpFunc is NULL.
   * \return \c NKT_DVERR_NotFound if there is no match.
   *
   */

  [helpstring("Find the exported function where the provided address belongs to"),
   id(dispidNktProcessFunctionByAddress)]
  HRESULT FunctionByAddress([in] my_ssize_t addr, [in] eNktSearchMode searchMode,
                            [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktProcess::Handle([in] LONG desiredAccess, [out, retval] my_ssize_t *pVal);
   *
   * \brief	Get this process handle.
   *
   * \param	desiredAccess   	The desired access mode. If you specify NULL, the default security descriptor is used. See <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx">Process Security and Access Rights</a>. 
   * \param [in,out]	pVal	A pointer where to store handle. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL if a general error occurs.
   * \return \c E_ACCESSDENIED if the process handle cannot be obtained using the selected access mode.
   */

  [helpstring("Get a process handle"),
   id(dispidNktProcessHandle)]
  HRESULT Handle([in] LONG desiredAccess, [out, retval] my_ssize_t *pVal);

  /**
   * \brief Gets an interface to access the process image Portable Executable (PE) header.
   *
   * \param ppVal A pointer to receive the PE file header interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppVal is NULL.
   * \return \c E_FAIL if a general error occurs.
   */
  [helpstring("Get process Portable Executable (PE) file header"),
   id(dispidNktProcessFileHeader)]
  HRESULT FileHeader([out, retval] INktStructPEFileHeader **ppVal);

  
  /**
   * \brief Gets an interface to access the process image optional Portable Executable (PE) header.
   *
   * \param ppVal A pointer to receive the PE optional header interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppVal is NULL.
   * \return \c E_FAIL if a general error occurs.
   */
  [helpstring("Get process PE optional header"),
   id(dispidNktProcessOptionalHeader)]
  HRESULT OptionalHeader([out, retval] INktStructPEOptionalHeader **ppVal);

   /**
   * \brief Gets an interface to access the process image Portable Executable (PE) sections.
   *
   * \param ppVal A pointer to receive the PE sections interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppVal is NULL.
   * \return \c E_FAIL if a general error occurs.
   */
  [helpstring("Get process PE sections"),
   id(dispidNktProcessSections)]
  HRESULT Sections([out, retval] INktStructPESections **ppVal);

  [propget, helpstring("Check if a process privilege is enabled or not"),
   id(dispidNktProcessPrivilege)]
  HRESULT Privilege([in] BSTR privilegeName, [out, retval] VARIANT_BOOL *pVal);

  /**
   * \brief Checks Get and sets process privilege.
   *
   * \param [in] privilegeName A string with the privilege to look for. See <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb530716(v=vs.85).aspx">Privilege constants</a>.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.   
   * \return \c E_INVALIDARG is privilegeName is empty, NULL, or invalid.
   * \return \c E_FAIL if privilege cannot be set or accessed.
   *
   */
  [propput, helpstring("Enable/disables a process privilege"),
   id(dispidNktProcessPrivilege)]
  HRESULT Privilege([in] BSTR privilegeName, [in] VARIANT_BOOL newValue);

  /**
   * \fn	HRESULT INktProcess::Memory([out, retval] INktProcessMemory **ppProcMem);
   *
   * \brief	Get an interface to access the process memory.
   *
   * \param [in,out]	ppProcMem	A pointer to store the INktProcessMemory interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProcMem is NULL.   
   */
  [helpstring("Get a memory reader/writer object"),
   id(dispidNktProcessMemory)]
  HRESULT Memory([out, retval] INktProcessMemory **ppProcMem);

  /**
  * \brief Invalidates internal module and exports cache
  *
  * \return \c S_OK on success.
  */
  [helpstring("Invalidates internal module and exports cache"),
   id(dispidNktProcessInvalidateCache)]
  HRESULT InvalidateCache([in] my_ssize_t hDll);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktProcessesEnum
 *
 * \brief	Exposes methods for enumerating a INktProcess collection.
 *
 * 
 * 
 */

[
  object,
  uuid(DF43831B-7A0B-43d4-AC40-6136A7C95B28),
  dual, local,
  nonextensible,
  helpstring("INktProcessEnum Interface"),
  pointer_default(unique)
]
interface INktProcessesEnum : INktObject
{
  /**
   * \fn	HRESULT INktProcessesEnum::Count([out, retval] LONG *pVal);
   *
   * \brief	Get the total item count in this collection.
   *
   * \param [in,out]	pVal	Pointer to store the item count. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the total item count in this collection"),
   id(dispidNktProcessesEnumCount)]
  HRESULT Count([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktProcessesEnum::GetAt([in] LONG index, [out, retval] INktProcess **ppProc);
   *
   * \brief	Retrieves the item at the specified index.
   *
   * \param	index			  	Zero-based index.
   * \param [in,out]	ppProc	Pointer to address to store the retrieved item interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_INVALIDARG if index parameter is out of bounds.
   */

  [helpstring("Retrieves the item at the specified index"),
   id(dispidNktProcessesEnumGetAt)]
  HRESULT GetAt([in] LONG index, [out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktProcessesEnum::First([out, retval] INktProcess **ppProc);
   *
   * \brief	Retrieves the first item in the collection.
   *
   * \param [in,out]	ppProc	Address of pointer to receive INktProcess interface. Cannot be NULL..
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the first item in the collection"),
   id(dispidNktProcessesEnumFirst)]
  HRESULT First([out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktProcessesEnum::Last([out, retval] INktProcess **ppProc);
   *
   * \brief	Retrieves the last item in the collection.
   *
   * \param [in,out]	ppProc	Address of pointer to receive INktProcess interface. Cannot be NULL..
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_FAIL if item not found (ppProc is set to NULL).
   */

  [helpstring("Retrieves the last item in the collection"),
   id(dispidNktProcessesEnumLast)]
  HRESULT Last([out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktProcessesEnum::Next([out, retval] INktProcess **ppProc);
   *
   * \brief	Retrieves the next item in the collection.
   *
   * \param [in,out]	ppProc	Address of pointer to receive INktProcess interface. Cannot be NULL..
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_FAIL if item not found (ppProc is set to NULL).
   */

  [helpstring("Retrieves the next item in the collection"),
   id(dispidNktProcessesEnumNext)]
  HRESULT Next([out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktProcessesEnum::Previous([out, retval] INktProcess **ppProc);
   *
   * \brief	Retrieves the previous item in the collection.
   *
   * \param [in,out]	ppProc	Address of pointer to receive INktProcess interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_FAIL if item not found (ppProc is set to NULL).
   */

  [helpstring("Retrieves the previous item in the collection"),
   id(dispidNktProcessesEnumPrevious)]
  HRESULT Previous([out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktProcessesEnum::GetByDeviareId([in] my_ssize_t devId, [out,
   * 		retval] INktProcess **ppProc);
   *
   * \brief	Find an item by its deviare id.
   *
   * \param	devId			  	Deviare object identifier.
   * \param [in,out]	ppProc	Address of pointer to receive INktProcess interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_INVALIDARG if devId is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppProc is set to NULL).
   */

  [helpstring("Find an item by its deviare id"),
   id(dispidNktProcessesEnumGetByDeviareId)]
  HRESULT GetByDeviareId([in] my_ssize_t devId, [out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktProcessesEnum::GetById([in] LONG id, [out, retval] INktProcess **ppProc);
   *
   * \brief	Find a process by PID.
   *
   * \param	id				  	The PID to search for.
   * \param [in,out]	ppProc	Address of pointer to receive INktProcess interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_INVALIDARG if specified PID is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppProc is set to NULL).
   */

  [helpstring("Find a process by id"),
   id(dispidNktProcessesEnumGetById)]
  HRESULT GetById([in] LONG id, [out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktProcessesEnum::GetByName([in] BSTR name, [out,
   * 		retval] INktProcess **ppProc);
   *
   * \brief	Find a process by name.
   *
   * \param	name			  	The name.
   * \param [in,out]	ppProc	Address of pointer to receive INktProcess interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_INVALIDARG if name string pointer is null, or string is empty.
   * \return \c NKTDV_ERR_NotFound if item not found (ppProc is set to NULL).
   */

  [helpstring("Find a process by name"),
   id(dispidNktProcessesEnumGetByName)]
  HRESULT GetByName([in] BSTR name, [out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktProcessesEnum::_NewEnum([out, retval] IUnknown** ppUnk);
   *
   * \brief	Retrieves an enumerable collection object.
   *
   * \param [out, retval]	ppUnk	Address of an interface pointer that on return points to the IUnknown interface of an enumerator
   object.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if ppUnk is NULL.
   * \return \c E_FAIL on general failure.
   */

  [propget, helpstring("Retrieves an enumerable collection object"),
   id(DISPID_NEWENUM), restricted]
  HRESULT _NewEnum([out, retval] IUnknown** ppUnk);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktModule
 *
 * \brief	Exposes methods for accessing modules.
 *
 * 
 * 
 */

[
  object,
  uuid(F12AAEB4-3CD8-435F-BF6B-7D2C2AFFD4EC),
  dual, local,
  nonextensible,
  helpstring("INktModule Interface"),
  pointer_default(unique)
]
interface INktModule : INktObject
{
  /**
   * \fn	HRESULT INktModule::ProcessId([out, retval] LONG *pVal);
   *
   * \brief	Get PID associated with this module.
   *
   * \param [in,out]	pVal	Address of pointer to receive PID. Cannot be NULL.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get id of process associated with this module"),
   id(dispidNktModuleProcessId)]
  HRESULT ProcessId([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktModule::PlatformBits([out, retval] LONG *pVal);
   *
   * \brief	Get the platform bits of the process which loaded the module.
   *
   * \param [in,out]	pVal	Address of pointer to receive process bitness. Cannot be NULL.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the platform bits of the module"),
   id(dispidNktModulePlatformBits)]
  HRESULT PlatformBits([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktModule::BaseAddress([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the module base address.
   *
   * \param [in,out]	pVal	Address of pointer to receive the module base address. Cannot be NULL.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the base address"),
   id(dispidNktModuleBaseAddress)]
  HRESULT BaseAddress([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktModule::Size([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the module size in bytes.
   *
   * \param [in,out]	pVal	Address of pointer to receive the module size. Cannot be NULL.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the size in bytes"),
   id(dispidNktModuleSize)]
  HRESULT Size([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktModule::Name([out, retval] BSTR *pVal);
   *
   * \brief	Get the module's base name.
   *
   * \param [in,out]	pVal	Address of string pointer to receive the module name. Cannot be NULL.
   *
   * \return \c S_OK on success
   * \return \c E_OUTOFMEMORY if pVal points to a string with insufficient space.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the module's base name"),
   id(dispidNktModuleName)]
  HRESULT Name([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktModule::Path([out, retval] BSTR *pVal);
   *
   * \brief	Get the dll file path of the module.
   *
   * \param [in,out]	pVal	Address of string pointer to receive the module path.
   *
   * \return \c S_OK on success
   * \return \c E_OUTOFMEMORY if pVal points to a string with insufficient space.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the dll file path of the module"),
   id(dispidNktModulePath)]
  HRESULT Path([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktModule::FileName([out, retval] BSTR *pVal);
   *
   * \brief	Get the executable file name.
   *
   * \param [in,out]	pVal	Address of string pointer to receive the module filename.
   *
   * \return \c S_OK on success
   * \return \c E_OUTOFMEMORY if pVal points to a string with insufficient space.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the executable file name"),
   id(dispidNktModuleFileName)]
  HRESULT FileName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktModule::Handle([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the module handle.
   *
   * \param [in,out]	pVal	Address of pointer to receive the module handle.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the module handle"),
   id(dispidNktModuleHandle)]
  HRESULT Handle([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktModule::ExportedFunctions([out,
   * 		retval] INktExportedFunctionsEnum **ppExpFunc);
   *
   * \brief	Get the functions exported by the module.
   *
   * \param [in,out]	ppExpFunc	Address of pointer to receive the enumerator interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppExpFunc is NULL.
   */

  [helpstring("Get the functions exported by the module"),
   id(dispidNktModuleExportedFunctions)]
  HRESULT ExportedFunctions([out, retval] INktExportedFunctionsEnum **ppExpFunc);

  /**
   * \fn	HRESULT INktModule::FunctionByOrdinal([in] LONG ordinal, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find the exported function with the provided ordinal index.
   *
   * \param	ordinal				 	The ordinal.
   * \param [in,out]	ppExpFunc	Address of pointer to receive the matching exported function, if any.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if ppExpFunc is NULL.
   * \return \c E_INVALIDARG if ordinal is invalid.
   * \return \c NKT_DVERR_NotFound if there is no match.
   */

  [helpstring("Find the exported function with the provided ordinal index"),
   id(dispidNktModuleFunctionByOrdinal)]
  HRESULT FunctionByOrdinal([in] LONG ordinal, [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktModule::FunctionByName([in] BSTR name, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find the exported function with the provided ordinal index.
   *
   * \param	name				 	The name to search for.
   * \param [in,out]	ppExpFunc	Address of pointer to receive the matching exported function, if any..
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if ppExpFunc is NULL.
   * \return \c E_INVALIDARG if name is invalid or empty.
   * \return \c NKT_DVERR_NotFound if there is no match.
   */

  [helpstring("Find the exported function with the provided name"),
   id(dispidNktModuleFunctionByName)]
  HRESULT FunctionByName([in] BSTR name, [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktModule::FunctionByAddress([in] my_ssize_t addr, [in,
   * 		defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL searchNearest, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find the exported function with the provided ordinal index.
   *
   * \param	addr				 	The address to search. 
   * \param	searchNearest		 	\c VARIANT_FALSE to match exact address, VARIANT_TRUE to match nearest function.
   * \param [in,out]	ppExpFunc	Address of pointer to receive the matching exported function, if any.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if ppExpFunc is NULL.
   * \return \c E_INVALIDARG if name is invalid or empty.
   * \return \c NKT_DVERR_NotFound if there is no match.
   */

  [helpstring("Find the exported function where the provided address belongs to"),
   id(dispidNktModuleFunctionByAddress)]
  HRESULT FunctionByAddress([in] my_ssize_t addr,
                            [in, defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL searchNearest,
                            [out, retval] INktExportedFunction **ppExpFunc);


   /**
   * \brief Gets an interface to access the process image Portable Executable (PE) header.
   *
   * \param ppVal Address of pointer to receive the PE file header interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppVal is NULL.
   * \return \c E_FAIL if a general error occurs.
   */
  [helpstring("Get module file header"),
   id(dispidNktModuleFileHeader)]
  HRESULT FileHeader([out, retval] INktStructPEFileHeader **ppVal);

    /**
   * \brief Gets an interface to access the process image optional Portable Executable (PE) header.
   *
   * \param ppVal Address of pointer to receive the PE optional header interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppVal is NULL.
   * \return \c E_FAIL if a general error occurs.
   */
  [helpstring("Get module optional header"),
   id(dispidNktModuleOptionalHeader)]
  HRESULT OptionalHeader([out, retval] INktStructPEOptionalHeader **ppVal);

  
   /**
   * \brief Gets an interface to access the process image Portable Executable (PE) sections.
   *
   * \param ppVal Address of pointer to receive the PE sections interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppVal is NULL.
   * \return \c E_FAIL if a general error occurs.
   */
  [helpstring("Get module sections"),
   id(dispidNktModuleSections)]
  HRESULT Sections([out, retval] INktStructPESections **ppVal);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktModulesEnum
 *
 * \brief	Exposes methods for enumerating a INktModule collection.
 *
 * 
 * 
 */

[
  object,
  uuid(382A6E42-3E59-40d7-BA40-AFD10611C5B8),
  dual, local,
  nonextensible,
  helpstring("INktModulesEnum Interface"),
  pointer_default(unique)
]
interface INktModulesEnum : INktObject
{
  /**
   * \fn	HRESULT INktModulesEnum::Count([out, retval] LONG *pVal);
   *
   * \brief	Get the total item count in this collection.
   *
   * \param [in,out]	pVal	Address of pointer to store the item count
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the total items count in this collection"),
   id(dispidNktModulesEnumCount)]
  HRESULT Count([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktModulesEnum::GetAt([in] LONG index, [out, retval] INktModule **ppMod);
   *
   * \brief	Retrieves the item at the specified index.
   *
   * \param	index			 	Zero-based index.
   * \param [in,out]	ppMod	Address of pointer to store the item count. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if index parameter is out of bounds.
   */

  [helpstring("Retrieves the item at the specified index"),
   id(dispidNktModulesEnumGetAt)]
  HRESULT GetAt([in] LONG index, [out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktModulesEnum::First([out, retval] INktModule **ppMod);
   *
   * \brief	Retrieves the first item in the collection.
   *
   * \param [in,out]	ppMod	Address of pointer to receive INktProcess interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the first item in the collection"),
   id(dispidNktModulesEnumFirst)]
  HRESULT First([out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktModulesEnum::Last([out, retval] INktModule **ppMod);
   *
   * \brief	Retrieves the last item in the collection.
   *
   * \param [in,out]	ppMod	Address of pointer to receive INktProcess interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the last item in the collection"),
   id(dispidNktModulesEnumLast)]
  HRESULT Last([out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktModulesEnum::Next([out, retval] INktModule **ppMod);
   *
   * \brief	Retrieves the next item in the collection.
   *
   * \param [in,out]	ppMod	Address of pointer to receive INktProcess interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   *
   * \return S_OK or E_FAIL.
   */

  [helpstring("Retrieves the next item in the collection"),
   id(dispidNktModulesEnumNext)]
  HRESULT Next([out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktModulesEnum::Previous([out, retval] INktModule **ppMod);
   *
   * \brief	Retrieves the previous item in the collection.
   *
   * \param [in,out]	ppMod	Address of pointer to receive INktProcess interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the previous item in the collection"),
   id(dispidNktModulesEnumPrevious)]
  HRESULT Previous([out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktModulesEnum::GetByDeviareId([in] my_ssize_t devId, [out,
   * 		retval] INktModule **ppMod);
   *
   * \brief	Find an item by its deviare id.
   *
   * \param	devId			  	The ID to search for.
   * \param [in,out]	ppMod	Address of pointer to receive INktModule interface. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_INVALIDARG if devId is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppMod is set to NULL).
   */

  [helpstring("Find an item by its deviare id"),
   id(dispidNktModulesEnumGetByDeviareId)]
  HRESULT GetByDeviareId([in] my_ssize_t devId, [out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktModulesEnum::GetByName([in] BSTR dllName, [out, retval] INktModule **ppMod);
   *
   * \brief	Find a module by the given name.
   *
   * \param	name		The name of DLL module.
   * \param [in,out]	ppProc	Address of pointer to receive INktModule interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_INVALIDARG if name string pointer is null, or string is empty.
   * \return \c NKTDV_ERR_NotFound if item not found (ppMod is set to NULL).
   *
    */

  [helpstring("Find a module by the given name"),
   id(dispidNktModulesEnumGetByName)]
  HRESULT GetByName([in] BSTR dllName, [out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktModulesEnum::GetByAddress([in] my_ssize_t addr,
   * 		[in] eNktSearchMode searchMode, [out, retval] INktModule **ppMod);
   *
   * \brief	Find a module by the given address.
   *
   * \param	addr			 	The address.
   * \param	searchMode		 	The search mode to use.
   * \param [in,out]	ppMod	Address of pointer to receive INktModule interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c NKTDV_ERR_NotFound if item not found (pointer  is set to NULL).
   */

  [helpstring("Find a module by the given address"),
   id(dispidNktModulesEnumGetByAddress)]
  HRESULT GetByAddress([in] my_ssize_t addr, [in] eNktSearchMode searchMode,
                       [out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktModulesEnum::FunctionByName([in] BSTR dllFunc, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find an exported function by the given name.
   *
   * \param	dllFunc				 	The export name.
   * \param [in,out]	ppExpFunc	Address of pointer to receive INktExportedFunction interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if provided export name is null or empty.
   * \return \c NKTDV_ERR_NotFound if item not found (pointer  is set to NULL).
   */

  [helpstring("Find an exported function by the given name"),
   id(dispidNktModulesEnumFunctionByName)]
  HRESULT FunctionByName([in] BSTR dllFunc, [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktModulesEnum::FunctionByAddress([in] my_ssize_t addr,
   * 		[in] eNktSearchMode searchMode, [out, retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find an exported function by the given address.
   *
   * \param	addr				 	The address.
   * \param	searchMode			 	The search mode to use.
   * \param [in,out]	ppExpFunc	Address of pointer to receive INktExportedFunction interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c NKTDV_ERR_NotFound if item not found (pointer  is set to NULL).
   */

  [helpstring("Find an exported function by the given address"),
   id(dispidNktModulesEnumFunctionByAddress)]
  HRESULT FunctionByAddress([in] my_ssize_t addr, [in] eNktSearchMode searchMode,
                            [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktModulesEnum::_NewEnum([out, retval] IUnknown** ppUnk);
   *
   * \brief	Retrieves an enumerable collection object.
   *
   * \param [out, retval]	ppUnk	Address of an interface pointer that on return points to the IUnknown interface of an enumerator object.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if ppUnk is NULL.
   * \return \c E_FAIL on general failure.
   */

  [propget, helpstring("Retrieves an enumerable collection object"),
   id(DISPID_NEWENUM), restricted]
  HRESULT _NewEnum([out, retval] IUnknown** ppUnk);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktExportedFunction
 *
 * \brief	Exposes methods for accessing exported functions.
 *
 * 
 * 
 */

[
  object,
  uuid(1B91884B-E65C-487d-AE89-0D86278C93C9),
  dual, local,
  nonextensible,
  helpstring("INktExportedFunction Interface"),
  pointer_default(unique)
]
interface INktExportedFunction : INktObject
{
  /**
   * \fn	HRESULT INktExportedFunction::Ordinal([out, retval] LONG *pVal);
   *
   * \brief	Get the function ordinal value.
   *
   * \param [in,out]	pVal	Address of pointer to store the ordinal.
   *
   * \return S_OK on success
   * \return E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get the function's ordinal value"),
   id(dispidNktExportedFunctionOrdinal)]
  HRESULT Ordinal([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::Name([out, retval] BSTR *pVal);
   *
   * \brief	Get the function name.
   *
   * \param [in,out]	pVal	Address of pointer to store the name string.
   *
   * \return S_OK on success
   * \return E_POINTER if pointer argument is NULL.
   * \return E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the function's name"),
   id(dispidNktExportedFunctionName)]
  HRESULT Name([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::ModuleName([out, retval] BSTR *pVal);
   *
   * \brief	Get the name of the module where this function resides.
   *
   * \param [in,out]	pVal	Address of pointer to store the module name string.
   *
   * \return S_OK on success
   * \return E_POINTER if pointer argument is NULL.
   * \return E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the name of the module where this function resides"),
   id(dispidNktExportedFunctionModuleName)]
  HRESULT ModuleName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::CompleteName([out, retval] BSTR *pVal);
   *
   * \brief	Get the complete name of the function.
   *
   * \param [in,out]	pVal	Address of pointer to store the function name string.
   *
   * \return S_OK on success
   * \return E_POINTER if pointer argument is NULL.
   * \return E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the complete name of the function"),
   id(dispidNktExportedFunctionCompleteName)]
  HRESULT CompleteName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::IsForwarded([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Get if the function is forwarded or not.
   *
   * \param [in,out]	pVal	Address of pointer to store boolean value.
   *
   * \return S_OK on success
   * \return E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get if the function is forwarded or not"),
   id(dispidNktExportedFunctionIsForwarded)]
  HRESULT IsForwarded([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::ForwardedApiName([out, retval] BSTR *pVal);
   *
   * \brief	Get the destination function name if forwarded.
   *
   * \param [in,out]	pVal	Address of pointer to store the target function name string.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the destination function name if forwarded"),
   id(dispidNktExportedFunctionForwardedApiName)]
  HRESULT ForwardedApiName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::ForwardedModuleName([out, retval] BSTR *pVal);
   *
   * \brief	Get the destination module name if forwarded.
   *
   * \param [in,out]	pVal	Address of pointer to store the target module name string.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the destination module name if forwarded"),
   id(dispidNktExportedFunctionForwardedModuleName)]
  HRESULT ForwardedModuleName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::ForwardedCompleteName([out, retval] BSTR *pVal);
   *
   * \brief	Get the full destination name if forwarded.
   *
   * \param [in,out]	pVal	Address of pointer to store the complete forwarded function name string.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the full destination name if forwarded"),
   id(dispidNktExportedFunctionForwardedCompleteName)]
  HRESULT ForwardedCompleteName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::AddrBase([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the base address of the module that contains this function.
   *
   * \param [in,out]	pVal	Address of pointer to store base address.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get the base address of the module that contains this function"),
   id(dispidNktExportedFunctionAddrBase)]
  HRESULT AddrBase([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::AddrOffset([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the offset of the function inside the containing module.
   *
   * \param [in,out]	pVal	Address of pointer to store offset address.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get the offset of the function inside the containing module"),
   id(dispidNktExportedFunctionAddrOffset)]
  HRESULT AddrOffset([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::Addr([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the address of the function.
   *
   * \param [in,out]	pVal	Address of pointer to store function address.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get the address of the function"),
   id(dispidNktExportedFunctionAddr)]
  HRESULT Addr([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::CallingConv([out, retval] eNktDboCallingConvention *pVal);
   *
   * \brief	Get the function calling convention.
   *
   * \param [in,out]	pVal	Address of pointer to store function calling convention.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get the function's calling convention"),
   id(dispidNktExportedFunctionCallingConv)]
  HRESULT CallingConv([out, retval] eNktDboCallingConvention *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::DbObject([out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Get the database object associated with this function.
   *
   * \param [in,out]	ppDbObject	 Address of pointer to receive INktDbObject database interface.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   *
   */

  [helpstring("Get the database object associated with this function"),
   id(dispidNktExportedFunctionDbObject)]
  HRESULT DbObject([out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktExportedFunction::HasDeclaration([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if the exported function has a declaration.
   *
   * \param [in,out]	pVal	Address of pointer to receive boolean value.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Check if the exported function has a declaration"),
   id(dispidNktExportedFunctionHasDeclaration)]
  HRESULT HasDeclaration([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktExportedFunction::Declaration([out, retval] BSTR *pVal);
   *
   * \brief	Get the declaration of the exported function.
   *
   * \param [in,out]	pVal	Address of pointer to receive the exported declaration string.
   *
   * \return \c S_OK on success
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the declaration of the exported function"),
   id(dispidNktExportedFunctionDeclaration)]
  HRESULT Declaration([out, retval] BSTR *pVal);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktExportedFunctionsEnum
 *
 * \brief	Exposes methods for enumerating a INktExportedFunctionsEnum collection.
 *
 * 
 * 
 */

[
  object,
  uuid(B110FD2E-174C-40ec-B180-AA2BF98C992D),
  dual, local,
  nonextensible,
  helpstring("INktExportedFunctionsEnum Interface"),
  pointer_default(unique)
]
interface INktExportedFunctionsEnum : INktObject
{
  /**
   * \fn	HRESULT INktExportedFunctionsEnum::Count([out, retval] LONG *pVal);
   *
   * \brief	Get the total items count in this collection.
   *
   * \param [in,out]	pVal	Address of pointer to store the item count. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the total items count in this collection"),
   id(dispidNktExportedFunctionsEnumCount)]
  HRESULT Count([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::GetAt([in] LONG index, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Retrieves the item at the specified index.
   *
   * \param	index			 	Zero-based index.
   * \param [in,out]	ppExpFunc	Address of pointer to store the item count. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if index parameter is out of bounds.
   */
  [helpstring("Retrieves the item at the specified index"),
   id(dispidNktExportedFunctionsEnumGetAt)]
  HRESULT GetAt([in] LONG index, [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::First([out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Retrieves the first item in the collection.
   *
   * \param [in,out]	ppExpFunc	Address of pointer to receive INktExportedFunction interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the first item in the collection"),
   id(dispidNktExportedFunctionsEnumFirst)]
  HRESULT First([out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::Last([out, retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Retrieves the last item in the collection.
   *
   * \param [in,out]	ppExpFunc	Address of pointer to receive INktExportedFunction interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the last item in the collection"),
   id(dispidNktExportedFunctionsEnumLast)]
  HRESULT Last([out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::Next([out, retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Retrieves the next item in the collection.
   *
   * \param [in,out]	ppExpFunc	Address of pointer to receive INktExportedFunction interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the next item in the collection"),
   id(dispidNktExportedFunctionsEnumNext)]
  HRESULT Next([out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::Previous([out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Retrieves the previous item in the collection.
   *
   * \param [in,out]	ppExpFunc	Address of pointer to receive INktExportedFunction interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the previous item in the collection"),
   id(dispidNktExportedFunctionsEnumPrevious)]
  HRESULT Previous([out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::GetByDeviareId([in] my_ssize_t devId, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find an item by its deviare id.
   *
   * \param	devId			  	The ID to search for.
   * \param [in,out]	ppExp	Address of pointer to receive INktExportedFunction interface. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if devId is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppExp is set to NULL).
   */

  [helpstring("Find an item by its deviare id"),
   id(dispidNktExportedFunctionsEnumGetByDeviareId)]
  HRESULT GetByDeviareId([in] my_ssize_t devId, [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::GetByOrdinal([in] LONG ordinal, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find an exported function by the given ordinal index.
   *
   * \param	ordinal				 	The ordinal.
   * \param [in,out]	ppExpFunc	Address of pointer to receive INktExportedFunction interface. 

   * \return S_OK or E_FAIL.
   */

  [helpstring("Find an exported function by the given ordinal index"),
   id(dispidNktExportedFunctionsEnumGetByOrdinal)]
  HRESULT GetByOrdinal([in] LONG ordinal, [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::GetByName([in] BSTR funcName, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find an exported function by the given name.
   *
   * \param	funcName				 	The export name.
   * \param [in,out]	ppExpFunc	Address of pointer to receive INktExportedFunction interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if provided export name is null or empty.
   * \return \c NKTDV_ERR_NotFound if item not found (pointer  is set to NULL).
   */

  [helpstring("Find an exported function by the given name"),
   id(dispidNktExportedFunctionsEnumGetByName)]
  HRESULT GetByName([in] BSTR funcName, [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::GetByAddress([in] my_ssize_t addr,
   * 		[in] VARIANT_BOOL searchNearest, [out, retval] INktExportedFunction **ppExpFunc);
   *
      * \brief	Find an exported function by the given address.
   *
   * \param	addr				 	The address.
   * \param	searchNearest		 	\c TRUE to use nearest match, \c FALSE to use exact match.
   * \param [in,out]	ppExpFunc	Address of pointer to receive INktExportedFunction interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c NKTDV_ERR_NotFound if item not found (pointer  is set to NULL).
   */

  [helpstring("Find an exported function by the given address"),
   id(dispidNktExportedFunctionsEnumGetByAddress)]
  HRESULT GetByAddress([in] my_ssize_t addr, [in] VARIANT_BOOL searchNearest,
                       [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktExportedFunctionsEnum::_NewEnum([out, retval] IUnknown** ppUnk);
   *
   * \brief	Retrieves an enumerable collection object.
   *
   * \param [out, retval]	ppUnk	Address of an interface pointer that on return points to the IUnknown interface of an enumerator object.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if ppUnk is NULL.
   * \return \c E_FAIL on general failure.
   */

  [propget, helpstring("Retrieves an enumerable collection object"),
   id(DISPID_NEWENUM), restricted]
  HRESULT _NewEnum([out, retval] IUnknown** ppUnk);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktHook
 *
 * \brief	Exposes methods to operate with hooks (e.g:attach, detach, enable,etc).
 *
 * 
 * 
 */

[
  object,
  uuid(F69A083D-105F-417b-B1E3-EE430E58431A),
  dual, local,
  nonextensible,
  helpstring("INktHook Interface"),
  pointer_default(unique)
]
interface INktHook : INktObject
{
  /**
   * \fn	HRESULT INktHook::Id([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the hook id.
   *
   * \param [in,out]	pVal	Address of pointer to receive the value.
   *
   * \return S_OK on success.
   * \return E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the hook id"),
   id(dispidNktHookId)]
  HRESULT Id([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktHook::Destroy();
   *
   * \brief	Destroys the hook and detaches from processes.
   *
   * \return \c S_OK on success.
   */

  [helpstring("Destroy the hook and removes attached processes"),
   id(dispidNktHookDestroy)]
  HRESULT Destroy();

  /**
   * \fn	HRESULT INktHook::Attach([in] VARIANT procOrId, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Attaches hook to a process. 
   *
   * \param	procOrId	Variant specifying to which process to attach. Can be either ::INktProcess pointer or numeric PID value.
   * \param	sync		If \c TRUE, this call waits for operation completion before returning.
   *
   * \return \c S_OK on success.
   * \return \c NKT_DVERR_NotFound if specified process does not exist.
   * \return \c E_INVALIDARG if process ID is invalid.
   * \return \c E_OUTOFMEMORY if an internal out of memory error has occured.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Attaches a process to the hook. Can be a used with process object or process id"),
   id(dispidNktHookAttach)]
  HRESULT Attach([in] VARIANT procOrId, [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHook::Detach([in] VARIANT procOrId, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Detaches hook from process.
   *
   * \param	procOrId	Variant specifying to which process to attach. Can be either ::INktProcess pointer or numeric PID value.
   * \param	sync		If \c TRUE, this call waits for operation completion before returning.
   *
   * \return \c S_OK on success.
   * \return \c NKT_DVERR_NotFound if specified process does not exist.
   * \return \c NKT_DVERR_Cancelled if asynchronous detach operation was cancelled.
   * \return \c E_INVALIDARG if process ID is invalid.
   * \return \c E_OUTOFMEMORY if an internal out of memory error has occured.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Detaches a process to the hook. Can be a used with process object or process id"),
   id(dispidNktHookDetach)]
  HRESULT Detach([in] VARIANT procOrId, [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHook::Enable([in] VARIANT procOrId, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL enable, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Enables or disables an attached process. 
   *
   * \param	procOrId	Variant specifying to which process to attach. Can be either ::INktProcess pointer or numeric PID value.
   * \param	enable  	\c TRUE to enable hook.
   * \param	sync		If \c TRUE, this call waits for operation completion before returning.
   *
   * \return \c S_OK on success.
   * \return \c NKT_DVERR_NotFound if specified process does not exist.
   * \return \c NKT_DVERR_Cancelled if asynchronous detach operation was cancelled.
   * \return \c E_INVALIDARG if process ID is invalid.
   * \return \c E_OUTOFMEMORY if an internal out of memory error has occured.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Enables/disables an attached process. Can be a used with process object or process id"),
   id(dispidNktHookEnable)]
  HRESULT Enable([in] VARIANT procOrId, [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL enable,
                 [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHook::State([in] VARIANT procOrId, [out, retval] eNktHookState *pVal);
   *
   * \brief	Returns the state of the hook regarding the specified process.
   *
   * \param	[in]	procOrId	Variant specifying process to query. Can be either ::INktProcess pointer or numeric PID value.
   * \param [out]	pVal	Address of pointer to receive an eNktHookState constant value.
   *
   * \return \c S_OK on success,
   * \return \c E_POINTER if pVal is NULL.
   */

  [helpstring("Returns the state of the hook regarding the specified process."),
   id(dispidNktHookState)]
  HRESULT State([in] VARIANT procOrId, [out, retval] eNktHookState *pVal);

  /**
   * \fn	HRESULT INktHook::QueryOverwrite([in] VARIANT procOrId, [out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Checks if the hook was overwritten in the specified process.
   *
   * \param	[in]	procOrId	Variant specifying process to query. Can be either ::INktProcess pointer or numeric PID value.
   * \param [out]	pVal	Address of pointer to receive the boolean result.
   *
   * \return \c S_OK on success,
   * \return \c E_POINTER if pVal is NULL.
   */

  [helpstring("Checks if the hook was overwritten in the specified process."),
   id(dispidNktHookQueryOverwrite)]
  HRESULT QueryOverwrite([in] VARIANT procOrId, [out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktHook::LastError([in] VARIANT procOrId, [out, retval] LONG *pVal);
   *
   * \brief	Get the state of the hook in the specified process.
   *
   * \param	procOrId			Variant specifying process to query. Can be either ::INktProcess pointer or numeric PID value.
   * \param [in,out]	pVal	Address of pointer to receive last error value.
   *
   * \return \c S_OK on success,
   * \return \c E_POINTER if pVal is NULL.
   */

  [helpstring("Get the state of the hook in the specified process"),
   id(dispidNktHookLastError)]
  HRESULT LastError([in] VARIANT procOrId, [out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktHook::Hook([in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Activate the hook in all processes.
   *
   * \param	sync	If \c TRUE, this call waits for operation completion before returning.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL if this hook is not active.
   * 
   */

  [helpstring("Activate the hook in all processes"),
   id(dispidNktHookHook)]
  HRESULT Hook([in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHook::Unhook([in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Deactivate the hook in all processes.
   *
   * \param	sync	If \c TRUE, this call waits for operation completion before returning.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL if this hook is not active.
   */

  [helpstring("Deactivate the hook in all processes"),
   id(dispidNktHookUnhook)]
  HRESULT Unhook([in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHook::AddCustomHandler([in] BSTR handlerDll, [in] LONG handlerFlags,
   *                                        [in] BSTR parameters);
   *
   * \brief	Adds a custom handler DLL with optional user-defined function parameters.
   *
   * \param	handlerDll	The DLL that will handle function calls intercepted by this hook.
   * \param	handlerFlags		  	The hook handler flags, any combination of ::eNktHookCustomHandlerFlags
   * \param	parameters		  	Optional user defined string parameters to pass when Deviare calls the \c OnHookAdded DLL function.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER  if handlerDll is NULL.
   * \return \c E_INVALIDARG is handlerDll is an empty string.
   *
   * \remarks The handler DLL should export a number of predefined functions for SpyMgr to call the DLL functions properly. The C++ signatures of such functions are:
   *
   * \code{.cpp}
   * extern "C" HRESULT WINAPI OnLoad();
   * extern "C" HRESULT WINAPI OnUnload();
   * extern "C" HRESULT WINAPI OnHookAdded(__in INktHookInfo *lpHookInfo, __in DWORD dwChainIndex, __in LPCWSTR szParametersW);
   * extern "C" HRESULT WINAPI OnHookRemoved(__in INktHookInfo *lpHookInfo, __in DWORD dwChainIndex);
   * extern "C" HRESULT WINAPI OnFunctionCall(__in INktHookInfo *lpHookInfo, __in DWORD dwChainIndex, __in INktHookCallInfoPlugin *lpHookCallInfoPlugin);
   * \endcode
   */

  [helpstring("Adds a custom handler for the specified function parameter"),
   id(dispidNktHookAddCustomHandler)]
  HRESULT AddCustomHandler([in] BSTR handlerDll, [in] LONG handlerFlags, [in] BSTR parameters);

  /**
   * \fn	HRESULT INktHook::RemoveAllHandlers();
   *
   * \brief	Removes all the local and custom handlers from this hook.
   *
   * \return \c S_OK on success.
   */

  [helpstring("Removes all the basic type and custom handlers from this hook"),
   id(dispidNktHookRemoveAllHandlers)]
  HRESULT RemoveAllHandlers();

  /**
   * \fn	HRESULT INktHook::FunctionName([out, retval] BSTR *pVal);
   *
   * \brief	Get the function name this hook was set to intercept.
   *
   * \param [in,out]	pVal	Address of pointer to receive the function name string.
   *
   * \return S_OK on success.
   * \return E_POINTER if pVal is NULL.
   * \return E_OUTOFMEMORY if provided buffer has insufficient space.
   */

  [propget, helpstring("Get the function name of this hook"),
   id(dispidNktHookFunctionName)]
  HRESULT FunctionName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktHook::Flags([out, retval] LONG *pVal);
   *
   * \brief	Get the current flags.
   *
   * \param [in,out]	pVal	Address of pointer to receive a combination of ::eNktHookFlags
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the current flags"),
   id(dispidNktHookFlags)]
  HRESULT Flags([out, retval] LONG *pVal);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktHooksEnum
 *
 * \brief	Exposes methods for enumerating INktHook based collections.
 *
 * 
 * 
 */

[
  object,
  uuid(A31B9BE8-CE9A-4d7c-A624-20640ACA532C),
  dual, local,
  nonextensible,
  helpstring("INktHooksEnum Interface"),
  pointer_default(unique)
]
interface INktHooksEnum : INktObject
{
  /**
   * \fn	HRESULT INktHooksEnum::Count([out, retval] LONG *pVal);
   *
   * \brief	Get the total item count in this collection.
   *
   * \param [in,out]	pVal	Address of pointer to receive the item count. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the total items count in this collection"),
   id(dispidNktHooksEnumCount)]
  HRESULT Count([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktHooksEnum::GetAt([in] LONG index, [out, retval] INktHook **ppHook);
   *
   * \brief	Retrieves the item at the specified index.
   *
   * \param	index			 	Zero-based index.
   * \param [in,out]	ppHook	Address of pointer to receive the item.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if index parameter is out of bounds.
   */

  [helpstring("Retrieves the item at the specified index"),
   id(dispidNktHooksEnumGetAt)]
  HRESULT GetAt([in] LONG index, [out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktHooksEnum::First([out, retval] INktHook **ppHook);
   *
   * \brief	Retrieves the first item in the collection.
   *
   * \param [in,out]	ppHook	Address of pointer to receive the item.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the first item in the collection"),
   id(dispidNktHooksEnumFirst)]
  HRESULT First([out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktHooksEnum::Last([out, retval] INktHook **ppHook);
   *
   * \brief	Retrieves the last item in the collection.
   *
   * \param [in,out]	ppHook	Address of pointer to receive the item.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the last item in the collection"),
   id(dispidNktHooksEnumLast)]
  HRESULT Last([out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktHooksEnum::Next([out, retval] INktHook **ppHook);
   *
   * \brief	Retrieves the next item in the collection.
   *
   * \param [in,out]	ppHook	Address of pointer to receive the item.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the next item in the collection"),
   id(dispidNktHooksEnumNext)]
  HRESULT Next([out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktHooksEnum::Previous([out, retval] INktHook **ppHook);
   *
   * \brief	Retrieves the previous item in the collection.
   *
   * \param [in,out]	ppHook	Address of pointer to receive the item.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the previous item in the collection"),
   id(dispidNktHooksEnumPrevious)]
  HRESULT Previous([out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktHooksEnum::GetByDeviareId([in] my_ssize_t devId, [out,
   * 		retval] INktHook **ppHook);
   *
   * \brief	Find an item by its deviare id.
   *
   * \param	devId			  	The ID to search for.
   * \param [in,out]	ppHook	Address of pointer to receive the item. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if devId is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppHook is set to NULL).
   */

  [helpstring("Find an item by its deviare id"),
   id(dispidNktHooksEnumGetByDeviareId)]
  HRESULT GetByDeviareId([in] my_ssize_t devId, [out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktHooksEnum::GetById([in] my_ssize_t id, [out, retval] INktHook **ppHook);
   *
   * \brief	Find a hook by its id.
   *
   * \param	id			  	The ID to search for.
   * \param [in,out]	ppHook	Address of pointer to receive the item. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if Id is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppHook is set to NULL).
   *
   * \return S_OK or E_FAIL.
   */

  [helpstring("Find a hook by its id"),
   id(dispidNktHooksEnumGetById)]
  HRESULT GetById([in] my_ssize_t id, [out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktHooksEnum::Add([in] INktHook *pHook);
   *
   * \brief	Adds a hook to the collection.
   *
   * \param	pHook	A pointer to the hook to add.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pHook is NULL.
   */

  [helpstring("Add a hook to the collection"),
   id(dispidNktHooksEnumAdd)]
  HRESULT Add([in] INktHook *pHook);

  /**
   * \fn	HRESULT INktHooksEnum::Attach([in] VARIANT procOrId, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Attaches all hooks in this collection to a process. 
   *
   * \param	procOrId	Variant specifying to which process to attach. Can be either ::INktProcess pointer or numeric PID value.
   * \param	sync		If \c TRUE, this call waits for operation completion before returning..
   *
   * \return \c S_OK on success.
   * \return \c NKT_DVERR_NotFound if specified process does not exist.
   * \return \c E_INVALIDARG if process ID is invalid.
   * \return \c E_OUTOFMEMORY if an internal out of memory error has occured.
   * \return \c E_FAIL on general error.
   */

  [helpstring("	Attaches all hooks in this collection to a process"),
   id(dispidNktHooksEnumAttach)]
  HRESULT Attach([in] VARIANT procOrId, [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHooksEnum::Detach([in] VARIANT procOrId, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Detaches all hooks in the collection from a process. 
   *
   * \param	procOrId	Variant specifying to which process to attach. Can be either ::INktProcess pointer or numeric PID value.
   * \param	sync		If \c TRUE, this call waits for operation completion before returning.
   *
   * \return \c S_OK on success.
   * \return \c NKT_DVERR_NotFound if specified process does not exist.
   * \return \c NKT_DVERR_Cancelled if asynchronous detach operation was cancelled.
   * \return \c E_INVALIDARG if process ID is invalid.
   * \return \c E_OUTOFMEMORY if an internal out of memory error has occured.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Detaches all hooks in the collection from a process"),
   id(dispidNktHooksEnumDetach)]
  HRESULT Detach([in] VARIANT procOrId, [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHooksEnum::Enable([in] VARIANT procOrId, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL enable, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Enables or disables all hooks in the collection from the process they are attached on. 
   *
   * \param	procOrId	Variant specifying to which process to attach. Can be either ::INktProcess pointer or numeric PID value.
   * \param	enable  	\c TRUE to enable hook.
   * \param	sync		If \c TRUE, this call waits for operation completion before returning.
   *
   * \return \c S_OK on success.
   * \return \c NKT_DVERR_NotFound if specified process does not exist.
   * \return \c NKT_DVERR_Cancelled if asynchronous detach operation was cancelled.
   * \return \c E_INVALIDARG if process ID is invalid.
   * \return \c E_OUTOFMEMORY if an internal out of memory error has occured.
   * \return \c E_FAIL on general error..
   */

  [helpstring("Enables/disables an attached process. Can be a used with process object or process id"),
   id(dispidNktHooksEnumEnable)]
  HRESULT Enable([in] VARIANT procOrId, [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL enable,
                 [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHooksEnum::Hook([in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Activate all the hooks in the collection.
   *
   * \param	sync	If \c TRUE, this call waits for operation completion before returning.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on error condition.
   */

  [helpstring("Activate the hooks in the list in all processes"),
   id(dispidNktHooksEnumHook)]
  HRESULT Hook([in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHooksEnum::Unhook([in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);
   *
   * \brief	Deactivate all the hooks in the collection.
   *
   * \param	sync	If \c TRUE, this call waits for operation completion before returning.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on error condition.
   */

  [helpstring("Deactivate the hooks in the list in all processes"),
   id(dispidNktHooksEnumUnhook)]
  HRESULT Unhook([in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync);

  /**
   * \fn	HRESULT INktHooksEnum::QueryOverwrite([in] VARIANT procOrId, [out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Checks if the hook was overwritten in the specified process.
   *
   * \param	[in]	procOrId	Variant specifying process to query. Can be either ::INktProcess pointer or numeric PID value.
   * \param [out]	pVal	Address of pointer to receive the boolean result.
   *
   * \return \c S_OK on success,
   * \return \c E_POINTER if pVal is NULL.
   */

  [helpstring("Checks if the hook was overwritten in the specified process."),
   id(dispidNktHooksEnumQueryOverwrite)]
  HRESULT QueryOverwrite([in] VARIANT procOrId, [out, retval] VARIANT *pVal);

  /**
   * \fn	HRESULT INktHooksEnum::_NewEnum([out, retval] IUnknown** ppUnk);
   *
   * \brief	Retrieves an enumerable collection object.
   *
   * \param [out, retval]	ppUnk	Address of an interface pointer that on return points to the IUnknown interface of an enumerator object.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if ppUnk is NULL.
   * \return \c E_FAIL on general failure.
   */

  [propget, helpstring("Retrieves an enumerable collection object"),
   id(DISPID_NEWENUM), restricted]
  HRESULT _NewEnum([out, retval] IUnknown** ppUnk);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktParam
 *
 * \brief	Exposes methods for accessing function call parameter information.
 *
 * 
 * 
 */

[
  object,
  uuid(BB0A417B-D0F2-4c69-8158-95087B0A0C8F),
  dual, local,
  nonextensible,
  helpstring("INktParam Interface"),
  pointer_default(unique)
]
interface INktParam : INktObject
{
  /**
   * \fn	HRESULT INktParam::Address([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the remote address where this parameter resides.
   *
   * \param [in,out]	pVal	Pointer to receive the address value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get the remote address where this parameter resides"),
   id(dispidNktParamAddress)]
  HRESULT Address([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktParam::Class([out, retval] eNktDboClass *pVal);
   *
   * \brief	Get the class type of this parameter.
   *
   * \param [in,out]	pVal	Pointer to receive the class value; one of ::eNktDboClass enumeration.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.

   */

  [propget, helpstring("Get the class type of this parameter"),
   id(dispidNktParamClass)]
  HRESULT Class([out, retval] eNktDboClass *pVal);

  /**
   * \fn	HRESULT INktParam::BasicType([out, retval] eNktDboFundamentalType *pVal);
   *
   * \brief	Get the basic type of this parameter.
   *
   * \param [in,out]	pVal	Pointer to receive the class value; one of ::eNktDboFundamentalType enumeration.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get the basic type of this parameter"),
   id(dispidNktParamBasicType)]
  HRESULT BasicType([out, retval] eNktDboFundamentalType *pVal);

  /**
   * \fn	HRESULT INktParam::Name([out, retval] BSTR *pVal);
   *
   * \brief	Get the name of this parameter.
   *
   * \param [in,out]	pVal	Pointer to string to receive the parameter name.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the name of this parameter"),
   id(dispidNktParamName)]
  HRESULT Name([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktParam::TypeName([out, retval] BSTR *pVal);
   *
   * \brief	Get the type name of this parameter.
   *
   * \param [in,out]	pVal	Pointer to string to receive the parameter type name.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the type name of this parameter"),
   id(dispidNktParamTypeName)]
  HRESULT TypeName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktParam::Declaration([out, retval] BSTR *pVal);
   *
   * \brief	Get the declaration of this parameter.
   *
   * \param [in,out]	pVal	Pointer to string to receive the parameter declaration.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the declaration of this parameter"),
   id(dispidNktParamDeclaration)]
  HRESULT Declaration([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktParam::Flags([out, retval] LONG *pVal);
   *
   * \brief	Get miscellaneous flags associated with this parameter.
   *
   * \param [in,out]	pVal	Pointer to receive a combination of ::eNktDboItemFlags. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get miscellaneous flags associated with this parameter"),
   id(dispidNktParamFlags)]
  HRESULT Flags([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktParam::IsPointer([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if this parameter is a pointer.
   *
   * \param [in,out]	pVal	Pointer to receive boolean \c VARIANT_TRUE if this parameter is of pointer type.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Check if this parameter is a pointer to something"),
   id(dispidNktParamIsPointer)]
  HRESULT IsPointer([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktParam::IsArray([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if this parameter is an array.
   *
   * \param [in,out]	pVal	Pointer to receive boolean \c VARIANT_TRUE if this parameter is of array type.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Check if this parameter is an array of something"),
   id(dispidNktParamIsArray)]
  HRESULT IsArray([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktParam::ArrayMaxHint([out, retval] LONG *pVal);
   *
   * \brief	If parameter is an array, get a hint of the upper bound index. 
   *
   * \param [in,out]	pVal	Pointer to receive array upper bound index value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   *
   * \remarks This function will return a negative value if the array upper bound is not known or does not exist.
   */

  [propget, helpstring("If parameter is an array, get a hint of the upper bound index (negative value if unlimited)"),
   id(dispidNktParamArrayMaxHint)]
  HRESULT ArrayMaxHint([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktParam::IsAnsiString([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if this parameter can be treated as an ANSI string.
   *
   * \param [in,out]	pVal	Pointer to receive boolean \c VARIANT_TRUE if this parameter can be treated as ANSI String.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Check if this parameter can be treated as an ansi string"),
   id(dispidNktParamIsAnsiString)]
  HRESULT IsAnsiString([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktParam::IsWideString([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if this parameter can be treated as a wide string.
   *
   * \param [in,out]	pVal	Pointer to receive boolean \c VARIANT_TRUE if this parameter can be treated as wide string.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Check if this parameter can be treated as a wide string"),
   id(dispidNktParamIsWideString)]
  HRESULT IsWideString([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktParam::IntResourceString([out, retval] LONG *pVal);
   *
   * \brief	Check if this parameter is an encoded resource string.
   *
   * \param [in,out]	pVal	pVal	Pointer to receive boolean \c VARIANT_TRUE if this parameter is an encoded resource string.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Check if this parameter is an encoded resource string"),
   id(dispidNktParamIntResourceString)]
  HRESULT IntResourceString([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktParam::GuidString([out, retval] BSTR *pVal);
   *
   * \brief	Cast this parameter as a GUID, IID, CLSID or UUID struct and retrieves its value.
   *
   * \param [in,out]	pVal	Pointer to string to receive GUID value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space to store GUID identifier.
   *
   * \remarks If the parameter type is not GUID (or compatible type), the function returns S_OK and clears string argument.
   */

  [propget, helpstring("Check if this parameter is a GUID, IID, CLSID or UUID struct and retrieves"
                       " its value"),
   id(dispidNktParamGuidString)]
  HRESULT GuidString([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktParam::Evaluate([out, retval] INktParam **ppParam);
   *
   * \brief	Dereference a pointer parameter and returns a proper interface.
   *
   * \param [in,out]	ppParam Pointer to address to receive the dereferenced parameter interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_FAIL if error or this parameter is not of pointer-type.
   */

  [helpstring("Evaluates this parameter"),
   id(dispidNktParamEvaluate)]
  HRESULT Evaluate([out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParam::IndexedEvaluate([in] LONG index, [out, retval] INktParam **ppParam);
   *
   * \brief	Dereference the pointer stored at specified index if the parameter is an array.
   *
   * \param	index			   	Zero-based index.
   * \param [in,out]	ppParam	Pointer to address to receive the dereferenced parameter interface.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if specified index is invalid.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_FAIL if general error, this parameter is not array, or the stored array value cannot be dereferenced.
   */

  [helpstring("Evaluate the index of this parameter if it is an array"),
   id(dispidNktParamIndexedEvaluate)]
  HRESULT IndexedEvaluate([in] LONG index, [out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParam::FullEvaluate([out, retval] INktParam **ppParam);
   *
   * \brief	Recursively dereference this pointer parameter.
   *
   * \param [in,out]	ppParam	Pointer to address to receive the dereferenced parameter interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_FAIL if error or this parameter is not of pointer-type.
   */

  [helpstring("Recursively evaluates this parameter"),
   id(dispidNktParamFullEvaluate)]
  HRESULT FullEvaluate([out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParam::FieldsCount([out, retval] LONG *pVal);
   *
   * \brief	Get the fields count of a struct or union.
   *
   * \param [in,out]	pVal	Pointer to receive the field count value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get the fields count of a struct or union"),
   id(dispidNktParamFieldsCount)]
  HRESULT FieldsCount([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktParam::Field([in] VARIANT indexOrName, [out, retval] INktParam **ppParam);
   *
   * \brief	Get a field from struct or union typed parameter.
   *
   * \param	indexOrName			   	A variant specifying which field to extract; valid type is either numeric index or field name string.
   * \param [in,out]	ppParam	Adress of pointer to receive field parameter interface, if any.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is null.
   * \return \c E_INVALIDARG if field index or name is not valid.
   * \return \c E_FAIL if this parameter is not struct or union, or general error.
   * \return \c NKT_DVERR_NotFound if field not found.   
   */

  [helpstring("Get a field from struct or union typed parameter"),
   id(dispidNktParamField)]
  HRESULT Field([in] VARIANT indexOrName, [out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParam::Fields([out, retval] INktParamsEnum **ppParamsEnum);
   *
   * \brief	Get a collection with fields of a struct or union typed parameter.
   *
   * \param [in,out]	ppParamsEnum	Address of pointer to receive a parameter enumerator interface to access the collection.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is null.
   */

  [helpstring("Get a collection with fields of a struct or union typed parameter"),
   id(dispidNktParamFields)]
  HRESULT Fields([out, retval] INktParamsEnum **ppParamsEnum);

  /**
   * \fn	HRESULT INktParam::Value([out, retval] VARIANT *pVal);
   *
   * \brief	Read parameter value as variant.
   *
   * \param [in,out]	pVal	Pointer to variant to receive value. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is null.
   */

  [propget, helpstring("Read variant parameter data"),
   id(dispidNktParamValue)]
  HRESULT Value([out, retval] VARIANT *pVal);

  /**
   * \fn	HRESULT INktParam::Value([in] VARIANT var);
   *
   * \brief	Write variant parameter data.
   *
   * \param	[in] var	The variant to write. 
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL if variant type is not supported or general error.   
   */

  [propput, helpstring("Write variant parameter data"),
   id(dispidNktParamValue)]
  HRESULT Value([in] VARIANT var);

  /**
   * \fn	HRESULT INktParam::ValueAt([in] LONG index, [out, retval] VARIANT *pVal);
   *
   * \brief	Reads data at the specified parameter index.
   *
   * \param	index				Zero-based parameter index.
   * \param [in,out]	pVal	Pointer to variant to receive value. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is null.
   * \return \c E_INVALIDARG if specified index is invalid.
   */

  [propget, helpstring("Read data at the specified parameter index"),
   id(dispidNktParamValueAt)]
  HRESULT ValueAt([in] LONG index, [out, retval] VARIANT *pVal);

  /**
   * \fn	HRESULT INktParam::ValueAt([in] LONG index, [in] VARIANT var);
   *
   * \brief	Write data at the specified parameter index.
   *
   * \param	index	Zero-based parameter index.
   * \param	var  	The variant to write.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if specified index is invali
   */

  [propput, helpstring("Write data at the specified parameter index"),
   id(dispidNktParamValueAt)]
  HRESULT ValueAt([in] LONG index, [in] VARIANT var);

  /**
   * \fn	HRESULT INktParam::ValueArray([in] LONG count, [out, retval] VARIANT *pVal);
   *
   * \brief	Reads an array parameter data.
   *
   * \param	count				Number of array elements.
   * \param [in,out]	pVal	Pointer to variant to receive array elements.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is null.
   * \return \c E_INVALIDARG if specified element count is invalid.
   */

  [propget, helpstring("Read  an array of data"),
   id(dispidNktParamValueArray)]
  HRESULT ValueArray([in] LONG count, [out, retval] VARIANT *pVal);

  /**
   * \fn	HRESULT INktParam::ValueArrayAt([in] LONG index, [in] LONG count, [out,	retval] VARIANT *pVal);
   *
   * \brief	Reads array parameter data at specified parameter index.
   *
   * \param	index				Zero-based parameter index.
   * \param	count				Number of array elements.
   * \param [in,out]	pVal	Pointer to variant to receive array elements.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is null.
   * \return \c E_INVALIDARG if specified element count and/or parameter index is invalid.
   */

  [propget, helpstring("Read/Write an array of data"),
   id(dispidNktParamValueArrayAt)]
  HRESULT ValueArrayAt([in] LONG index, [in] LONG count, [out, retval] VARIANT *pVal);

  /**
   * \fn	HRESULT INktParam::ReadString([out, retval] BSTR *pVal);
   *
   * \brief	Read an ANSI or Wide string from the parameter.
   *
   * \param [in,out]	pVal	Pointer to store the function name string.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if maxChars is invalid.
   * \return \c E_POINTER if provided string pointer is NULL.
   * \return \c E_OUTOFMEMORY  if provided string buffer has insufficient space.
   */

  [helpstring("Read an ansi or wide string from the parameter"),
   id(dispidNktParamReadString)]
  HRESULT ReadString([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktParam::ReadStringN([in] LONG maxChars, [out, retval] BSTR *pVal);
   *
   * \brief		Read an ANSI or Wide string from the parameter specifying a maximum number of characters.
   *
   * \param	maxChars			The character count to read.
   * \param [in,out]	pVal	Pointer to store the function name string.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if maxChars is invalid.
   * \return \c E_POINTER if provided string pointer is NULL.
   * \return \c E_OUTOFMEMORY  if provided string buffer has insufficient space.
   */

  [helpstring("Read an ANSI or Wide string from the parameter specifying a maximum number of characeters."),
   id(dispidNktParamReadStringN)]
  HRESULT ReadStringN([in] LONG maxChars, [out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktParam::WriteString([in] BSTR str, [in] VARIANT_BOOL isAnsi, [in,
   * 		defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL writeNul);
   *
   * \brief	Write a string as parameter value.
   *
   * \param	str			The string buffer.
   * \param	isAnsi  	\c VARIANT_TRUE if \c str points to an ANSI string.
   * \param	writeNul	\c Specify VARIANT_TRUE to write the NULL string terminator.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if maxChars is invalid.
   * \return \c E_POINTER if provided string pointer is NULL.
   * \return \c E_OUTOFMEMORY  if provided string buffer has insufficient space.
   */
  [helpstring("Write a string as parameter value."),
   id(dispidNktParamWriteString)]
  HRESULT WriteString([in] BSTR str, [in] VARIANT_BOOL isAnsi,
                      [in, defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL writeNul);

  /**
   * \fn	HRESULT INktParam::StringLength([out, retval] LONG *pVal);
   *
   * \brief	If the parameter refers to a string value, returns the string-length in characters.
   *
   * \param [in,out]	pVal	Pointer to receive the number of characters in string.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer value is NULL.
   * \return \c E_FAIL if the parameter type is non-string.
   */

  [helpstring("Get the length"),
   id(dispidNktParamStringLength)]
  HRESULT StringLength([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktParam::CharVal([out, retval] signed char *pVal);
   *
   * \brief	Read parameter as character value.
   *
   * \param [in,out]	pVal	Pointer to character to receive parameter value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed byte value"),
   id(dispidNktParamCharVal)]
  HRESULT CharVal([out, retval] signed char *pVal);

  /**
   * \fn	HRESULT INktParam::CharVal([in] signed char newValue);
   *
   * \brief	Write a signed byte  parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed byte value"),
   id(dispidNktParamCharVal)]
  HRESULT CharVal([in] signed char newValue);

  /**
   * \fn	HRESULT INktParam::ByteVal([out, retval] unsigned char *pVal);
   *
   * \brief	Read parameter as an unsigned byte value.
   *
   * \param [in,out]	pVal	Pointer to unsigned char to receive parameter value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned byte value"),
   id(dispidNktParamByteVal)]
  HRESULT ByteVal([out, retval] unsigned char *pVal);

  /**
   * \fn	HRESULT INktParam::ByteVal([in] unsigned char newValue);
   *
   * \brief	Write an unsigned byte parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned byte value"),
   id(dispidNktParamByteVal)]
  HRESULT ByteVal([in] unsigned char newValue);

  /**
   * \fn	HRESULT INktParam::ShortVal([out, retval] short *pVal);
   *
   * \brief	Read parameter as a signed word value.
   *
   * \param [in,out]	pVal	Pointer to short to receive parameter value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed word value"),
   id(dispidNktParamShortVal)]
  HRESULT ShortVal([out, retval] short *pVal);

  /**
   * \fn	HRESULT INktParam::ShortVal([in] short newValue);
   *
   * \brief	Write a signed word parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed word value"),
   id(dispidNktParamShortVal)]
  HRESULT ShortVal([in] short newValue);

  /**
   * \fn	HRESULT INktParam::UShortVal([out, retval] unsigned short *pVal);
   *
   * \brief	Read parameter as an unsigned word value.
   *
   * \param [in,out]	pVal	Pointer to <> to receive parameter value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned word value"),
   id(dispidNktParamUShortVal)]
  HRESULT UShortVal([out, retval] unsigned short *pVal);

  /**
   * \fn	HRESULT INktParam::UShortVal([in] unsigned short newValue);
   *
   * \brief	Write an unsigned word parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned word value"),
   id(dispidNktParamUShortVal)]
  HRESULT UShortVal([in] unsigned short newValue);

  /**
   * \fn	HRESULT INktParam::LongVal([out, retval] long *pVal);
   *
   * \brief	Read parameter as a signed doubleword value.
   *
   * \param [in,out]	pVal	Pointer to signed double-word to receive parameter value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed doubleword value"),
   id(dispidNktParamLongVal)]
  HRESULT LongVal([out, retval] long *pVal);

  /**
   * \fn	HRESULT INktParam::LongVal([in] long newValue);
   *
   * \brief	Write a signed doubleword parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed doubleword value"),
   id(dispidNktParamLongVal)]
  HRESULT LongVal([in] long newValue);

  /**
   * \fn	HRESULT INktParam::ULongVal([out, retval] unsigned long *pVal);
   *
   * \brief	Read parameter as an unsigned doubleword value.
   *
   * \param [in,out]	pVal	Pointer to unsigned doubleword to receive parameter value..
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned doubleword value"),
   id(dispidNktParamULongVal)]
  HRESULT ULongVal([out, retval] unsigned long *pVal);

  /**
   * \fn	HRESULT INktParam::ULongVal([in] unsigned long newValue);
   *
   * \brief	Write an unsigned doubleword parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned doubleword value"),
   id(dispidNktParamULongVal)]
  HRESULT ULongVal([in] unsigned long newValue);

  /**
   * \fn	HRESULT INktParam::LongLongVal([out, retval] __int64 *pVal);
   *
   * \brief	Read parameter as a signed quadword value.
   *
   * \param [in,out]	pVal	Pointer to quadword to receive parameter value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed quadword value"),
   id(dispidNktParamLongLongVal)]
  HRESULT LongLongVal([out, retval] __int64 *pVal);

  /**
   * \fn	HRESULT INktParam::LongLongVal([in] __int64 newValue);
   *
   * \brief	Write a signed quadword parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed quadword value"),
   id(dispidNktParamLongLongVal)]
  HRESULT LongLongVal([in] __int64 newValue);

  /**
   * \fn	HRESULT INktParam::ULongLongVal([out, retval] unsigned __int64 *pVal);
   *
   * \brief	Read parameter as an unsigned quadword value.
   *
   * \param [in,out]	pVal	Pointer to unsigned quadword to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned quadword value"),
   id(dispidNktParamULongLongVal)]
  HRESULT ULongLongVal([out, retval] unsigned __int64 *pVal);

  /**
   * \fn	HRESULT INktParam::ULongLongVal([in] unsigned __int64 newValue);
   *
   * \brief	Write an unsigned quadword parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned quadword value"),
   id(dispidNktParamULongLongVal)]
  HRESULT ULongLongVal([in] unsigned __int64 newValue);

  /**
   * \fn	HRESULT INktParam::SSizeTVal([out, retval] my_ssize_t *pVal);
   *
   * \brief	Read parameter as a signed integral sized value.
   *
   * \param [in,out]	pVal	Pointer to signed integral-sized variable to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed integral sized value"),
   id(dispidNktParamSSizeTVal)]
  HRESULT SSizeTVal([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktParam::SSizeTVal([in] my_ssize_t newValue);
   *
   * \brief	Write a signed integral-sized parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed integral sized value"),
   id(dispidNktParamSSizeTVal)]
  HRESULT SSizeTVal([in] my_ssize_t newValue);

  /**
   * \fn	HRESULT INktParam::SizeTVal([out, retval] my_size_t *pVal);
   *
   * \brief	Read parameter as an unsigned integral sized value.
   *
   * \param [in,out]	pVal	Pointer to unsigned integral-sized variable to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned integral sized value"),
   id(dispidNktParamSizeTVal)]
  HRESULT SizeTVal([out, retval] my_size_t *pVal);

  /**
   * \fn	HRESULT INktParam::SizeTVal([in] my_size_t newValue);
   *
   * \brief	Write an unsigned integral-sized parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned integral sized value"),
   id(dispidNktParamSizeTVal)]
  HRESULT SizeTVal([in] my_size_t newValue);

  /**
   * \fn	HRESULT INktParam::FloatVal([out, retval] float *pVal);
   *
   * \brief	Read parameter as a single precision floating point value.
   *
   * \param [in,out]	pVal	Pointer to single-precision floating point to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a single precision floating point value"),
   id(dispidNktParamFloatVal)]
  HRESULT FloatVal([out, retval] float *pVal);

  /**
   * \fn	HRESULT INktParam::FloatVal([in] float newValue);
   *
   * \brief	Write a single-precision floating point parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a single precision floating point value"),
   id(dispidNktParamFloatVal)]
  HRESULT FloatVal([in] float newValue);

  /**
   * \fn	HRESULT INktParam::DoubleVal([out, retval] double *pVal);
   *
   * \brief	Read parameter as a double precision floating point value.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a double precision floating point value"),
   id(dispidNktParamDoubleVal)]
  HRESULT DoubleVal([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktParam::DoubleVal([in] double newValue);
   *
   * \brief	Write a double-precision floating point parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a double precision floating point value"),
   id(dispidNktParamDoubleVal)]
  HRESULT DoubleVal([in] double newValue);

  /**
   * \fn	HRESULT INktParam::CharValAt([in] LONG index, [out, retval] signed char *pVal);
   *
   * \brief	Read parameter as a signed-byte value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to signed-byte to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed byte value at the specified index"),
   id(dispidNktParamCharValAt)]
  HRESULT CharValAt([in] LONG index, [out, retval] signed char *pVal);

  /**
   * \fn	HRESULT INktParam::CharValAt([in] LONG index, [in] signed char newValue);
   *
   * \brief	Write a signed byte value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed byte value at the specified index"),
   id(dispidNktParamCharValAt)]
  HRESULT CharValAt([in] LONG index, [in] signed char newValue);

  /**
   * \fn	HRESULT INktParam::ByteValAt([in] LONG index, [out, retval] unsigned char *pVal);
   *
   * \brief	Read parameter as a unsigned-char value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to unsigned-char to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned byte value at the specified index"),
   id(dispidNktParamByteValAt)]
  HRESULT ByteValAt([in] LONG index, [out, retval] unsigned char *pVal);

  /**
   * \fn	HRESULT INktParam::ByteValAt([in] LONG index, [in] unsigned char newValue);
   *
   * \brief	Write an unsigned-char  value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned byte value at the specified index"),
   id(dispidNktParamByteValAt)]
  HRESULT ByteValAt([in] LONG index, [in] unsigned char newValue);

  /**
   * \fn	HRESULT INktParam::ShortValAt([in] LONG index, [out, retval] short *pVal);
   *
   * \brief	Read parameter as a short value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to short to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed word value at the specified index"),
   id(dispidNktParamShortValAt)]
  HRESULT ShortValAt([in] LONG index, [out, retval] short *pVal);

  /**
   * \fn	HRESULT INktParam::ShortValAt([in] LONG index, [in] short newValue);
   *
   * \brief	Write a short value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed word value at the specified index"),
   id(dispidNktParamShortValAt)]
  HRESULT ShortValAt([in] LONG index, [in] short newValue);

  /**
   * \fn	HRESULT INktParam::UShortValAt([in] LONG index, [out, retval] unsigned short *pVal);
   *
   * \brief	Read parameter as an unsigned-short value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to unsigned short to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned word value at the specified index"),
   id(dispidNktParamUShortValAt)]
  HRESULT UShortValAt([in] LONG index, [out, retval] unsigned short *pVal);

  /**
   * \fn	HRESULT INktParam::UShortValAt([in] LONG index, [in] unsigned short newValue);
   *
   * \brief	Write an unsigned-short value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned word value at the specified index"),
   id(dispidNktParamUShortValAt)]
  HRESULT UShortValAt([in] LONG index, [in] unsigned short newValue);

  /**
   * \fn	HRESULT INktParam::LongValAt([in] LONG index, [out, retval] long *pVal);
   *
   * \brief	Read parameter as a signed double-word value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to signed double-word to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed doubleword value at the specified index"),
   id(dispidNktParamLongValAt)]
  HRESULT LongValAt([in] LONG index, [out, retval] long *pVal);

  /**
   * \fn	HRESULT INktParam::LongValAt([in] LONG index, [in] long newValue);
   *
   * \brief	Write a signed double-word value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed doubleword value at the specified index"),
   id(dispidNktParamLongValAt)]
  HRESULT LongValAt([in] LONG index, [in] long newValue);

  /**
   * \fn	HRESULT INktParam::ULongValAt([in] LONG index, [out, retval] unsigned long *pVal);
   *
   * \brief	Read parameter as an unsigned double-word value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to unsigned double-word to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned doubleword value at the specified index"),
   id(dispidNktParamULongValAt)]
  HRESULT ULongValAt([in] LONG index, [out, retval] unsigned long *pVal);

  /**
   * \fn	HRESULT INktParam::ULongValAt([in] LONG index, [in] unsigned long newValue);
   *
   * \brief	Write a unsigned double-word value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned doubleword value at the specified index"),
   id(dispidNktParamULongValAt)]
  HRESULT ULongValAt([in] LONG index, [in] unsigned long newValue);

  /**
   * \fn	HRESULT INktParam::LongLongValAt([in] LONG index, [out, retval] __int64 *pVal);
   *
   * \brief	Read parameter as a signed quadword value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to  signed quadword to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed quadword value at the specified index"),
   id(dispidNktParamLongLongValAt)]
  HRESULT LongLongValAt([in] LONG index, [out, retval] __int64 *pVal);

  /**
   * \fn	HRESULT INktParam::LongLongValAt([in] LONG index, [in] __int64 newValue);
   *
   * \brief	Write a  signed quadword value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed quadword value at the specified index"),
   id(dispidNktParamLongLongValAt)]
  HRESULT LongLongValAt([in] LONG index, [in] __int64 newValue);

  /**
   * \fn	HRESULT INktParam::ULongLongValAt([in] LONG index, [out,
   * 		retval] unsigned __int64 *pVal);
   *
   * \brief	Read parameter as a unsigned quadword value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to <> to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned quadword value at the specified index"),
   id(dispidNktParamULongLongValAt)]
  HRESULT ULongLongValAt([in] LONG index, [out, retval] unsigned __int64 *pVal);

  /**
   * \fn	HRESULT INktParam::ULongLongValAt([in] LONG index, [in] unsigned __int64 newValue);
   *
   * \brief	Write a unsigned quadword value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned quadword value at the specified index"),
   id(dispidNktParamULongLongValAt)]
  HRESULT ULongLongValAt([in] LONG index, [in] unsigned __int64 newValue);

  /**
   * \fn	HRESULT INktParam::SSizeTValAt([in] LONG index, [out, retval] my_ssize_t *pVal);
   *
   * \brief	Read parameter as a signed integral-sized value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to signed integral-sized to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a signed integral sized value at the specified index"),
   id(dispidNktParamSSizeTValAt)]
  HRESULT SSizeTValAt([in] LONG index, [out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktParam::SSizeTValAt([in] LONG index, [in] my_ssize_t newValue);
   *
   * \brief	Write a signed integral-sized value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed integral sized value at the specified index"),
   id(dispidNktParamSSizeTValAt)]
  HRESULT SSizeTValAt([in] LONG index, [in] my_ssize_t newValue);

  /**
   * \fn	HRESULT INktParam::SizeTValAt([in] LONG index, [out, retval] my_size_t *pVal);
   *
   * \brief	Read parameter as an unsigned integral-sized value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to unsigned integral-sized variable to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write an unsigned integral sized value at the specified index"),
   id(dispidNktParamSizeTValAt)]
  HRESULT SizeTValAt([in] LONG index, [out, retval] my_size_t *pVal);

  /**
   * \fn	HRESULT INktParam::SizeTValAt([in] LONG index, [in] my_size_t newValue);
   *
   * \brief	Write a unsigned integral-sized value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned integral sized value at the specified index"),
   id(dispidNktParamSizeTValAt)]
  HRESULT SizeTValAt([in] LONG index, [in] my_size_t newValue);

  /**
   * \fn	HRESULT INktParam::FloatValAt([in] LONG index, [out, retval] float *pVal);
   *
   * \brief	Read parameter as a single-precision floating point value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to single-precision floating point to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a single precision floating point value at the specified index"),
   id(dispidNktParamFloatValAt)]
  HRESULT FloatValAt([in] LONG index, [out, retval] float *pVal);

  /**
   * \fn	HRESULT INktParam::FloatValAt([in] LONG index, [in] float newValue);
   *
   * \brief	Write a single-precision floating point value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a single precision floating point value at the specified index"),
   id(dispidNktParamFloatValAt)]
  HRESULT FloatValAt([in] LONG index, [in] float newValue);

  /**
   * \fn	HRESULT INktParam::DoubleValAt([in] LONG index, [out, retval] double *pVal);
   *
   * \brief	Read parameter as a double-precision floating point value from the specified array index.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to double-precision floating point to receive parameter value.
   *
   * \return S_OK on success.
   * \return E_POINTER of pVal pointer value is NULL.
   * \return E_INVALIDARG if specified index is invalid.
   * \return E_FAIL on general error.   
   */

  [propget, helpstring("Read/Write a double precision floating point value at the specified index"),
   id(dispidNktParamDoubleValAt)]
  HRESULT DoubleValAt([in] LONG index, [out, retval] double *pVal);

  /**
   * \fn	HRESULT INktParam::DoubleValAt([in] LONG index, [in] double newValue);
   *
   * \brief	Write a double-precision floating point value at the specified array index.
   *
   * \param	index   	Zero-based index.
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a double precision floating point value at the specified index"),
   id(dispidNktParamDoubleValAt)]
  HRESULT DoubleValAt([in] LONG index, [in] double newValue);

  /**
   * \fn	HRESULT INktParam::PointerVal([out, retval] my_ssize_t *pVal);
   *
   * \brief	Read parameter as a signed pointer-sized integral value.
   *
   * \param [in,out]	pVal	Pointer to signed, pointer-sized integral variable to receive parameter value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get/Set the pointer value of this parameter"),
   id(dispidNktParamPointerVal)]
  HRESULT PointerVal([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktParam::PointerVal([in] my_ssize_t newValue);
   *
   * \brief	Write a signed pointer-sized integral parameter value.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Get/Set the pointer value of this parameter"),
   id(dispidNktParamPointerVal)]
  HRESULT PointerVal([in] my_ssize_t newValue);

  /**
   * \fn	HRESULT INktParam::IsNullPointer([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if the parameter is a null-pointer.
   *
   * \param [in,out]	pVal	Pointer to receive boolean value.
   *
   * \return S_OK on success.
   * \return E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Check if the param is a pointer to a null address"),
   id(dispidNktParamIsNullPointer)]
  HRESULT IsNullPointer([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktParam::Memory([out, retval] INktProcessMemory **ppProcMem);
   *
   * \brief	Get a INktProcessMemory interface providing access to process memory.
   *
   * \param [in,out]	ppProcMem	Address of pointer to receive the requested interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProcMem is \c NULL.   
   */

  [helpstring("Get a INktProcessMemory interface to access process memory"),
   id(dispidNktParamMemory)]
  HRESULT Memory([out, retval] INktProcessMemory **ppProcMem);

  /**
   * \fn	HRESULT INktParam::CastTo([in] BSTR newType, [out, retval] INktParam **ppParam);
   *
   * \brief	Do a static cast of the parameter into a new type.
   *
   * \param	newType		Name of the target type.
   * \param [in,out]	ppParam	Address of pointer to receive a interface for the newly-typed parameter.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_INVALIDARG if provided string is empty.
   * \return \c NKT_DVERR_NotFound if the specified type cannot be found in the Deviare database.
   * \return \c E_OUTOFMEMORY if the new parameter could not be created due to memory error.      
   */

  [helpstring("Do a static cast of the parameter into a new type"),
   id(dispidNktParamCastTo)]
  HRESULT CastTo([in] BSTR newType, [out, retval] INktParam **ppParam);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktParamsEnum
 *
 * \brief	Exposes methods for enumerating a INktParamsEnum collection.
 *
 * 
 * 
 */

[
  object,
  uuid(718E4DBC-DFC2-4fa8-BFE6-0A8192CEEF5D),
  dual, local,
  nonextensible,
  helpstring("INktParamsEnum Interface"),
  pointer_default(unique)
]
interface INktParamsEnum : INktObject
{
  /**
   * \fn	HRESULT INktParamsEnum::Count([out, retval] LONG *pVal);
   *
   * \brief	Get the total item count in this collection".
   *
   * \param [in,out]	pVal	Pointer to store the item count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the total items count in this collection"),
   id(dispidNktParamsEnumCount)]
  HRESULT Count([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktParamsEnum::GetAt([in] LONG index, [out, retval] INktParam **ppParam);
   *
   * \brief	Retrieves the item at the specified index.
   *
   * \param	index			   	Zero-based index.
   * \param [in,out]	ppParam	Pointer to address to store the retrieved item interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_INVALIDARG if index parameter is out of bounds.
   */

  [helpstring("Retrieves the item at the specified index"),
   id(dispidNktParamsEnumGetAt)]
  HRESULT GetAt([in] LONG index, [out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParamsEnum::First([out, retval] INktParam **ppParam);
   *
   * \brief	Retrieves the first item in the collection.
   *
   * \param [in,out]	ppParam	Address of pointer to receive INktParam interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the first item in the collection"),
   id(dispidNktParamsEnumFirst)]
  HRESULT First([out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParamsEnum::Last([out, retval] INktParam **ppParam);
   *
   * \brief	Retrieves the last item in the collection.
   *
   * \param [in,out]	ppParam	Address of pointer to receive INktParam interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the last item in the collection"),
   id(dispidNktParamsEnumLast)]
  HRESULT Last([out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParamsEnum::Next([out, retval] INktParam **ppParam);
   *
   * \brief	Retrieves the next item in the collection.
   *
   * \param [in,out]	ppParam	Address of pointer to receive INktParam interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the next item in the collection"),
   id(dispidNktParamsEnumNext)]
  HRESULT Next([out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParamsEnum::Previous([out, retval] INktParam **ppParam);
   *
   * \brief	Retrieves the previous item in the collection.
   *
   * \param [in,out]	ppParam	Address of pointer to receive INktParam interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the previous item in the collection"),
   id(dispidNktParamsEnumPrevious)]
  HRESULT Previous([out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParamsEnum::GetByDeviareId([in] my_ssize_t devId, [out,
   * 		retval] INktParam **ppParam);
   *
   * \brief	Find an item by its deviare id.
   *
  * \param	devId			  	Deviare object identifier.
   * \param [in,out]	ppParam	Address of pointer to receive INktParam interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_INVALIDARG if devId is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppParam is set to NULL).
   */

  [helpstring("Find an item by its deviare id"),
   id(dispidNktParamsEnumGetByDeviareId)]
  HRESULT GetByDeviareId([in] my_ssize_t devId, [out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktParamsEnum::_NewEnum([out, retval] IUnknown** ppUnk);
   *
   * \brief	Retrieves an enumerable collection object.
   *
    * \param [out, retval]	ppUnk	Address of an interface pointer that on return points to the IUnknown interface of an enumerator
   object.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if ppUnk is NULL.
   * \return \c E_FAIL on general failure.
   *
   * \return \c S_OK on success or \c E_FAIL
   */

  [propget, helpstring("Retrieves an enumerable collection object"),
   id(DISPID_NEWENUM), restricted]
  HRESULT _NewEnum([out, retval] IUnknown** ppUnk);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktHookCallInfo
 *
 * \brief	Exposes methods for accessing hooked function call information.
 *
 * 
 * 
 */

[
  object,
  uuid(1A2D8AE6-6CF9-49db-880D-A806D559EE20),
  dual, local,
  nonextensible,
  helpstring("INktHookCallInfo Interface"),
  pointer_default(unique)
]
interface INktHookCallInfo : INktObject
{
  /**
   * \fn	HRESULT INktHookCallInfo::IsPreCall([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Indicates if this is the pre-call stage of the hooked function.
   *
   * \param [in,out]	pVal	Pointer to receive boolean value.
   *
   * \return \c S_OK on success, or \c  E_FAIL on general error.
   */

  [propget, helpstring("Indicates if this is the pre-call stage of the hooked function."),
   id(dispidNktHookCallInfoIsPreCall)]
  HRESULT IsPreCall([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::Cookie([out, retval] LONG *pVal);
   *
   * \brief	Get the cookie of this call.
   *
   * \param [in,out]	pVal	Pointer to long variable to store to cookie.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the cookie of this call"),
   id(dispidNktHookCallInfoCookie)]
  HRESULT Cookie([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::LastError([out, retval] LONG *pVal);
   *
   * \brief	Get the operating system last error code of the calling thread. 
   *
   * \param [in,out]	pVal	Pointer to receive the error code.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   *
   * \remarks * 0 (zero) indicates successful operation.
   * \remarks * To convert the error code to a readable string, check \c FormatMessage API function on MSDN. 
   * \remarks * To convert a system error into an \c HRESULT value, use the \c HRESULT_FROM_WIN32 macro.
   */

  [propget, helpstring("Get/Set the operating system last error code of the calling thread"),
   id(dispidNktHookCallInfoLastError)]
  HRESULT LastError([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::LastError([in] LONG newValue);
   *
   * \brief	Set the operating system last error code of the calling thread.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success, or \c  E_FAIL on general error.
   * \remark * 0 (zero) indicates successful operation.
   */

  [propput, helpstring("Get/Set the operating system last error code of the calling thread"),
   id(dispidNktHookCallInfoLastError)]
  HRESULT LastError([in] LONG newValue);

  /**
   * \fn	HRESULT INktHookCallInfo::CurrentTimeMs([out, retval] double *pVal);
   *
   * \brief	Get the actual time when the function was called in milliseconds since system startup.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the actual time when the function was called in milliseconds"),
   id(dispidNktHookCallInfoCurrentTimeMs)]
  HRESULT CurrentTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::ElapsedTimeMs([out, retval] double *pVal);
   *
   * \brief	Get the elapsed time of the function in milliseconds.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the elapsed time of the function in milliseconds"),
   id(dispidNktHookCallInfoElapsedTimeMs)]
  HRESULT ElapsedTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::ChildsElapsedTimeMs([out, retval] double *pVal);
   *
   * \brief	Get the elapsed time of the function including its hooked children in milliseconds.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the elapsed time of the function including its hooked children in milliseconds"),
   id(dispidNktHookCallInfoChildsElapsedTimeMs)]
  HRESULT ChildsElapsedTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::KernelModeTimeMs([out, retval] double *pVal);
   *
   * \brief	Get the running time of the current thread in kernel mode in milliseconds.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the running time of the current thread in kernel mode in milliseconds."),
   id(dispidNktHookCallInfoKernelModeTimeMs)]
  HRESULT KernelModeTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::UserModeTimeMs([out, retval] double *pVal);
   *
   * \brief	Get the running time of the current thread in user mode in milliseconds.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the running time of the current thread in user mode in milliseconds."),
   id(dispidNktHookCallInfoUserModeTimeMs)]
  HRESULT UserModeTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::CpuClockCycles([out, retval] unsigned __int64 *pVal);
   *
   * \brief	Get the executed CPU clock-cycle count in the current thread.
   *
   * \param [in,out]	pVal	Pointer to unsigned 64-bit integer to receive clock cycle count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the executed CPU clock-cycle count in the current thread."),
   id(dispidNktHookCallInfoCpuClockCycles)]
  HRESULT CpuClockCycles([out, retval] unsigned __int64 *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::Hook([out, retval] INktHook **ppHook);
   *
   * \brief	Get the hook associated with the call.
   *
   * \param [in,out]	ppHook	Pointer to address to receive the INktHook interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppHook is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the hook associated with the call"),
   id(dispidNktHookCallInfoHook)]
  HRESULT Hook([out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktHookCallInfo::Process([out, retval] INktProcess **ppProc);
   *
   * \brief	Get the process of the call.
   *
   * \param [in,out]	ppProc	Pointer to address to receive the INktProcess interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppProc is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the process of the call"),
   id(dispidNktHookCallInfoProcess)]
  HRESULT Process([out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktHookCallInfo::ThreadId([out, retval] LONG *pVal);
   *
   * \brief	Get the thread id of the call.
   *
   * \param [in,out]	pVal	Pointer to long to receive the thread identifier.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the thread id of the call"),
   id(dispidNktHookCallInfoThreadId)]
  HRESULT ThreadId([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::ChainDepth([out, retval] LONG *pVal);
   *
   * \brief	Get the hook call chain depth in the current thread.
   *
   * \param [in,out]	pVal	Pointer to long to receive the chain depth.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the hook call chain depth in the current thread"),
   id(dispidNktHookCallInfoCallDepth)]
  HRESULT ChainDepth([out, retval] LONG *pVal);
  
  /**
   * \fn	HRESULT INktHookCallInfo::StackTrace([out, retval] INktStackTrace **ppStackTrace);
   *
   * \brief	Get the stack trace of the call.
   *
   * \param [in,out]	ppStackTrace	Pointer to address to receive the INktStackTrace interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppStackTrace is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the stack trace of the call"),
   id(dispidNktHookCallInfoStackTrace)]
  HRESULT StackTrace([out, retval] INktStackTrace **ppStackTrace);

  /**
   * \fn	HRESULT INktHookCallInfo::Params([out, retval] INktParamsEnum **ppParamsEnum);
   *
   * \brief	Get the parameters of the call.
   *
   * \param [in,out]	ppParamsEnum	Pointer to address to receive the parameter enumerator interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParamsEnum is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the parameters of the call"),
   id(dispidNktHookCallInfoParams)]
  HRESULT Params([out, retval] INktParamsEnum **ppParamsEnum);

  /**
   * \fn	HRESULT INktHookCallInfo::Result([out, retval] INktParam **ppParam);
   *
   * \brief	Get the result value of the call.
   *
   * \param [in,out]	ppParam	Pointer to address to receive the INktParam parameter interface representing the result value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the result of the call"),
   id(dispidNktHookCallInfoResult)]
  HRESULT Result([out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktHookCallInfo::CustomParams([out, retval] INktParamsEnum **ppParamsEnum);
   *
   * \brief	Get the custom parameters of the call.
   *
   * \param [in,out]	ppParamsEnum	Pointer to address to receive the parameter enumerator interface.
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParamsEnum is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the custom parameters of the call"),
   id(dispidNktHookCallInfoCustomParams)]
  HRESULT CustomParams([out, retval] INktParamsEnum **ppParamsEnum);

  /**
   * \fn	HRESULT INktHookCallInfo::Register([in] eNktRegister asmReg, [out,
   * 		retval] my_ssize_t *pVal);
   *
   * \brief	Get a CPU register value.
   *
   * \param	asmReg				eNktRegister enumeration member representing the CPU register to retrieve.
   * \param [in,out]	pVal	A pointer to a register-sized variable to receive the register value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get assembler register value"),
   id(dispidNktHookCallInfoRegister)]
  HRESULT Register([in] eNktRegister asmReg, [out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::Register([in] eNktRegister asmReg, [in] my_ssize_t newValue);
   *
   * \brief	Set CPU register value.
   *
   * \param	asmReg  	eNktRegister enumeration member representing the CPU register to modify.
   * \param	newValue	The new register value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Get/Set assembler register value"),
   id(dispidNktHookCallInfoRegister)]
  HRESULT Register([in] eNktRegister asmReg, [in] my_ssize_t newValue);

  /**
   * \fn	HRESULT INktHookCallInfo::FloatingRegister([in] eNktRegister asmReg, [out,
   * 		retval] double *pVal);
   *
   * \brief	Get floating-point CPU register value.
   *
   * \param	asmReg				The asm register.
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get/Set assembler register value"),
   id(dispidNktHookCallInfoFloatingRegister)]
  HRESULT FloatingRegister([in] eNktRegister asmReg, [out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfo::FloatingRegister([in] eNktRegister asmReg,
   * 		[in] double newValue);
   *
   * \brief	Set floating-point CPU register value.
   *
   * \param	asmReg  	The asm register.
   * \param	newValue	The new value.
   *
   * \return S_OK or E_FAIL.
   */

  [propput, helpstring("Get/Set assembler register value"),
   id(dispidNktHookCallInfoFloatingRegister)]
  HRESULT FloatingRegister([in] eNktRegister asmReg, [in] double newValue);

  /**
   * \fn	HRESULT INktHookCallInfo::SkipCall();
   *
   * \brief	Skip calling the original function.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Skip calling the original function"),
   id(dispidNktHookCallInfoSkipCall)]
  HRESULT SkipCall();
  
  /**
  * \fn ReadIntercallData([in] my_ssize_t destAddr, [in] my_ssize_t offset, [in] my_ssize_t bytes);
  *
  * \brief Retrieves user-defined data that is maintained between pre and post call stages. Use WriteIntercallData to store this data.
  * \sa WriteIntercallData
  *
  * \param destAddr Pointer-sized variable indicating address to store retrieved data.
  * \param offset   Offset in the internal buffer to begin read.
  * \param bytes	Number of bytes to read.
  *
  * \remarks Number of bytes cannot exceed 128.
  *  
  * \return S_OK on success.
  * \return E_INVALIDARG if byte count and/or offset are invalid; or the requested byte count exceeds internal buffer size (128 bytes).
  * \return E_POINTER if destination address is NULL.
  * \return E_FAIL if general failure.
  *
  * 
  */
  [helpstring("Retrieves data that is maintained between pre and post call"),
   id(dispidNktHookCallInfoReadIntercallData)]
  HRESULT ReadIntercallData([in] my_ssize_t destAddr, [in] my_ssize_t offset, [in] my_ssize_t bytes);
  
  /**
  * \fn WriteIntercallData([in] my_ssize_t destAddr, [in] my_ssize_t offset, [in] my_ssize_t bytes);
  *
  * \brief Stores user-defined data that is maintained between pre and post call stages. Use ReadIntercallData to read this data.
  * \sa ReadIntercallData
  *
  * \param destAddr Pointer-sized variable indicating address containing data to store.
  * \param offset   Offset in the internal buffer to begin write.
  * \param bytes	Number of bytes to write.
  *
  * \remarks Number of bytes cannot exceed 128.
  *  
  * \return S_OK on success.
  * \return E_INVALIDARG if byte count and/or offset are invalid; or the requested byte count exceeds internal buffer size (128 bytes).
  * \return E_POINTER if source address is NULL.
  * \return E_FAIL if general failure.
  *
  * 
  */
  [helpstring("Stores data that will be maintained between pre and post call"),
   id(dispidNktHookCallInfoWriteIntercallData)]
  HRESULT WriteIntercallData([in] my_ssize_t srcAddr, [in] my_ssize_t offset, [in] my_ssize_t bytes);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktProcessMemory
 *
 * \brief	Exposes methods for accessing process memory.
 *
 * 
 * 
 */

[
  object,
  uuid(ACE2F499-AA1C-4b36-912F-189F8F8B6765),
  dual, local,
  nonextensible,
  helpstring("INktProcessMemory Interface"),
  pointer_default(unique)
]
interface INktProcessMemory : INktObject
{
  /**
   * \fn	HRESULT INktProcessMemory::GetProtection([in] my_ssize_t remoteAddr, [in,
   * 		defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL allocated, [out, retval] eNktProtection *pVal);
   *
   * \brief	Get the protection flags of a remote address.
   *
   * \param	remoteAddr			The remote address to query.
   * \param	allocated			If \c TRUE, the returned flags will match the protection flags when the memory region was initially allocated; otherwise, the current flags will be returned.
   * \param [in,out]	pVal	Pointer to a variable of type eNktProtection to receive protection flags.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed.   
   */

  [helpstring("Get the protection flags of a remote address"),
   id(dispidNktProcessMemoryGetProtection)]
  HRESULT GetProtection([in] my_ssize_t remoteAddr,
                        [in, defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL allocated,
                        [out, retval] eNktProtection *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::ReadMem([in] my_ssize_t localAddr,
   * 		[in] my_ssize_t remoteAddr, [in] my_ssize_t bytes, [out, retval] my_ssize_t *pReaded);
   *
   * \brief	Read a bulk of bytes from the remote process.
   *
   * \param	localAddr		   	The local address.
   * \param	remoteAddr		   	The remote address.
   * \param	bytes			   	The number of bytes to read from the remote process.
   * \param [in,out]	pReaded	A pointer to receive the requested bytes. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed.
   * \return \c NKT_DVERR_PartialCopy Not all the requested bytes could be read.
   * \return \c E_FAIL A general has occurred.
   */

  [helpstring("Read a bulk of bytes from the remote process"),
   id(dispidNktProcessMemoryReadMem)]
  HRESULT ReadMem([in] my_ssize_t localAddr, [in] my_ssize_t remoteAddr, [in] my_ssize_t bytes,
                  [out, retval] my_ssize_t *pReaded);

  /**
   * \fn	HRESULT INktProcessMemory::WriteMem([in] my_ssize_t remoteAddr,
   * 		[in] my_ssize_t localAddr, [in] my_ssize_t bytes, [out, retval] my_ssize_t *pWritten);
   *
   * \brief	Write a bulk of bytes in the remote process.
   *
   * \param	remoteAddr				The remote address.
   * \param	localAddr				The local address.
   * \param	bytes					The number of bytes to write to the remote process.
   * \param [in,out]	pWritten	A pointer to the data to write.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed.
   * \return \c NKT_DVERR_PartialCopy Not all the requested bytes could be written.
   * \return \c E_FAIL A general error has occurred.
   */

  [helpstring("Write a bulk of bytes in the remote process"),
   id(dispidNktProcessMemoryWriteMem)]
  HRESULT WriteMem([in] my_ssize_t remoteAddr, [in] my_ssize_t localAddr, [in] my_ssize_t bytes,
                   [out, retval] my_ssize_t *pWritten);

  /**
   * \fn	HRESULT INktProcessMemory::Read([in] my_ssize_t remoteAddr,
   * 		[in] eNktDboFundamentalType type, [out, retval] VARIANT *pVal);
   *
   * \brief	Read data from the remote process.
   *
   * \param	remoteAddr			The remote address.
   * \param	type				The type of the data to be read (member of eNktDboFundamentalType enumeration).
   * \param [in,out]	pVal	A pointer to a variant to receive the requested data.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed.
   * \return \c E_FAIL A general error has occurred.
   */

  [helpstring("Read data from the remote process"),
   id(dispidNktProcessMemoryRead)]
  HRESULT Read([in] my_ssize_t remoteAddr, [in] eNktDboFundamentalType type, [out, retval] VARIANT *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::ReadArray([in] my_ssize_t remoteAddr,
   * 		[in] eNktDboFundamentalType type, [in] LONG count, [out, retval] VARIANT *pVal);
   *
   * \brief	Read an array of data from the remote process.
   *
   * \param	remoteAddr			The remote address.
   * \param	type				The type of the array elements to be read (member of eNktDboFundamentalType enumeration).
   * \param	count				The number of elements to read.
   * \param [in,out]	pVal	A pointer to a variant to receive the requested array.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed.
   * \return \c E_INVALIDARG if count parameter is invalid.
   * \return \c E_FAIL A general error has occurred.   
   */

  [helpstring("Read an array of data from the remote process"),
   id(dispidNktProcessMemoryReadArray)]
  HRESULT ReadArray([in] my_ssize_t remoteAddr, [in] eNktDboFundamentalType type, [in] LONG count,
                    [out, retval] VARIANT *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::Write([in] my_ssize_t remoteAddr, [in] VARIANT var);
   *
   * \brief	Write data or array of data in the remote process.
   *
   * \param	remoteAddr	The remote address.
   * \param	var		  	The variant to write.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed.   
   * \return \c NKT_DVERR_PartialCopy Not all the requested bytes could be written.
   * \return \c E_FAIL A general error has occurred.   
   */

  [helpstring("Write data or array of data in the remote process"),
   id(dispidNktProcessMemoryWrite)]
  HRESULT Write([in] my_ssize_t remoteAddr, [in] VARIANT var);

  /**
   * \fn	HRESULT INktProcessMemory::ReadString([in] my_ssize_t remoteAddr,
   * 		[in] VARIANT_BOOL isAnsi, [out, retval] BSTR *pVal);
   *
   * \brief	Read an ANSI or Wide string from the remote process. 
   *
   * \param	remoteAddr			The remote address to read.
   * \param	isAnsi				\c TRUE if string is to be read as ANSI; Unicode otherwise.
   * \param [in,out]	pVal	Pointer to store the read string.
   *
   * \remarks The function assumes the target string is NULL terminated. 
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed.   
   * \return \c E_OUTOFMEMORY  if provided string buffer has insufficient space.
   * \return \c E_FAIL A general error has occurred. 
   */

  [helpstring("Read an ansi/wide string from the remote process"),
   id(dispidNktProcessMemoryReadString)]
  HRESULT ReadString([in] my_ssize_t remoteAddr, [in] VARIANT_BOOL isAnsi, [out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::ReadStringN([in] my_ssize_t remoteAddr,
   * 		[in] VARIANT_BOOL isAnsi, [in] LONG maxChars, [out, retval] BSTR *pVal);
   *
   * \brief	Read an ANSI or Wide string from the remote process and specifying a maximum number of chars.
   *
   * \param	remoteAddr			The remote address.
   * \param	isAnsi				\c TRUE if string is to be read as ANSI; Unicode otherwise.
   * \param	maxChars			The character count to read.
   * \param [in,out]	pVal	Pointer to store the read string.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if maxChars is invalid.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed.   
   * \return \c E_OUTOFMEMORY  if provided string buffer has insufficient space.
   * \return \c E_FAIL A general error has occurred. 
   */

  [helpstring("Read an ansi/wide string from the remote process and specify the maximum number of chars"),
   id(dispidNktProcessMemoryReadStringN)]
  HRESULT ReadStringN([in] my_ssize_t remoteAddr, [in] VARIANT_BOOL isAnsi, [in] LONG maxChars,
                      [out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::WriteString([in] my_ssize_t remoteAddr, [in] BSTR str,
   * 		[in] VARIANT_BOOL asAnsi, [in, defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL writeNul);
   *
   * \brief	Write a string in the remote process.
   *
   * \param	remoteAddr	The remote address.
   * \param	str		  	The string to write.
   * \param	asAnsi	  	\c VARIANT_TRUE if \c str points to an ANSI string.
   * \param	writeNul  	\c Specify VARIANT_TRUE to write the NULL string terminator.
   *  
   * \return \c S_OK on success.
   * \return \c E_POINTER if provided string pointer is NULL.      
   * \return \c E_ACCESSDENIED if the specified address could not be accessed.      
   * \return \c E_FAIL A general error has occurred.    
   */

  [helpstring("Write an ansi/wide string in the remote process"),
   id(dispidNktProcessMemoryWriteString)]
  HRESULT WriteString([in] my_ssize_t remoteAddr, [in] BSTR str, [in] VARIANT_BOOL asAnsi,
                      [in, defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL writeNul);

  /**
   * \fn	HRESULT INktProcessMemory::StringLength([in] my_ssize_t remoteAddr,
   * 		[in] VARIANT_BOOL asAnsi, [out, retval] LONG *pVal);
   *
   * \brief	Get the length in characters of an ansi/wide string in the remote process.
   *
   * \param	remoteAddr			The remote address.
   * \param	asAnsi				\c TRUE if string is to be read as ANSI; Unicode otherwise.
   * \param [in,out]	pVal	Pointer to receive the number of characters in string.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer value is NULL.
   * \return \c E_FAIL if the parameter type is non-string.
   */

  [helpstring("Get the length in characters of an ansi/wide string in the remote process"),
   id(dispidNktProcessMemoryStringLength)]
  HRESULT StringLength([in] my_ssize_t remoteAddr, [in] VARIANT_BOOL asAnsi,
                       [out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::CharVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] signed char *pVal);
   *
   * \brief	Read a signed byte value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write a signed byte value from the specified remote address"),
   id(dispidNktProcessMemoryCharVal)]
  HRESULT CharVal([in] my_ssize_t remoteAddr, [out, retval] signed char *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::CharVal([in] my_ssize_t remoteAddr,
   * 		[in] signed char newValue);
   *
   * \brief Write a signed byte value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed byte value to the specified remote address"),
   id(dispidNktProcessMemoryCharVal)]
  HRESULT CharVal([in] my_ssize_t remoteAddr, [in] signed char newValue);

  /**
   * \fn	HRESULT INktProcessMemory::ByteVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] unsigned char *pVal);
   *
   * \brief	Read an unsigned byte value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write an unsigned byte value from the specified remote address"),
   id(dispidNktProcessMemoryByteVal)]
  HRESULT ByteVal([in] my_ssize_t remoteAddr, [out, retval] unsigned char *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::ByteVal([in] my_ssize_t remoteAddr,
   * 		[in] unsigned char newValue);
   *
   * \brief	Write an unsigned byte value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned byte value to the specified remote address"),
   id(dispidNktProcessMemoryByteVal)]
  HRESULT ByteVal([in] my_ssize_t remoteAddr, [in] unsigned char newValue);

  /**
   * \fn	HRESULT INktProcessMemory::ShortVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] short *pVal);
   *
   * \brief	Read a signed word value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write a signed word value from the specified remote address"),
   id(dispidNktProcessMemoryShortVal)]
  HRESULT ShortVal([in] my_ssize_t remoteAddr, [out, retval] short *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::ShortVal([in] my_ssize_t remoteAddr, [in] short newValue);
   *
   * \brief	Write a signed word value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed word value to the specified remote address"),
   id(dispidNktProcessMemoryShortVal)]
  HRESULT ShortVal([in] my_ssize_t remoteAddr, [in] short newValue);

  /**
   * \fn	HRESULT INktProcessMemory::UShortVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] unsigned short *pVal);
   *
   * \brief	Read an unsigned word value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write an unsigned word value from the specified remote address"),
   id(dispidNktProcessMemoryUShortVal)]
  HRESULT UShortVal([in] my_ssize_t remoteAddr, [out, retval] unsigned short *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::UShortVal([in] my_ssize_t remoteAddr,
   * 		[in] unsigned short newValue);
   *
   * \brief	Write an unsigned word value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned word value to the specified remote address"),
   id(dispidNktProcessMemoryUShortVal)]
  HRESULT UShortVal([in] my_ssize_t remoteAddr, [in] unsigned short newValue);

  /**
   * \fn	HRESULT INktProcessMemory::LongVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] long *pVal);
   *
   * \brief	Read a signed doubleword value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write a signed doubleword value from the specified remote address"),
   id(dispidNktProcessMemoryLongVal)]
  HRESULT LongVal([in] my_ssize_t remoteAddr, [out, retval] long *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::LongVal([in] my_ssize_t remoteAddr, [in] long newValue);
   *
   * \brief	Write a signed doubleword value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed doubleword value to the specified remote address"),
   id(dispidNktProcessMemoryLongVal)]
  HRESULT LongVal([in] my_ssize_t remoteAddr, [in] long newValue);

  /**
   * \fn	HRESULT INktProcessMemory::ULongVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] unsigned long *pVal);
   *
   * \brief	Read an unsigned doubleword value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write an unsigned doubleword value from the specified remote address"),
   id(dispidNktProcessMemoryULongVal)]
  HRESULT ULongVal([in] my_ssize_t remoteAddr, [out, retval] unsigned long *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::ULongVal([in] my_ssize_t remoteAddr,
   * 		[in] unsigned long newValue);
   *
   * \brief	Write an unsigned doubleword value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned doubleword value to the specified remote address"),
   id(dispidNktProcessMemoryULongVal)]
  HRESULT ULongVal([in] my_ssize_t remoteAddr, [in] unsigned long newValue);

  /**
   * \fn	HRESULT INktProcessMemory::LongLongVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] __int64 *pVal);
   *
   * \brief	Read a signed quadword value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write a signed quadword value from the specified remote address"),
   id(dispidNktProcessMemoryLongLongVal)]
  HRESULT LongLongVal([in] my_ssize_t remoteAddr, [out, retval] __int64 *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::LongLongVal([in] my_ssize_t remoteAddr,
   * 		[in] __int64 newValue);
   *
   * \brief	Write a signed quadword value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed quadword value to the specified remote address"),
   id(dispidNktProcessMemoryLongLongVal)]
  HRESULT LongLongVal([in] my_ssize_t remoteAddr, [in] __int64 newValue);

  /**
   * \fn	HRESULT INktProcessMemory::ULongLongVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] unsigned __int64 *pVal);
   *
   * \brief	Read an unsigned quadword value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write an unsigned quadword value from the specified remote address"),
   id(dispidNktProcessMemoryULongLongVal)]
  HRESULT ULongLongVal([in] my_ssize_t remoteAddr, [out, retval] unsigned __int64 *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::ULongLongVal([in] my_ssize_t remoteAddr,
   * 		[in] unsigned __int64 newValue);
   *
   * \brief	Write an unsigned quadword value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned quadword value to the specified remote address"),
   id(dispidNktProcessMemoryULongLongVal)]
  HRESULT ULongLongVal([in] my_ssize_t remoteAddr, [in] unsigned __int64 newValue);

  /**
   * \fn	HRESULT INktProcessMemory::SSizeTVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] my_ssize_t *pVal);
   *
   * \brief	Read a signed integral sized value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write a signed integral sized value from the specified remote address"),
   id(dispidNktProcessMemorySSizeTVal)]
  HRESULT SSizeTVal([in] my_ssize_t remoteAddr, [out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::SSizeTVal([in] my_ssize_t remoteAddr,
   * 		[in] my_ssize_t newValue);
   *
   * \brief	Write a signed integral sized value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a signed integral sized value to the specified remote address"),
   id(dispidNktProcessMemorySSizeTVal)]
  HRESULT SSizeTVal([in] my_ssize_t remoteAddr, [in] my_ssize_t newValue);

  /**
   * \fn	HRESULT INktProcessMemory::SizeTVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] my_size_t *pVal);
   *
   * \brief	Read an unsigned integral sized value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write an unsigned integral sized value from the specified remote address"),
   id(dispidNktProcessMemorySizeTVal)]
  HRESULT SizeTVal([in] my_ssize_t remoteAddr, [out, retval] my_size_t *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::SizeTVal([in] my_ssize_t remoteAddr,
   * 		[in] my_size_t newValue);
   *
   * \brief	Write an unsigned integral sized value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write an unsigned integral sized value to the specified remote address"),
   id(dispidNktProcessMemorySizeTVal)]
  HRESULT SizeTVal([in] my_ssize_t remoteAddr, [in] my_size_t newValue);

  /**
   * \fn	HRESULT INktProcessMemory::FloatVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] float *pVal);
   *
   * \brief	Read a single precision floating point value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive requested value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write a single precision floating point value from the specified remote "
                       "address"),
   id(dispidNktProcessMemoryFloatVal)]
  HRESULT FloatVal([in] my_ssize_t remoteAddr, [out, retval] float *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::FloatVal([in] my_ssize_t remoteAddr, [in] float newValue);
   *
   * \brief Write a single precision floating point value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a single precision floating point value to the specified remote "
                       "address"),
   id(dispidNktProcessMemoryFloatVal)]
  HRESULT FloatVal([in] my_ssize_t remoteAddr, [in] float newValue);

  /**
   * \fn	HRESULT INktProcessMemory::DoubleVal([in] my_ssize_t remoteAddr, [out,
   * 		retval] double *pVal);
   *
   * \brief	Read a double precision floating point value from the specified remote address.
   *
   * \param	remoteAddr			The remote address.
   * \param [in,out]	pVal	Pointer to receive value.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_POINTER of pVal pointer value is NULL.
   * \return \c E_FAIL on general error. 
   */

  [propget, helpstring("Read/Write a double precision floating point value from the specified remote "
                       "address"),
   id(dispidNktProcessMemoryDoubleVal)]
  HRESULT DoubleVal([in] my_ssize_t remoteAddr, [out, retval] double *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::DoubleVal([in] my_ssize_t remoteAddr, [in] double newValue);
   *
   * \brief	Write a double precision floating point value to the specified remote address.
   *
   * \param	remoteAddr	The remote address.
   * \param	newValue  	The new value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if the specified address could not be accessed. 
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Read/Write a double precision floating point value to the specified remote "
                       "address"),
   id(dispidNktProcessMemoryDoubleVal)]
  HRESULT DoubleVal([in] my_ssize_t remoteAddr, [in] double newValue);


  /**
   * \fn	HRESULT INktParam::BuildParam([in] my_ssize_t remoteAddr, [in] BSTR type, [out, retval]
   * 		INktParam **ppParam);
   *
   * \brief	Build a parameter from the given address and type.
   *
   * \param	remoteAddr			   	Remote address to request data.
   * \param	type			   	Name of the target type. 
   * \param [in,out]	ppParam	A pointer to receive the INktParam interface address.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_INVALIDARG if provided string is empty.
   * \return \c NKT_DVERR_NotFound if the specified type cannot be found in the Deviare database.
   * \return \c NKT_DVERR_NotSupported if operation unsupported on this architecture.
   * \return \c E_OUTOFMEMORY if the new parameter could not be created due to memory error.      
   */

  [helpstring("Build a parameter from the given address and type"),
   id(dispidNktProcessMemoryBuildParam)]
  HRESULT BuildParam([in] my_ssize_t remoteAddr, [in] BSTR type, [out, retval] INktParam **ppParam);


  /**
   * \fn	HRESULT INktProcessMemory::AllocMem([in] my_ssize_t bytes,
   * 		[in] VARIANT_BOOL executeFlag, [out, retval] my_ssize_t *pVal);
   *
   * \brief	Allocate a block of memory in the remote process.
   *
   * \param	bytes				The number of bytes to allocate.
   * \param	executeFlag			Set to \c TRUE to enable the execute bit (NX) on the memory page(s) containing the block. 
   * \param [in,out]	pVal	A pointer to receive the address of the allocated block.
   *
   * \remark Use INktProcessMemory::FreeMem to free the allocated memory on the remote process.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer value is NULL.
   * \return \c E_INVALIDARG if byte count is invalid.
   * \return \c E_ACCESSDENIED if this allocation operation is not allowed.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Allocate a block of memory in the remote process"),
   id(dispidNktProcessMemoryAllocMem)]
  HRESULT AllocMem([in] my_ssize_t bytes, [in] VARIANT_BOOL executeFlag, [out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktProcessMemory::FreeMem([in] my_ssize_t remoteAddr);
   *
   * \brief	Free a block of memory in the remote process.
   *
   * \param	remoteAddr	The remote address.
   *
   * \remark Use INktProcessMemory::AllocMem to allocate memory block(s) on the remote process.
   *
   * \return \c S_OK on success.
   * \return \c E_ACCESSDENIED if this deallocation operation is not allowed, or the block was not requested with INktProcessMemory::AllocMem function.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Free a block of memory in the remote process"),
   id(dispidNktProcessMemoryFreeMem)]
  HRESULT FreeMem([in] my_ssize_t remoteAddr);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktStackTrace
 *
 * \brief	Exposes methods for retrieving, analyzing and traversing stack traces.
 *
 * 
 * 
 */

[
  object,
  uuid(42B03B4D-C3DA-463d-98B7-73405754A764),
  dual, local,
  nonextensible,
  helpstring("INktStackTrace Interface"),
  pointer_default(unique)
]
interface INktStackTrace : INktObject
{
  /**
   * \fn	HRESULT INktStackTrace::NearestFunction([in] LONG depth, [out,
   * 		retval] INktExportedFunction **ppExpFunc);
   *
   * \brief	Find the exported function associated with a call.
   *
   * \param	depth				 	The depth in the stack trace.
   * \param [in,out]	ppExpFunc	A pointer to receive the exported function interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer parameter is NULL.
   * \return \c E_INVALIDARG if the specified call depth is invalid.
   * \return \c NKT_DVERR_NotFound if requested information could not be found.
   * \return \c E_FAIL on general error.
   * \remarks Maximum stack searching depth is 50, as determined by the internal \c NKT_DV_TMSG_ONHOOKCALLED_StackTraceDepth constant.
   */

  [helpstring("Find the exported function associated with a call"),
   id(dispidNktStackTraceNearestFunction)]
  HRESULT NearestFunction([in] LONG depth, [out, retval] INktExportedFunction **ppExpFunc);

  /**
   * \fn	HRESULT INktStackTrace::Module([in] LONG depth, [out, retval] INktModule **ppMod);
   *
   * \brief	Find the module associated with a call.
   *
   * \param	depth			 	The depth in the stack trace.
   * \param [in,out]	ppMod	A pointer to receive the exported function interface.
   * \remarks Interface should be released in the @link Deviare2::DNktHookEvents::OnFunctionCalled OnFunctionCalled @endlink context. In .NET you should use Marshal.ReleaseComObject after using it.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer parameter is NULL.
   * \return \c E_INVALIDARG if the specified call depth is invalid.
   * \return \c NKT_DVERR_NotFound if requested information could not be found.
   * \return \c E_FAIL on general error.
   * \remarks Maximum stack searching depth is 50, as determined by the internal \c NKT_DV_TMSG_ONHOOKCALLED_StackTraceDepth constant.
   *
   */

  [helpstring("Find the module associated with a call"),
   id(dispidNktStackTraceModule)]
  HRESULT Module([in] LONG depth, [out, retval] INktModule **ppMod);

  /**
   * \fn	HRESULT INktStackTrace::Offset([in] LONG depth, [out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the call offset relative to the module base address.
   *
   * \param	depth				The depth in the stack trace.
   * \param [in,out]	pVal	A pointer to a pointer-sized value to store address.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer parameter is NULL.
   * \return \c E_INVALIDARG if the specified call depth is invalid.
   * \return \c NKT_DVERR_NotFound if requested information could not be found.
   * \return \c E_FAIL on general error.
   * \remarks Maximum stack searching depth is 50, as determined by the internal \c NKT_DV_TMSG_ONHOOKCALLED_StackTraceDepth constant.
   *
   */

  [helpstring("Get the call offset in the module"),
   id(dispidNktStackTraceOffset)]
  HRESULT Offset([in] LONG depth, [out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktStackTrace::Address([in] LONG depth, [out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the address of a call.
   *
   * \param	depth				The depth in the stack trace.
   * \param [in,out]	pVal	A pointer to a pointer-sized value to store address.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer parameter is NULL.
   * \return \c E_INVALIDARG if the specified call depth is invalid.
   * \return \c NKT_DVERR_NotFound if requested information could not be found.   
   * \return \c E_FAIL on general error.
   * \remarks Maximum stack searching depth is 50, as determined by the internal \c NKT_DV_TMSG_ONHOOKCALLED_StackTraceDepth constant.   
   */

  [helpstring("Get the address of a call"),
   id(dispidNktStackTraceAddress)]
  HRESULT Address([in] LONG depth, [out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktStackTrace::NearestSymbol([in] LONG depth, [out, retval] BSTR *pVal);
   *
   * \brief	Find the nearest symbol associated with a call.
   *
   * \param	depth				The depth in the stack trace.
   * \param [in,out]	pVal	A string pointer to receive the symbol name, if any.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer parameter is NULL.
   * \return \c E_INVALIDARG if the specified call depth is invalid.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   * \return \c NKT_DVERR_NotFound if requested information could not be found.
   * \return \c E_FAIL on general error.
   * \remarks Maximum stack searching depth is 50, as determined by the internal \c NKT_DV_TMSG_ONHOOKCALLED_StackTraceDepth constant.   
   */

  [helpstring("Find the nearest symbol associated with a call"),
   id(dispidNktStackTraceNearestSymbol)]
  HRESULT NearestSymbol([in] LONG depth, [out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktStackTrace::Params([in] LONG depth, [out,
   * 		retval] INktParamsEnum **ppParamsEnum);
   *
   * \brief	Get the parameters associated with a call.
   *
   * \param	depth						The depth in the stack trace.
   * \param [in,out]	ppParamsEnum	A pointer to receive the parameter enumeration interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer parameter is NULL.
   * \return \c E_INVALIDARG if the specified call depth is invalid.   
   * \return \c NKT_DVERR_NotFound if requested information could not be found.
   * \return \c E_FAIL on general error.
   * \remarks Maximum stack searching depth is 50, as determined by the internal \c NKT_DV_TMSG_ONHOOKCALLED_StackTraceDepth constant.   
   */

  [helpstring("Get the parameters associated with a call"),
   id(dispidNktStackTraceParams)]
  HRESULT Params([in] LONG depth, [out, retval] INktParamsEnum **ppParamsEnum);

  /**
   * \fn	HRESULT INktStackTrace::Result([in] LONG depth, [out, retval] INktParam **ppParam);
   *
   * \brief	Get the result associated with a call.
   *
   * \param	depth			   	The depth in the stack trace.
   * \param [in,out]	ppParam	A pointer to receive the parameter interface representing the function call result.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer parameter is NULL.
   * \return \c E_INVALIDARG if the specified call depth is invalid.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   * \return \c NKT_DVERR_NotFound if requested information could not be found.
   * \return \c E_FAIL on general error.
   *
   * \remarks Maximum stack searching depth is 50, as determined by the internal \c NKT_DV_TMSG_ONHOOKCALLED_StackTraceDepth constant.
   */

  [helpstring("Get the result associated with a call"),
   id(dispidNktStackTraceResult)]
  HRESULT Result([in] LONG depth, [out, retval] INktParam **ppParam);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktSpyMgr
 *
 * \brief	This is central Deviare interface. It exposes methods for initializing and configuring the interception engine; working with hooks, agents and custom DLLs; and obtaining interfaces to access to process, memory and similar system objects.
 * 
 *
 * 
 * 
 */

[
  object,
  uuid(DD71FF07-B1E6-430e-8439-53B760E90062),
  dual, local,
  nonextensible,
  helpstring("INktSpyMgr Interface"),
  pointer_default(unique)
]
interface INktSpyMgr : INktObject
{
  /**
   * \fn	HRESULT INktSpyMgr::SettingOverride([in] BSTR setting, [in] LONG newValue);
   *
   * \brief	Overrides a Deviare engine setting. 
   *
   * \param [in]	setting	Name of setting to override. 
   * \param [in]	newValue	New value to set.
   *
   * \remarks The following settings are available:
   
   Setting       | Meaning       | Default
   ------------- | ------------- | ------------
	\c SpyMgrDebugLevelMask  |  A set of flags affecting SpyMgr component debugging output. See "Debug Flags" below | 0
	\c SpyMgrAgentLevelMask  | A set of flags affecting agent component debugging output. See "Debug Flags" below			| 0
	\c SpyMgrMemMgrPoolMaxAge| The time in milliseconds a free block will remain in memory until released to the operating system	| 10000
	\c SpyMgrTransportMaxInUseMessageCount | Reserved | Reserved
	\c SpyMgrTransportMaxFreeBufferList 	| Reserved | Reserved
	\c SpyMgrMemMgrPoolCheckFrequency | The frequency where the LRU blocks are checked and discarded | 128
	\c SpyMgrTransportMessageDelay | Time in milliseconds in message delivery in order to keep memory usage low until more buffers became available. SpyMgrMaxInUseTransportMessageCount and AgentMaxInUseTransportMessageCount sets the maximum message count to send/receive before starting the delay operation | 50
	\c AgentMemMgrPoolMaxAge | Reserved | Reserved
	\c AgentMemMgrPoolCheckFrequency | Reserved | Reserved
	\c AgentTransportMaxFreeBufferList | Reserved | Reserved
	\c AgentTransportMaxInUseMessageCount | Reserved | Reserved
	\c AgentTransportMessageDelay | Time in milliseconds in message delivery in order to keep memory usage low until more buffers became available. SpyMgrMaxInUseTransportMessageCount and AgentMaxInUseTransportMessageCount sets the maximum message count to send/receive before starting the delay operation | 50
	\c AgentLoadTimeout | Time in milliseconds to wait for agent loading | 10000
	
	Unless you need specific application requeriments, Deviare is by default optimized for most usage scenarios. 	
	
	* Debug Flags available:
	
		+ Tools = \c 0x00000008 
		+ Transport = \c 0x00000010
		+ Engine = \c 0x00000020
		+ Agent = \c 0x00000040
		+ HookEngine = \c 0x00000080
		+ HookEnginePreCall = \c 0x00000100
		+ HookEnginePostCall = \c 0x00000200
		+ Error = \c 0x00000400
		+ Warning = \c 0x00000800
		+ dlInformation = \c 0x00002000	
	
   * \return \c S_OK on success.
   * \return \c E_POINTER if BSTR parameter is NULL.
   * \return \c E_INVALIDARG if specified parameter is invalid does not exist.
   */

  [helpstring("Overrides a tweak setting"),
   id(dispidNktSpyMgrSettingOverride)]
  HRESULT SettingOverride([in] BSTR setting, [in] LONG newValue);

  /**
   * \fn	HRESULT INktSpyMgr::DatabasePath([out, retval] BSTR *pVal);
   *
   * \brief	Get the database path.
   *
   * \param [in,out]	pVal	Pointer to String to receive the database path.
   *
   * \remarks The database path is read-only after engine initialization.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   * \return \c E_FAIL on general error.

  [propget, helpstring("Get/Set the database path (read-only after initialization)"),
   id(dispidNktSpyMgrDatabasePath)]
  HRESULT DatabasePath([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktSpyMgr::DatabasePath([in] BSTR newValue);
   *
   * \brief	Set the database path.
   *
   * \param	newValue	The new value.
   *
   * \remarks The database path is read-only after engine initialization.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG is the provided string is not valid.
   * \return \c NKT_DVERR_AlreadyInitialized if the engine is already initialized.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Get/Set the database path (read-only after initialization)"),
   id(dispidNktSpyMgrDatabasePath)]
  HRESULT DatabasePath([in] BSTR newValue);

  /**
   * \fn	HRESULT INktSpyMgr::AgentPath([out, retval] BSTR *pVal);
   *
   * \brief	Get the agent DLL path.
   *
   * \remarks The agent DLL path is read-only after engine initialization.
   *
   * \param [in,out]	pVal	Pointer to string to receive the agent DLL path.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get/Set the agent dll path (read-only after initialization)"),
   id(dispidNktSpyMgrAgentPath)]
  HRESULT AgentPath([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktSpyMgr::AgentPath([in] BSTR newValue);
   *
   * \brief	Set the agent DLL path (read-only after initialization).   
   * \remarks The agent DLL path is read-only after engine initialization.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG is the provided string is not valid.
   * \return \c E_FAIL on general error.
   */
   
  [propput, helpstring("Get/Set the agent dll path (read-only after initialization)"),
   id(dispidNktSpyMgrAgentPath)]
  HRESULT AgentPath([in] BSTR newValue);

  /**
   * \fn	HRESULT INktSpyMgr::Initialize([out, retval] LONG *pVal);
   *
   * \brief	Initializes the Spy Manager system. 
   *
   * \details This method MUST be called before using any instance of INktSpyMgr. 
   *
   * \param [out]	pVal	0 on success, eNktErrorCodes or regular HRESULT error code on fail.  Common codes: 
   * \c E_FILENOTFOUND if database files could not be found. For 64-bit applications, both 32bit and 64-bit Database AND Agent DLLs are required.
   *
   * \remarks For performance oriented applications, we recommend to switch to multithreaded-apartment mode before Deviare initialization.
   *          For C++ applications, it's enough to call:
   *
   *          \c CoInitializeEx(NULL, COINIT_MULTITHREADED);
   *
   *          For C#  use the \c [MTAThread] attribute. 
   *
   *		  For more information on threading apartment, please check your programming language and/or library reference. Note that MTA-threading mode
   *          may be incompatible and/or provoke unexpected side effects when used with some COM and .NET components. For example, WinForms applications
   *          do not support MTA.
   *
   * \return S_OK on success or E_FAIL on general error. 
   */

  [helpstring("Initializes the Spy Manager system."),
   id(dispidNktSpyMgrInitialize)]
  HRESULT Initialize([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktSpyMgr::Processes([out, retval] INktProcessesEnum **ppProcsEnum);
   *
   * \brief	Retrieves the currently running processes. 
   *
   * \remarks The engine updates this list at an approximate rate of 10 times per second.
   *
   * \param [out]	ppProcsEnum	A pointer to receive the INktProcessesEnum enumerator interface to retrieve the running processes.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Retrieves the currently running processes."),
   id(dispidNktSpyMgrProcesses)]
  HRESULT Processes([out, retval] INktProcessesEnum **ppProcsEnum);

  /**
   * \fn	HRESULT INktSpyMgr::Hooks([out, retval] INktHooksEnum **ppHooksEnum);
   *
   * \brief	Retrieves a hook enumerator object representing the existent hooks on this engine instance.
   *
   * \param [in,out]	ppHooksEnum	A pointer to receive the INktHooksEnum  enumerator interface. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Retrieves a hook enumerator object"),
   id(dispidNktSpyMgrHooks)]
  HRESULT Hooks([out, retval] INktHooksEnum **ppHooksEnum);

  /**
   * \fn	HRESULT INktSpyMgr::CreateHooksCollection([out, retval] INktHooksEnum **ppHooksEnum);
   *
   * \brief	Creates a hook collection object.   Collections of hooks are a convenience feature for grouping several hooks in one manageable interface. 
   *
   *
   * \param [in,out]	ppHooksEnum	A pointer to receive the INktHooksEnum  enumerator interface. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Retrieves a hook enumerator object"),
   id(dispidNktSpyMgrCreateHooksCollection)]
  HRESULT CreateHooksCollection([out, retval] INktHooksEnum **ppHooksColl);

  /**
   * \fn	HRESULT INktSpyMgr::CreateHook([in] VARIANT func, [in] LONG hookFlags, [out, retval] INktHook **ppHook);
   *
   * \brief	Creates a hook to intercept the provided function name or an INktExportedFunction compatible object.
   *
   * \details The function names should be passed in the format "[dll]![function name]" (example: "kernel32.dll!CreateFileW").
   *
   * \param	func			  	A variant containing either a function name string or a pointer to a INktExportedFunction interface.
   * \param	hookFlags		  	The hook flags. Any combination is allowed. See ::eNktHookFlags.
   * \param [out]	ppHook	A pointer to receive the created hook. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL, or VARIANT contains a null pointer.
   * \return \c E_INVALIDARG if variant type is not VT_BSTR (string), VT_DISPATCH or VT_UNKNOWN (INktExportedFunction compatible).
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error. 
   */

  [helpstring("Creates a hook with the provided function name or an ::INktExportedFunction implementor."),
   id(dispidNktSpyMgrCreateHook)]
  HRESULT CreateHook([in] VARIANT func, [in] LONG hookFlags, [out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktSpyMgr::CreateHookForAddress([in] my_ssize_t addr, [in] BSTR functionName,
   * 		[in] LONG hookFlags, [out, retval] INktHook **ppHook);
   *
   * \brief	Creates a hook to intercept a function specified by its memory address.
   *
   * \param	addr			  	The memory address related to the function to intercept. 
   * \param	functionName			  	An optional function name to associate to this hook.
   * \param	hookFlags		  	The hook flags. See ::eNktHookFlags enumeration.
   * \param [in,out]	ppHook	A pointer to receive the created hook. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Create a hook with the provided process and address"),
   id(dispidNktSpyMgrCreateHookForAddress)]
  HRESULT CreateHookForAddress([in] my_ssize_t addr, [in] BSTR functionName, [in] LONG hookFlags,
                               [out, retval] INktHook **ppHook);

  /**
   * \fn	HRESULT INktSpyMgr::DestroyHook([in] INktHook *hook);
   *
   * \brief	Destroys a hook.
   *
   * \param [in,out]	hook	A pointer to the hook object to destroy.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Destroy a hook"),
   id(dispidNktSpyMgrDestroyHook)]
  HRESULT DestroyHook([in] INktHook *hook);

  /**
   * \fn	HRESULT INktSpyMgr::LoadAgent([in] VARIANT procOrId);
   *
   * \brief	Loads the agent DLL in the target process.
   *
   * \param	procOrId			 	A variant containing either a process identifier (PID) or a pointer to a INktProcess interface. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if variant does not contain a LONG integer representing a PID (or compatible type), or a INktProcess interface pointer.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Loads the agent in the target process"),
   id(dispidNktSpyMgrLoadAgent)]
  HRESULT LoadAgent([in] VARIANT procOrId);

  /**
   * \fn	HRESULT INktSpyMgr::UnloadAgent([in] VARIANT procOrId);
   *
   * \brief	Forces agent unload from the target process.
   *
   * \param	procOrId			 	A variant containing either a process identifier (PID) or a pointer to a INktProcess interface. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if variant does not contain a LONG integer representing a PID (or compatible type), or a INktProcess interface pointer.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Forces agent unload from the target process"),
   id(dispidNktSpyMgrUnloadAgent)]
  HRESULT UnloadAgent([in] VARIANT procOrId);

  /**
   * \fn	HRESULT INktSpyMgr::LoadCustomDll([in] VARIANT procOrId, [in] BSTR dllFileName, [in,
   * 		defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL unloadOnAgentShutdown, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync, [out, retval] LONG *pActionId);
   *
   * \brief	Loads a custom DLL  in a target process.
   *
   * \param	procOrId			 	A variant containing either a process identifier (PID) or a pointer to a INktProcess interface.
   * \param	dllFileName			 	Filename of the DLL file.
   * \param	unloadOnAgentShutdown	If \c TRUE, the DLL will be automatically unloaded when Agent shuts down; remains loaded in the target process otherwise.
   * \param	sync					\c TRUE to call in synchronous mode.
   * \param [in,out]	pActionId	A pointer to receive a cookie identifying this call in completion event, during asynchronous mode. In a synchronous operation, this is ignored.
   *
   * \remarks The DLL to load must export a set of functions identified by the following C signatures:
   * 
   * \code {.cpp}
   * typedef HRESULT (WINAPI *lpfnUserFunc0)();
   * typedef HRESULT (WINAPI *lpfnUserFunc1)(SIZE_T nParam1);
   * typedef HRESULT (WINAPI *lpfnUserFunc2)(SIZE_T nParam1, SIZE_T nParam2);
   * typedef HRESULT (WINAPI *lpfnUserFunc3)(SIZE_T nParam1, SIZE_T nParam2, SIZE_T nParam3);
   * typedef HRESULT (WINAPI *lpfnUserFunc4)(SIZE_T nParam1, SIZE_T nParam2, SIZE_T nParam3, SIZE_T nParam4);
   * \endcode
   * 
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if variant does not contain a LONG integer representing a PID (or compatible type), or a INktProcess interface pointer.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Loads a custom dll in the target process"),
   id(dispidNktSpyMgrLoadCustomDll)]
  HRESULT LoadCustomDll([in] VARIANT procOrId, [in] BSTR dllFileName,
                        [in, defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL unloadOnAgentShutdown,
                        [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync,
                        [out, retval] LONG *pActionId);

  /**
   * \fn	HRESULT INktSpyMgr::UnloadCustomDll([in] VARIANT procOrId, [in] BSTR dllFileName, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync, [out, retval] my_ssize_t *pVal);
   *
   * \brief	Unloads a custom DLL from a target process.
   *
   * \param	procOrId			A variant containing either a process identifier (PID) or a pointer to a INktProcess interface.
   * \param	dllFileName			Filename of the DLL file.
   * \param	sync					\c TRUE to call in synchronous mode.
   * \param [in,out]	pActionId	A pointer to receive a cookie identifying this call in completion event, during asynchronous mode. In a synchronous operation, this is ignored.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if variant does not contain a LONG integer representing a PID (or compatible type), or a INktProcess interface pointer.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Unloads a custom dll in the target process id"),
   id(dispidNktSpyMgrUnloadCustomDll)]
  HRESULT UnloadCustomDll([in] VARIANT procOrId, [in] BSTR dllFileName,
                          [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync,
                          [out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktSpyMgr::CallCustomApi([in] VARIANT procOrId, [in] BSTR dllFileName,
   * 		[in] BSTR apiToCall, [in, defaultvalue(NULL)] VARIANT *params, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync, [out, retval] LONG *pVal);
   *
   * \brief	Calls a custom API in the target process.
   *
   * \param	procOrId		  	A variant containing either a process identifier (PID) or a pointer to a INktProcess interface.
   * \param	dllFileName		  	Filename of the DLL file.
   * \param	apiToCall		  	The API function to call.
   * \param [in,out]	params	A pointer to an array of variants with the parameters to pass. Supported element types are single or arrays of 1, 2, 4 or 8-byte integers, signed or unsigned. In terms of Win32 VARIANT VT constants: VT_Ix, VT_UIx and VT_Ix|VT_ARRAY, VT_IUx|VT_ARRAY, where x=1,2,4 or 8.
   * \param	sync			  	\c TRUE to call in synchronous mode.
   * \param [in,out]	pVal  	A pointer to receive a cookie identifying this call in completion event, during asynchronous mode. For sync operation, this is ignored.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if any pointer argument is NULL.
   * \return \c E_INVALIDARG if procOrId does not contain a LONG integer representing a PID (or compatible type), or a INktProcess interface pointer.
   * \return \c E_INVALIDARG if parameter array contains a variant with one or more unsupported types. 
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Calls a custom api in the target process"),
   id(dispidNktSpyMgrCallCustomApi)]
  HRESULT CallCustomApi([in] VARIANT procOrId, [in] BSTR dllFileName, [in] BSTR apiToCall,
                        [in, defaultvalue(NULL)] VARIANT *params,
                        [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL sync,
                        [out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktSpyMgr::ProcessFromPID([in] LONG pid, [out, retval] INktProcess **ppProc);
   *
   * \brief	Get a process object from the specified process ID.
   *
   * \param	pid				  	The process identifier.
   * \param [in,out]	ppProc	A pointer to receive the INktProcess interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if the specified PID is not valid.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get a process object from the specified process id"),
   id(dispidNktSpyMgrProcessFromPID)]
  HRESULT ProcessFromPID([in] LONG pid, [out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktSpyMgr::ProcessMemoryFromPID([in] LONG pid, [out,
   * 		retval] INktProcessMemory **ppProcMem);
   *
   * \brief	Get a process memory reader/writer object from the specified process id.
   *
   * \param	pid					 	The process identifier.
   * \param [in,out]	ppProcMem	A pointer to receive the INktProcessMemory interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if the specified PID is not valid.
   * \return \c E_OUTOFMEMORY is process memory object cannot be accessed or created.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get a process memory reader/writer object from the specified process id"),
   id(dispidNktSpyMgrProcessMemoryFromPID)]
  HRESULT ProcessMemoryFromPID([in] LONG pid, [out, retval] INktProcessMemory **ppProcMem);

  /**
   * \fn	HRESULT INktSpyMgr::CreateProcess([in] BSTR imagePath, [in,
   * 		defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL suspended, [out,
   * 		defaultvalue(NULL)] VARIANT *continueEvent, [out, retval] INktProcess **ppProc);
   *
   * \brief	Create a new process.
   *
   * \param	imagePath				 	Full pathname of the image file.
   * \param	suspended				 	If \c TRUE, process is created on suspended state.  
   * \param [in,out]	continueEvent	If process was created in suspended state, this is a pointer to receive a cookie to supply the ResumeProcess method to resume the process execution. Can be NULL if suspended parameter is \c FALSE.
   * \param [in,out]	ppProc		 	If successful, a pointer to receive the INktProcess interface identifying the new process.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Create a new process"),
   id(dispidNktSpyMgrCreateProcess)]
  HRESULT CreateProcess([in] BSTR imagePath, [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL suspended,
                        [out, defaultvalue(NULL)] VARIANT *continueEvent,
                        [out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktSpyMgr::CreateProcessWithLogon(  [in] BSTR imagePath,
   *                                                   [in] BSTR userName,
   *                                                   [in] BSTR password,
   *                                                   [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL suspended,
   *                                                   [out,defaultvalue(NULL)] VARIANT *continueEvent,
   *                                                   [out, retval] INktProcess **ppProc);
   *
   * \brief	Create a new process under an arbitrary user impersonation.
   *
   * \param	imagePath				 	Full pathname of the image file.
   * \param	userName				 	User name of the user the new process will belong to.
   * \param	password				 	Password of the user.
   * \param	suspended				 	If \c TRUE, process is created on suspended state.  
   * \param [in,out]	continueEvent	If process was created in suspended state, this is a pointer to receive a cookie to supply the ResumeProcess method to resume the process execution. Can be NULL if suspended parameter is \c FALSE.
   * \param [in,out]	ppProc		 	If successful, a pointer to receive the INktProcess interface identifying the new process.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if userName and/or password argument(s) are invalid; or the token is an invalid handle.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   * \return \c NKT_DVERR_NotSupported this operation is not supported.
   */

  [helpstring("Create a new process"),
   id(dispidNktSpyMgrCreateProcessWithLogon)]
  HRESULT CreateProcessWithLogon([in] BSTR imagePath, [in] BSTR userName, [in] BSTR password,
                                 [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL suspended,
                                 [out, defaultvalue(NULL)] VARIANT *continueEvent,
                                 [out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktSpyMgr::CreateProcessWithToken(  [in] BSTR imagePath,
   *                                                   [in] my_ssize_t token,
   *                                                   [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL suspended,
   *                                                   [out,defaultvalue(NULL)] VARIANT *continueEvent,
   *                                                   [out, retval] INktProcess **ppProc);
   *
   * \brief	Create a new process under an arbitrary user impersonation.
   *
   * \param	imagePath				 	Full pathname of the image file.
   * \param	token						 	Token handle that belongs to the logged used.
   * \param	password				 	Password of the user.
   * \param	suspended				 	If \c TRUE, process is created on suspended state.  
   * \param [in,out]	continueEvent	If process was created in suspended state, this is a pointer to receive a cookie to supply the ResumeProcess method to resume the process execution. Can be NULL if suspended parameter is \c FALSE.
   * \param [in,out]	ppProc		 	If successful, a pointer to receive the INktProcess interface identifying the new process.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if userName and/or password argument(s) are invalid.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   * \return \c NKT_DVERR_NotSupported this operation is not supported.   
   */

  [helpstring("Create a new process"),
   id(dispidNktSpyMgrCreateProcessWithToken)]
  HRESULT CreateProcessWithToken([in] BSTR imagePath, [in] my_ssize_t token,
                                 [in, defaultvalue(MY_VARIANT_FALSE)] VARIANT_BOOL suspended,
                                 [out, defaultvalue(NULL)] VARIANT *continueEvent,
                                 [out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktSpyMgr::ResumeProcess([in] INktProcess *pProc, [in] VARIANT continueEvent);
   *
   * \brief	Resume a suspended process created with CreateProcess, CreateProcessWithToken or CreateProcessWithLogon functions.
   *
   * \param [in,out]	pProc	A pointer to the process object to resume.
   * \param	continueEvent	 	The continue-event cookie obtained from the process creation call.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if the continueEvent cookie is invalid or the variant contains an unsupported type.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
 
   */

  [helpstring("Resume a recently created process"),
   id(dispidNktSpyMgrResumeProcess)]
  HRESULT ResumeProcess([in] INktProcess *pProc, [in] VARIANT continueEvent);

  /**
   * \fn	HRESULT INktSpyMgr::TerminateProcess([in] VARIANT procOrId, [in] LONG exitCode);
   *
   * \brief	Terminate an existing running process.
   *
   * \param	procOrId	A variant containing either a process identifier (PID) or a pointer to a INktProcess interface.
   * \param	exitCode	The exit code.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if variant does not contain a LONG integer representing a PID (or compatible type), or a INktProcess interface pointer.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Terminate an existing running process"),
   id(dispidNktSpyMgrTerminateProcess)]
  HRESULT TerminateProcess([in] VARIANT procOrId, [in] LONG exitCode);

  /**
   * \fn	HRESULT INktSpyMgr::FindProcessId([in] BSTR name, [out, retval] LONG *pVal);
   *
   * \brief	Find the process id from the specified image name.
   *
   * \param	name				The image name. 
   * \param [in,out]	pVal	Pointer to receive the PID value, if any.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Find the process id from the specified name"),
   id(dispidNktSpyMgrFindProcessId)]
  HRESULT FindProcessId([in] BSTR name, [out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktSpyMgr::RealFilePath([in] BSTR name, [out, retval] BSTR *pVal);
   *
   * \brief	Returns the complete filesystem path of the file.
   *
   * \param	name				The name of the file.  
   * \param [in,out]	pVal	A pointer to string to receive the full path.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if provided filename is invalid.
   * \return \c E_OUTOFMEMORY if provided string buffer is insufficient.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Find the real path of the file"),
   id(dispidNktSpyMgrRealFilePath)]
  HRESULT RealFilePath([in] BSTR name, [out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktSpyMgr::DbObjects([in] LONG platformBits, [out,
   * 		retval] INktDbObjectsEnum **ppObjsEnum);
   *
   * \brief	Retrieves a database-object enumerator.
   *
   * \param	platformBits		   	The platform bits. 
   * \param [in,out]	ppObjsEnum	A pointer to receive the enumerator interface.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if specified bitness is not 32/64, or not valid for the current architecture.
   * \return \c E_OUTOFMEMORY if provided string buffer is insufficient.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.   
   */

  [helpstring("Retrieves a database object enumerator object"),
   id(dispidNktSpyMgrDbObjects)]
  HRESULT DbObjects([in] LONG platformBits, [out, retval] INktDbObjectsEnum **ppObjsEnum);

  /**
   * \fn	HRESULT INktSpyMgr::DbFunctions([in] LONG platformBits, [out,
   * 		retval] INktDbObjectsEnum **ppFuncsEnum);
   *
   * \brief	Retrieves a database-function enumerator.
   *
   * \param	platformBits		   	The platform bits.
   * \param [in,out]	ppFuncsEnum	A pointer to receive the enumerator interface.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if specified bitness is not 32/64, or not valid for the current architecture.
   * \return \c E_OUTOFMEMORY if provided string buffer is insufficient.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.   
   */


  [helpstring("Retrieves a database functions enumerator object"),
   id(dispidNktSpyMgrDbFunctions)]
  HRESULT DbFunctions([in] LONG platformBits, [out, retval] INktDbObjectsEnum **ppFuncsEnum);

  /**
   * \fn	HRESULT INktSpyMgr::DbModules([in] LONG platformBits, [out,
   * 		retval] INktDbModulesEnum **ppModsEnum);
   *
   * \brief	Retrieves a database modules enumerator.
   *
   * \param	platformBits		  	The platform bits.
   * \param [in,out]	ppModsEnum	A pointer to receive the enumerator interface.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if specified bitness is not 32/64, or not valid for the current architecture.
   * \return \c E_OUTOFMEMORY if provided string buffer is insufficient.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.   
   */

  [helpstring("Retrieves a database modules enumerator object"),
   id(dispidNktSpyMgrDbModules)]
  HRESULT DbModules([in] LONG platformBits, [out, retval] INktDbModulesEnum **ppModsEnum);

  /**
   * \fn	HRESULT INktSpyMgr::ProcessHandle([in] VARIANT procOrId, [in] LONG desiredAccess, [out,
   * 		retval] my_ssize_t *pVal);
   *
   * \brief	Get a process handle.
   *
   * \param	procOrId					A variant containing either a process identifier (PID) or a pointer to a INktProcess interface.
   * \param	desiredAccess   	The desired access mode. If you specify NULL, the default security descriptor is used. See <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx">Process Security and Access Rights</a>. 
   * \param [in,out]	pVal	A pointer to receive a pointer-sized handle. 
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if variant does not contain a LONG integer representing a PID (or compatible type), or a INktProcess interface pointer.
   * \return \c E_ACCESSDENIED if engine is not initialized or the handle cannot be obtained using the selected access mode.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get a process handle"),
   id(dispidNktSpyMgrProcessHandle)]
  HRESULT ProcessHandle([in] VARIANT procOrId, [in] LONG desiredAccess, [out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktSpyMgr::Memory([in] VARIANT procOrId, [out, retval] INktProcessMemory **ppProcMem);
   *
   * \brief	Get a memory reader/writer object.
   *
   * \param	procOrId					Variant specifying to which process to attach. Can be either ::INktProcess pointer or numeric PID value.
   * \param [in,out]	ppProcMem	A pointer to receive the INktProcessMemory interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if variant does not contain a LONG integer representing a PID (or compatible type), or a INktProcess interface pointer.
   * \return \c E_ACCESSDENIED if engine is not initialized.
   * \return \c E_FAIL on general error.  
   */

  [helpstring("Get a memory reader/writer object"),
   id(dispidNktSpyMgrProcessMemory)]
  HRESULT ProcessMemory([in] VARIANT procOrId, [out, retval] INktProcessMemory **ppProcMem);

/**
   * \fn HRESULT INktSpyMgr::GetWindowProc([in] VARIANT procOrId, [in] my_ssize_t hWnd, [out, retval] my_ssize_t* ppWndProc);
   *
   * \brief Gets the address for a window procedure in a specific process.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get Window Proc"),
   id(dispidNktSpyMgrGetWindowProc)]
  HRESULT GetWindowProc([in] VARIANT procOrId, [in] my_ssize_t hWnd, [out, retval] my_ssize_t* ppWndProc);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktHookCallInfoPlugin
 *
 * \brief	Exposes methods for accessing hooked function call information 
 *          in custom-handler DLLs (inprocess).
 *
 * 
 * 
 */

[
  object,
  uuid(D7630D7B-12E3-407a-8056-CF08A25B3A07),
  dual, local,
  nonextensible,
  helpstring("INktHookCallInfoPlugin Interface"),
  pointer_default(unique)
]
interface INktHookCallInfoPlugin : IDispatch
{
  /**
   * \fn	HRESULT INktHookCallInfoPlugin::IsPreCall([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Indicates if this is the pre-call stage of the hooked function.
   *
   * \param [in,out]	pVal	Pointer to receive boolean value.
   *
   * \return \c S_OK on success, or \c  E_FAIL on general error.
   */

  [propget, helpstring("Get the operating system last error code of the calling thread"),
   id(dispidNktHookCallInfoPluginIsPreCall)]
  HRESULT IsPreCall([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::Cookie([out, retval] LONG *pVal);
   *
     * \brief	Get the cookie of this call.
   *
   * \param [in,out]	pVal	Pointer to long variable to store to cookie.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the cookie of this call"),
   id(dispidNktHookCallInfoPluginCookie)]
  HRESULT Cookie([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::LastError([out, retval] LONG *pVal);
   *
   * \brief	Get the operating system last error code of the calling thread. 
   *
   * \param [in,out]	pVal	Pointer to receive the error code.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   *
   * \remarks * 0 (zero) indicates successful operation.
   * \remarks * To convert the error code to a readable string, check \c FormatMessage API function on MSDN. 
   * \remarks * To convert a system error into an \c HRESULT value, use the \c HRESULT_FROM_WIN32 macro.
   */

  [propget, helpstring("Get/Set the operating system last error code of the calling thread"),
   id(dispidNktHookCallInfoPluginLastError)]
  HRESULT LastError([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::LastError([in] LONG newValue);
   *
   * \brief	Set the operating system last error code of the calling thread.
   *
   * \param	newValue	The new value.
   *
   * \return \c S_OK on success, or \c  E_FAIL on general error.
   * \remark * 0 (zero) indicates successful operation.
   */

  [propput, helpstring("Get/Set the operating system last error code of the calling thread"),
   id(dispidNktHookCallInfoPluginLastError)]
  HRESULT LastError([in] LONG newValue);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::CurrentTimeMs([out, retval] double *pVal);
   *
* \brief	Get the actual time when the function was called in milliseconds since system startup.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the actual time when the function was called in milliseconds"),
   id(dispidNktHookCallInfoPluginCurrentTimeMs)]
  HRESULT CurrentTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::ElapsedTimeMs([out, retval] double *pVal);
   *
   * \brief	Get the elapsed time of the function in milliseconds.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the elapsed time of the function in milliseconds"),
   id(dispidNktHookCallInfoPluginElapsedTimeMs)]
  HRESULT ElapsedTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::ChildsElapsedTimeMs([out, retval] double *pVal);
   *
   * \brief	Get the elapsed time of the function including its hooked children in milliseconds.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the elapsed time of the function including its hooked childs in milliseconds"),
   id(dispidNktHookCallInfoPluginChildsElapsedTimeMs)]
  HRESULT ChildsElapsedTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::KernelModeTimeMs([out, retval] double *pVal);
   *
   * \brief	Get the running time of the current thread in kernel mode in milliseconds.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the elapsed time of the function including its hooked childs in milliseconds"),
   id(dispidNktHookCallInfoPluginKernelModeTimeMs)]
  HRESULT KernelModeTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::UserModeTimeMs([out, retval] double *pVal);
   *
   * \brief	Get the running time of the current thread in user mode in milliseconds.
   *
   * \param [in,out]	pVal	Pointer to double-precision floating point value to get millisecond count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the elapsed time of the function including its hooked childs in milliseconds"),
   id(dispidNktHookCallInfoPluginUserModeTimeMs)]
  HRESULT UserModeTimeMs([out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::CpuClockCycles([out, retval] unsigned __int64 *pVal);
   *
   * \brief	Get the executed CPU clock-cycle count in the current thread.
   *
   * \param [in,out]	pVal	Pointer to unsigned 64-bit integer to receive clock cycle count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */


  [propget, helpstring("Get the elapsed time of the function including its hooked childs in milliseconds"),
   id(dispidNktHookCallInfoPluginCpuClockCycles)]
  HRESULT CpuClockCycles([out, retval] unsigned __int64 *pVal);


  /**
   * \fn	HRESULT INktHookCallInfoPlugin::HookInfo([out, retval] INktHookInfo **ppHookInfo);
   *
 * \brief	Get the hook information associated with the call.
   *
   * \param [in,out]	ppHookInfo	Pointer to address to receive the INktHookInfo interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppHook is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the hook info associated with the call"),
   id(dispidNktHookCallInfoPluginHookInfo)]
  HRESULT HookInfo([out, retval] INktHookInfo **pppHookInfo);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::ThreadId([out, retval] LONG *pVal);
   *
   * \brief	Get the thread id of the call.
   *
   * \param [in,out]	pVal	Pointer to long to receive the thread identifier.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the thread id of the call"),
   id(dispidNktHookCallInfoPluginThreadId)]
  HRESULT ThreadId([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::ChainDepth([out, retval] LONG *pVal);
   *
   * \brief	Get the hook call chain depth in the current thread.
   *
   * \param [in,out]	pVal	Pointer to long to receive the chain depth.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the hook call chain depth in the current thread"),
   id(dispidNktHookCallInfoPluginCallDepth)]
  HRESULT ChainDepth([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::CurrentProcess([out, retval] INktProcess **ppProc);
   *
   * \brief	Get the current process object.
   *
   * \param [in,out]	ppProc	A pointer to receive the process object interface.
   *
   * \return S_OK or E_FAIL.
   */

  [helpstring("Get the current process object"),
   id(dispidNktHookCallInfoPluginCurrentProcess)]
  HRESULT CurrentProcess([out, retval] INktProcess **ppProc);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::StackTrace([out, retval] INktStackTrace **ppStackTrace);
   *
  * \brief	Get the stack trace of the call.
   *
   * \param [in,out]	ppStackTrace	Pointer to address to receive the INktStackTrace interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppStackTrace is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the stack trace of the call"),
   id(dispidNktHookCallInfoPluginStackTrace)]
  HRESULT StackTrace([out, retval] INktStackTrace **ppStackTrace);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::Params([out, retval] INktParamsEnum **ppParamsEnum);
   *
   * \brief	Get the parameters of the call.
   *
   * \param [in,out]	ppParamsEnum	Pointer to address to receive the parameter enumerator interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParamsEnum is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the parameters of the call"),
   id(dispidNktHookCallInfoPluginParams)]
  HRESULT Params([out, retval] INktParamsEnum **ppParamsEnum);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::Result([out, retval] INktParam **ppParam);
   *
   * \brief	Get the result of the call.
   *
   * \param [in,out]	ppParam	Pointer to address to receive the INktParam parameter interface representing the result value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppParam is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the result of the call"),
   id(dispidNktHookCallInfoPluginResult)]
  HRESULT Result([out, retval] INktParam **ppParam);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::Register([in] eNktRegister asmReg, [out,
   * 		retval] my_ssize_t *pVal);
   *
  * \brief	Get a CPU register value.
   *
   * \param	asmReg				eNktRegister enumeration member representing the CPU register to retrieve.
   * \param [in,out]	pVal	A pointer to a register-sized variable to receive the register value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get/Set assembler register value"),
   id(dispidNktHookCallInfoPluginRegister)]
  HRESULT Register([in] eNktRegister asmReg, [out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::Register([in] eNktRegister asmReg, [in] my_ssize_t newValue);
   *
   * \brief	Set CPU register value.
   *
   * \param	asmReg  	eNktRegister enumeration member representing the CPU register to modify.
   * \param	newValue	The new register value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [propput, helpstring("Get/Set assembler register value"),
   id(dispidNktHookCallInfoPluginRegister)]
  HRESULT Register([in] eNktRegister asmReg, [in] my_ssize_t newValue);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::FloatingRegister([in] eNktRegister asmReg, [out,
   * 		retval] double *pVal);
   *
   * \brief	Get floating-point CPU register value.
   *
   * \param	asmReg				The asm register.
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */
   
  [propget, helpstring("Get/Set assembler register value"),
   id(dispidNktHookCallInfoPluginFloatingRegister)]
  HRESULT FloatingRegister([in] eNktRegister asmReg, [out, retval] double *pVal);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::FloatingRegister([in] eNktRegister asmReg,
   * 		[in] double newValue);
   *
   * \brief	Set floating-point CPU register value.
   *
   * \param	asmReg  	The asm register.
   * \param	newValue	The new value.
   *
   * \return S_OK or E_FAIL.
   */

  [propput, helpstring("Get/Set assembler register value"),
   id(dispidNktHookCallInfoPluginFloatingRegister)]
  HRESULT FloatingRegister([in] eNktRegister asmReg, [in] double newValue);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::SkipCall();
   *
   * \brief	Skip calling the original function.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Skip calling the original function"),
   id(dispidNktHookCallInfoPluginSkipCall)]
  HRESULT SkipCall();

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::FilterSpyMgrEvent();
   *
   * \brief	Prevent the current call from being sent to the SpyMgr session. Use it for filtering calls.
   *
   * \return S_OK on success.   
   */

  [helpstring("Skip calling the original function"),
   id(dispidNktHookCallInfoPluginFilterSpyMgrEvent)]
  HRESULT FilterSpyMgrEvent();

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::Add([in] BSTR name, [in] VARIANT value);
   *
   * \brief	Add a custom parameter.
   *
   * \param name	The name of the parameter to add.
   * \param	value	The VARIANT to add. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_INVALIDARG if variant type is unsupported.
   */

  [helpstring("Add a custom parameter"),
   id(dispidNktHookCallInfoPluginAdd)]
  HRESULT Add([in] BSTR name, [in] VARIANT value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddString([in] BSTR name, [in] BSTR value);
   *
   * \brief	Add a wide string to the custom parameters.
   *
   * \param name	The name of the string parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add a string to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddString)]
  HRESULT AddString([in] BSTR name, [in] BSTR value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddChar([in] BSTR name, [in] signed char value);
   *
   * \brief	Add a signed byte to the custom parameters.
   *
   * \param name	The name of the signed byte parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add a signed byte to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddChar)]
  HRESULT AddChar([in] BSTR name, [in] signed char value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddByte([in] BSTR name, [in] unsigned char value);
   *
   * \brief	Add an unsigned byte to the custom parameters.
   *
   * \param name	The name of the unsigned byte parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add an unsigned byte to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddByte)]
  HRESULT AddByte([in] BSTR name, [in] unsigned char value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddShort([in] BSTR name, [in] short value);
   *
   * \brief	Add a signed word to the custom parameters.
   *
   * \param name	The name of the signed word parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add a signed word to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddShort)]
  HRESULT AddShort([in] BSTR name, [in] short value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddUShort([in] BSTR name, [in] unsigned short value);
   *
   * \brief	Add an unsigned word to the custom parameters.
   *
   * \param name	The name of the unsigned word parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add an unsigned word to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddUShort)]
  HRESULT AddUShort([in] BSTR name, [in] unsigned short value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddLong([in] BSTR name, [in] long value);
   *
   * \brief	Add a signed doubleword to the custom parameters.
   *
   * \param name	The name of the double-word parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.   
   */

  [helpstring("Add a signed doubleword to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddLong)]
  HRESULT AddLong([in] BSTR name, [in] long value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddULong([in] BSTR name, [in] unsigned long value);
   *
   * \brief	Add an unsigned doubleword to the custom parameters.
   *
   * \param name	The name of the unsigned doubleword parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add an unsigned doubleword to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddULong)]
  HRESULT AddULong([in] BSTR name, [in] unsigned long value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddLongLong([in] BSTR name, [in] __int64 value);
   *
   * \brief	Add a signed quadword to the custom parameters.
   *
   * \param name	The name of the signed quadword parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add a signed quadword to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddLongLong)]
  HRESULT AddLongLong([in] BSTR name, [in] __int64 value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddULongLong([in] BSTR name, [in] unsigned __int64 value);
   *
   * \brief	Add an unsigned quadword to the custom parameters.
   *
   * \param name	The name of the unsigned quadword parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add an unsigned quadword to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddULongLong)]
  HRESULT AddULongLong([in] BSTR name, [in] unsigned __int64 value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddSSizeT([in] BSTR name, [in] my_ssize_t value);
   *
   * \brief	Add a signed integral sized value to the custom parameters.
   *
   * \param name	The name of the signed integral-sized parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add a signed integral sized value to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddSSizeT)]
  HRESULT AddSSizeT([in] BSTR name, [in] my_ssize_t value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddSizeT([in] BSTR name, [in] my_size_t value);
   *
   * \brief	Add an unsigned integral sized value to the custom parameters.
   *
   * \param name	The name of the unsigned integral-sized parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add an unsigned integral sized value to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddSizeT)]
  HRESULT AddSizeT([in] BSTR name, [in] my_size_t value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddFloat([in] BSTR name, [in] float value);
   *
   * \brief	Add a single precision floating point value to the custom parameters.
   *
   * \param name	The name of the single-precision floating point parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add a single precision floating point value to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddFloat)]
  HRESULT AddFloat([in] BSTR name, [in] float value);

  /**
   * \fn	HRESULT INktHookCallInfoPlugin::AddDouble([in] BSTR name, [in] double value);
   *
   * \brief	Add a double precision floating point value to the custom parameters.
   *
   * \param name	The name of the double precision floating point parameter to add.
   * \param	value	The value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if value is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Add a double precision floating point value to the custom parameters"),
   id(dispidNktHookCallInfoPluginAddDouble)]
  HRESULT AddDouble([in] BSTR name, [in] double value);

  /**
  * \fn ReadIntercallData([in] my_ssize_t destAddr, [in] my_ssize_t offset, [in] my_ssize_t bytes);
  *
  * \brief Retrieves user-defined data that is maintained between pre and post call stages. Use WriteIntercallData to store this data.
  * \sa WriteIntercallData
  *
  * \param destAddr Pointer-sized variable indicating address to store retrieved data.
  * \param offset   Offset in the internal buffer to begin read.
  * \param bytes	Number of bytes to read.
  *
  * \remarks Number of bytes cannot exceed 128.
  *  
  * \return S_OK on success.
  * \return E_INVALIDARG if byte count and/or offset are invalid; or the requested byte count exceeds internal buffer size (128 bytes).
  * \return E_POINTER if destination address is NULL.
  * \return E_FAIL if general failure.
  *
  * 
  */
  [helpstring("Retrieves data that is maintained between pre and post call"),
   id(dispidNktHookCallInfoPluginReadIntercallData)]
  HRESULT ReadIntercallData([in] my_ssize_t destAddr, [in] my_ssize_t offset, [in] my_ssize_t bytes);

  
  /**
  * \fn WriteIntercallData([in] my_ssize_t destAddr, [in] my_ssize_t offset, [in] my_ssize_t bytes);
  *
  * \brief Stores user-defined data that is maintained between pre and post call stages. Use ReadIntercallData to read this data.
  * \sa ReadIntercallData
  *
  * \param destAddr Pointer-sized variable indicating address containing data to store.
  * \param offset   Offset in the internal buffer to begin write.
  * \param bytes	Number of bytes to write.
  *
  * \remarks Number of bytes cannot exceed 128.
  *  
  * \return S_OK on success.
  * \return E_INVALIDARG if byte count and/or offset are invalid; or the requested byte count exceeds internal buffer size (128 bytes).
  * \return E_POINTER if source address is NULL.
  * \return E_FAIL if general failure.
  *
  * 
  */
  [helpstring("Stores data that will be maintained between pre and post call"),
   id(dispidNktHookCallInfoPluginWriteIntercallData)]
  HRESULT WriteIntercallData([in] my_ssize_t srcAddr, [in] my_ssize_t offset, [in] my_ssize_t bytes);
};


//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktHookInfo
 *
 * \brief	Exposes methods to access hook information.
 *
 * 
 * 
 */

[
  object,
  uuid(99DE4737-C1B4-49f6-8072-A7645E78BA8B),
  dual, local,
  nonextensible,
  helpstring("INktHookInfo Interface"),
  pointer_default(unique)
]
interface INktHookInfo : IDispatch
{
   /**
   * \fn	HRESULT INktHookInfo::Id([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the hook identifier.
   *
   * \param [in,out]	pVal	A pointer to a pointer-sized variable to receive the identifier.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the hook id"),
   id(dispidNktHookInfoId)]
  HRESULT Id([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktHookInfo::FunctionName([out, retval] BSTR *pVal);
   *
   * \brief	Get the function name related to this hook.
   *
   * \param [in,out]	pVal	Pointer to string to receive the function name.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [propget, helpstring("Get the function name of this hook"),
   id(dispidNktHookInfoFunctionName)]
  HRESULT FunctionName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktHookInfo::Address([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the address of the hooked function.
   *
   * \param [in,out]	pVal	A pointer to receive the address.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the address of the hook"),
   id(dispidNktHookInfoAddress)]
  HRESULT Address([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktHookInfo::DbObject([out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Get the database object associated with this hook.
   *
   * \param [in,out]	ppDbObject	A pointer to receive the INktDbObject interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer has insufficient space.
   */

  [helpstring("Get the database object associated with this hook"),
   id(dispidNktHookInfoDbObject)]
  HRESULT DbObject([out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktHookInfo::SendCustomMessage([out, retval] my_ssize_t *pRetVal,
   * [in] my_ssize_t msgCode, [in] my_ssize_t msgParam,
   * [in, defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL sync);
   *
     * \brief	Send a custom message to the SpyMgr instance.
   *
   * \param pRetVal The returned value from the OnCustomMessage event. Only valid for synchronous messages. 
   * \param	msgCode	The custom message code.
   * \param	msgParam	The custom message parameter.
   * \param	sync	If \c TRUE, the message is sent synchronously.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.   
   * \return \c E_FAIL on general error.
   */
  [helpstring("Send a custom message to the server"),
   id(dispidNktHookInfoSendCustomMessage)]
  HRESULT SendCustomMessage([in] my_ssize_t msgCode, [in] my_ssize_t msgParam,
                            [in, defaultvalue(MY_VARIANT_TRUE)] VARIANT_BOOL sync,
                            [out, retval] my_ssize_t *pRetVal);

  /**
   * \fn	HRESULT INktHookInfo::ThreadIgnore([in] LONG theadId, [in] VARIANT_BOOL ignore);
   *
   * \brief	Adds or removes a thread from the global ignore list.
   *
   * \details When a plugin DLL creates its own threads, this
   * function can be used to force Deviare to ignore the API calls made
   * from those user threads.
   *
   * \param	theadId	The thread id to add/remove.
   * \param	ignore	Indicates if the thread should be ignored or not.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */
  [helpstring("Adds or removes a thread from the global ignore list"),
   id(dispidNktHookInfoThreadIgnore)]
  HRESULT ThreadIgnore([in] LONG theadId, [in] VARIANT_BOOL ignore);

  /**
   * \fn	HRESULT INktHookInfo::InvalidateCache();
   *
   * \brief	Invalidates modules and exports cache.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general error.
   */
  [helpstring("Invalidates modules and exports cache"),
   id(dispidNktHookInfoInvalidateCache)]
  HRESULT InvalidateCache([in] my_ssize_t hDll);

    /**
   * \fn	HRESULT INktHookInfo::CurrentProcess([out, retval] INktProcess **ppProc);
   *
   * \brief	Get the current process object.
   *
   * \param [in,out]	ppProc	A pointer to receive the process object interface.
   *
   * \return \c S_OK on success.
   * \return \c E_FAIL on general failure.
   */

  [helpstring("Get the current process object"),
   id(dispidNktHookInfoCurrentProcess)]
  HRESULT CurrentProcess([out, retval] INktProcess **ppProc);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktDbObject
 *
 * \brief	Exposes methods for querying Deviare database object properties.
 *
 * 
 * 
 */

[
  object,
  uuid(8B4C6D62-05C5-48ee-A527-E1E1C35F522C),
  dual, local,
  nonextensible,
  helpstring("INktDbObject Interface"),
  pointer_default(unique)
]
interface INktDbObject : INktObject
{
  /**
   * \fn	HRESULT INktDbObject::Id([out, retval] LONG *pVal);
   *
   * \brief	Get the id of the database object.
   *
   * \param [in,out]	pVal	A pointer to receive the identifier.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the id of the database object"),
   id(dispidNktDbObjectId)]
  HRESULT Id([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::Class([out, retval] eNktDboClass *pVal);
   *
   * \brief	Get the class of the database object.
   *
   * \param [in,out]	pVal	A pointer to receive eNktDboClass enumerator value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the class of the database object"),
   id(dispidNktDbObjectClass)]
  HRESULT Class([out, retval] eNktDboClass *pVal);

  /**
   * \fn	HRESULT INktDbObject::FundamentalType([out, retval] eNktDboFundamentalType *pVal);
   *
   * \brief	Get the fundamental type of the database object.
   *
   * \param [in,out]	pVal	A pointer to receive the ::eNktDboFundamentalType enumerator value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the fundamental type of the database object"),
   id(dispidNktDbObjectFundamentalType)]
  HRESULT FundamentalType([out, retval] eNktDboFundamentalType *pVal);

  /**
   * \fn	HRESULT INktDbObject::Declaration([out, retval] BSTR *pVal);
   *
   * \brief	Get the declaration of the database object.
   *
   * \param [in,out]	pVal	A pointer to string to receive the declaration.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if insufficient string buffer was provided.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the declaration of the database object"),
   id(dispidNktDbObjectDeclaration)]
  HRESULT Declaration([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktDbObject::Name([out, retval] BSTR *pVal);
   *
   * \brief	Get the name of the database object.
   *
   * \param [in,out]	pVal	A pointer to string to receive the object name.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if insufficient string buffer was provided.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the name of the database object"),
   id(dispidNktDbObjectName)]
  HRESULT Name([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktDbObject::Size([out, retval] LONG *pVal);
   *
   * \brief	Get the size in bytes of the database object.
   *
   * \param [in,out]	pVal	A pointer to receive the size in bytes.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the size in bytes of the database object"),
   id(dispidNktDbObjectSize)]
  HRESULT Size([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::Align([out, retval] LONG *pVal);
   *
   * \brief	Get the alignment in bytes of the database object.
   *
   * \param [in,out]	pVal	A pointer to receive the alignment in bytes.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the alignment in bytes of the database object"),
   id(dispidNktDbObjectAlign)]
  HRESULT Align([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::IsArray([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if the database object is an array.
   *
   * \param [in,out]	pVal	\c TRUE if the object is an array.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */
  [propget, helpstring("Check if the database object is an array"),
   id(dispidNktDbObjectIsArray)]
  HRESULT IsArray([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktDbObject::ArrayMaxHint([out, retval] LONG *pVal);
   *
   * \brief	Get a hint of the maximum array index allowed for an array database object.
   *
   * \param [in,out]	pVal	A pointer to receive the value.
   *
   * \remarks Zero indicates either the object is not an array; or the maximum index equals to ULONG_MAX constant.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */
  [propget, helpstring("Get a hint of the maximum array index allowed of an array database object"),
   id(dispidNktDbObjectArrayMaxHint)]
  HRESULT ArrayMaxHint([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::IsAnsiString([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if this parameter can be treated as an ANSI string.
   *
   * \param [in,out]	pVal	Pointer to receive boolean value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Check if this parameter can be treated as an ansi string"),
   id(dispidNktDbObjectIsAnsiString)]
  HRESULT IsAnsiString([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktDbObject::IsWideString([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if this parameter can be treated as a wide string.
   *
   * \param [in,out]	pVal	Pointer to receive boolean value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Check if this parameter can be treated as a wide string"),
   id(dispidNktDbObjectIsWideString)]
  HRESULT IsWideString([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktDbObject::IsGuid([out, retval] VARIANT_BOOL *pVal);
   *
   * \brief	Check if this parameter is a GUID, IID, CLSID or UUID struct and retrieves its value.
   *
   * \param [in,out]	pVal	 Pointer to receive boolean value.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Check if this parameter is a GUID, IID, CLSID or UUID struct and retrieves"
                       " its value"),
   id(dispidNktDbObjectIsGuid)]
  HRESULT IsGuid([out, retval] VARIANT_BOOL *pVal);

  /**
   * \fn	HRESULT INktDbObject::Evaluate([out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Dereference a pointer-type object and returns the pointed database object.
   *
   * \param [in,out]	ppDbObject	Pointer to address to receive the dereferenced object.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if general error or this parameter is not of pointer-type.
   */

  [helpstring("Evaluates this parameter"),
   id(dispidNktDbObjectEvaluate)]
  HRESULT Evaluate([out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObject::IndexedEvaluate([in] LONG index, [out, retval] INktDbObject **ppDbObject);
   *
   * \brief Dereference the pointer stored at specified index if the object is an array.
   *
   * \param	index			   	Zero-based index.
   * \param [in,out]	ppDbObject	Pointer to address to receive the dereferenced object interface.
   *
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if specified index is invalid.
   * \return \c E_POINTER if ppDbObject is NULL.
   * \return \c E_FAIL if general error, this object is not an array, or the stored array value cannot be dereferenced.
   */

  [helpstring("Evaluate the n'th index of this parameter if it is an array"),
   id(dispidNktDbObjectIndexedEvaluate)]
  HRESULT IndexedEvaluate([in] LONG index, [out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObject::FullEvaluate([out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Recursively dereference this pointer object.
   *
   * \param [in,out]	ppDbObject	Pointer to address to receive the dereferenced object interface.
   *   
   * \return \c S_OK on success.
   * \return \c E_POINTER if ppDbObject is NULL.
   * \return \c E_FAIL if general error, or this object is not  pointer-typed.
   */

  [helpstring("Recursively evaluates this parameter"),
   id(dispidNktDbObjectFullEvaluate)]
  HRESULT FullEvaluate([out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObject::Flags([out, retval] LONG *pVal);
   *
   * \brief	Get the flags of a struct, union or function database object.
   *
   * \param [in,out]	pVal	A pointer to receive the set of flags, if this object is struct, union or function typed. 
   *
   * \sa eNktDboStructUnionFlags and eNktDboFunctionFlags enumerations.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the flags of a structs, unions and functions database objects"),
   id(dispidNktDbObjectFlags)]
  HRESULT Flags([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::ItemsCount([out, retval] LONG *pVal);
   *
   * \brief	Get the children count of the database object.
   *
   * \param [in,out]	pVal	A pointer to receive the children count.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the childs count of the database object"),
   id(dispidNktDbObjectItemsCount)]
  HRESULT ItemsCount([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::NameToIndex([in] BSTR name, [out, retval] LONG *pVal);
   *
   * \brief	Find the zero-based index of a named child item.
   *
   * \param	name				The name to search for.
   * \param [in,out]	pVal	A pointer to receive the zero-based index.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if no child was found with the specified name.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Find the index of a named child item"),
   id(dispidNktDbObjectNameToIndex)]
  HRESULT NameToIndex([in] BSTR name, [out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::Item([in] LONG index, [out, retval] INktDbObject **ppDbObj);
   *
   * \brief	Get the child item at index.
   *
   * \param	index			   	Zero-based index.
   * \param [in,out]	ppDbObj	Pointer to receive the object interface, if any.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if no item was found at specified index.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the database object"),
   id(dispidNktDbObjectItem)]
  HRESULT Item([in] LONG index, [out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObject::Items([out, retval] INktDbObjectsEnum **ppDbObjEnum);
   *
   * \brief	Get the children database objects.
   *
   * \param [in,out]	ppDbObjEnum	 A pointer to receive the database object enumerator interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the childs database objects"),
   id(dispidNktDbObjectItems)]
  HRESULT Items([out, retval] INktDbObjectsEnum **ppDbObjEnum);

  /**
   * \fn	HRESULT INktDbObject::ItemName([in] LONG index, [out, retval] BSTR *pVal);
   *
   * \brief	Get the name of the item.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to string to receive the item name.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if no item was found at specified index.
   * \return \c E_OUTOFMEMORY if provided string buffer is insufficient.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the name of the item"),
   id(dispidNktDbObjectItemName)]
  HRESULT ItemName([in] LONG index, [out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktDbObject::ItemFlags([in] LONG index, [out, retval] LONG *pVal);
   *
   * \brief	Get the flags of the item.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to receive the item flags. See eNktDboItemFlags enumeration members.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if no item was found at specified index.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the flags of the item"),
   id(dispidNktDbObjectItemFlags)]
  HRESULT ItemFlags([in] LONG index, [out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::ItemMemberType([in] LONG index, [out,
   * 		retval] eNktDboItemMemberType *pVal);
   *
   * \brief	Get the member type of the item.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to receive the item type.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if no item was found at specified index.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the member type of the item"),
   id(dispidNktDbObjectItemMemberType)]
  HRESULT ItemMemberType([in] LONG index, [out, retval] eNktDboItemMemberType *pVal);

  /**
   * \fn	HRESULT INktDbObject::ItemStructOffset([in] LONG index, [out, retval] LONG *pVal);
   *
   * \brief	Get the offset in bytes of the struct field.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to receive the struct offset, in bytes.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if no item was found at specified index.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the offset of the struct field"),
   id(dispidNktDbObjectItemStructOffset)]
  HRESULT ItemStructOffset([in] LONG index, [out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::ItemStructBits([in] LONG index, [out, retval] LONG *pVal);
   *
   * \brief	Get the size in bits of the struct field.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	If non-null, the value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if no item was found at specified index.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the size in bits of the struct field"),
   id(dispidNktDbObjectItemStructBits)]
  HRESULT ItemStructBits([in] LONG index, [out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::ItemEnumValue([in] LONG index, [out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the value of an enumeration database object.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	A pointer to receive the enumerator value.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if no item was found at specified index.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the value of an enumeration database object"),
   id(dispidNktDbObjectItemEnumValue)]
  HRESULT ItemEnumValue([in] LONG index, [out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktDbObject::ItemDeclaration([in] LONG index, [out, retval] BSTR *pVal);
   *
   * \brief	Get the declaration of the item.
   *
   * \param	index				Zero-based index.
   * \param [in,out]	pVal	Pointer to string to receive the item declaration.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer is insufficient.
   * \return \c E_INVALIDARG if no item was found at specified index.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Get the declaration of the item"),
   id(dispidNktDbObjectItemDeclaration)]
  HRESULT ItemDeclaration([in] LONG index, [out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktDbObject::FuncCallingConvention([out,
   * 		retval] eNktDboCallingConvention *pVal);
   *
   * \brief	Get the calling convention of a function database object.
   *
   * \param [in,out]	pVal	Pointer to eNktDboCallingConvention enumerator to receive.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.
   */

  [propget, helpstring("Get the calling convention of a function database object"),
   id(dispidNktDbObjectFuncCallingConvention)]
  HRESULT FuncCallingConvention([out, retval] eNktDboCallingConvention *pVal);

  /**
   * \fn	HRESULT INktDbObject::FunctionReturn([out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Get the return object a function database object.
   *
   * \param [in,out]	ppDbObject	A pointer to receive the database object.
   *
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.  
   */

  [propget, helpstring("Get the return object a function database object"),
   id(dispidNktDbObjectFunctionReturn)]
  HRESULT FunctionReturn([out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObject::FunctionReturnFlags([out, retval] LONG *pVal);
   *
   * \brief	Get the return flags a function database object.
   *
   * \param [in,out]	pVal	A pointer to receive the function flags.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.  
   */

  [propget, helpstring("Get the return flags a function database object"),
   id(dispidNktDbObjectFunctionReturnFlags)]
  HRESULT FunctionReturnFlags([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObject::FunctionReturnDeclaration([out, retval] BSTR *pVal);
   *
   * \brief	Get the return declaration a function database object.
   *
   * \param [in,out]	pVal	A pointer to receive the return declaration string.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if provided string buffer is insufficient.
   * \return \c E_FAIL on general error.  
   */

  [propget, helpstring("Get the return declaration a function database object"),
   id(dispidNktDbObjectFunctionReturnDeclaration)]
  HRESULT FunctionReturnDeclaration([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktDbObject::DbModules([out, retval] INktDbModulesEnum **ppDbModsEnum);
   *
   * \brief	Retrieves a database modules enumerator object of this database object.
   *
   * \param [in,out]	ppDbModsEnum	A pointer to receive the enumerator interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.  
   */

  [helpstring("Retrieves a database modules enumerator object of this database object"),
   id(dispidNktDbObjectDbModules)]
  HRESULT DbModules([out, retval] INktDbModulesEnum **ppDbModsEnum);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktDbObjectsEnum
 *
 * \brief	Exposes methods for enumerating a database object collection.
 *
 * 
 * 
 */

[
  object,
  uuid(E36B3F2F-DEA5-4d55-9348-8B67A4157B21),
  dual, local,
  nonextensible,
  helpstring("INktDbObjectsEnum Interface"),
  pointer_default(unique)
]
interface INktDbObjectsEnum : INktObject
{
  /**
   * \fn	HRESULT INktDbObjectsEnum::Count([out, retval] LONG *pVal);
   *
   * \brief	Get the total item count in this collection.
   *
   * \param [in,out]	pVal	Pointer to store the item count. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pVal is NULL.
   */

  [propget, helpstring("Get the total items count in this collection"),
   id(dispidNktDbObjectsEnumCount)]
  HRESULT Count([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbObjectsEnum::GetAt([in] LONG index, [out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Retrieves the item at the specified index.
   *
   * \param	index			   	Zero-based index.
   * \param [in,out]	ppi	Pointer to address to store the retrieved item interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if index parameter is out of bounds.
   */
  [helpstring("Retrieves the item at the specified index"),
   id(dispidNktDbObjectsEnumGetAt)]
  HRESULT GetAt([in] LONG index, [out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObjectsEnum::First([out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Retrieves the first item in the collection.
   *
   * \param [in,out]	ppDbObject	Address of pointer to receive INktDbObject interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the first item in the collection"),
   id(dispidNktDbObjectsEnumFirst)]
  HRESULT First([out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObjectsEnum::Last([out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Retrieves the last item in the collection.
   *
   * \param [in,out]	ppDbObject	Address of pointer to receive INktDbObject interface. Cannot be NULL..
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the last item in the collection"),
   id(dispidNktDbObjectsEnumLast)]
  HRESULT Last([out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObjectsEnum::Next([out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Retrieves the next item in the collection.
   *
   * \param [in,out]	ppDbObject	Address of pointer to receive INktDbObject interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the next item in the collection"),
   id(dispidNktDbObjectsEnumNext)]
  HRESULT Next([out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObjectsEnum::Previous([out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Retrieves the previous item in the collection.
   *
   * \param [in,out]	ppDbObject	Address of pointer to receive INktDbObject interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if argument is NULL.
   * \return \c E_FAIL if item not found (ppDbObject is set to NULL).
   */

  [helpstring("Retrieves the previous item in the collection"),
   id(dispidNktDbObjectsEnumPrevious)]
  HRESULT Previous([out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObjectsEnum::GetById([in] LONG id, [out, retval] INktDbObject **ppDbObject);
   *
   * \brief	Find a database object by id.
   *
   * \param	id				   	Deviare object identifier.
   * \param [in,out]	ppobj	Address of pointer to receive INktDbObject interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if devId is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppProc is set to NULL).
   */   

  [helpstring("Find a database object by id"),
   id(dispidNktDbObjectsEnumGetById)]
  HRESULT GetById([in] LONG id, [out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObjectsEnum::GetByName([in] BSTR name, [out,
   * 		retval] INktDbObject **ppDbObject);
   *
   * \brief	Find a database object by name.
   *
   * \param	name			   	The name.
   * \param [in,out]	ppDbObject	Address of pointer to receive INktDbObject interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if devId is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppProc is set to NULL).
   */

  [helpstring("Find a database object by name"),
   id(dispidNktDbObjectsEnumGetByName)]
  HRESULT GetByName([in] BSTR name, [out, retval] INktDbObject **ppDbObject);

  /**
   * \fn	HRESULT INktDbObjectsEnum::_NewEnum([out, retval] IUnknown** ppUnk);
   *
   * \brief	Retrieves an enumerable collection object.
   *
   * \param [out, retval]	ppUnk		Address of an interface pointer that on return points to the IUnknown interface of an enumerator
   object.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if ppUnk is NULL.
   * \return \c E_FAIL on general failure.
   */

  [propget, helpstring("Retrieves an enumerable collection object"),
   id(DISPID_NEWENUM), restricted]
  HRESULT _NewEnum([out, retval] IUnknown** ppUnk);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktDbModule
 *
 * \brief	Exposes methods for querying database module information.
 *
 * 
 * 
 */

[
  object,
  uuid(9AB36611-AB19-4346-9563-AB47A71A863F),
  dual, local,
  nonextensible,
  helpstring("INktDbModule Interface"),
  pointer_default(unique)
]
interface INktDbModule : INktObject
{
  /**
   * \fn	HRESULT INktDbModule::Id([out, retval] LONG *pVal);
   *
   * \brief	Get the id of the database module.
   *
   * \param [in,out]	pVal	A pointer to receive the module ID.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.  
   */

  [propget, helpstring("Get the id of the database module"),
   id(dispidNktDbModuleId)]
  HRESULT Id([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbModule::Name([out, retval] BSTR *pVal);
   *
   * \brief	Get the module name.
   *
   * \param [in,out]	pVal	A pointer to string to receive the module name.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_OUTOFMEMORY if string buffer is insufficient.
   * \return \c E_FAIL on general error.  
   */
  [propget, helpstring("Get the module name"),
   id(dispidNktDbModuleName)]
  HRESULT Name([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktDbModule::DbFunctions([out, retval] INktDbObjectsEnum **ppDbObjsEnum);
   *
   * \brief	Retrieves a database functions enumerator associated with this module.
   *
   * \param [in,out]	ppDbObjsEnum	A pointer to receive the enumerator interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL on general error.  
   */

  [helpstring("Retrieves a database functions enumerator associated with this module"),
   id(dispidNktDbModuleDbFunctions)]
  HRESULT DbFunctions([out, retval] INktDbObjectsEnum **ppDbObjsEnum);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktDbModulesEnum
 *
 * \brief	Interface for nkt database modules enum.
 *
 * 
 * 
 */

[
  object,
  uuid(D8E4F664-6EC1-4c6b-8791-D72EC69EBCA1),
  dual, local,
  nonextensible,
  helpstring("INktDbModulesEnum Interface"),
  pointer_default(unique)
]
interface INktDbModulesEnum : INktObject
{
  /**
   * \fn	HRESULT INktDbModulesEnum::Count([out, retval] LONG *pVal);
   *
   * \brief	Get the total items count in this collection.
   *
   * \param [in,out]	pVal	Pointer to store the item count. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   */

  [propget, helpstring("Get the total items count in this collection"),
   id(dispidNktDbModulesEnumCount)]
  HRESULT Count([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktDbModulesEnum::GetAt([in] LONG index, [out, retval] INktDbModule **ppDbMod);
   *
   * \brief	Retrieves the item at the specified index.
   *
   * \param	index			   	Zero-based index.
   * \param [in,out]	ppDbMod	Pointer to address to store the retrieved module interface.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if index parameter is out of bounds.
   */
  [helpstring("Retrieves the item at the specified index"),
   id(dispidNktDbModulesEnumGetAt)]
  HRESULT GetAt([in] LONG index, [out, retval] INktDbModule **ppDbMod);

  /**
   * \fn	HRESULT INktDbModulesEnum::First([out, retval] INktDbModule **ppDbMod);
   *
   * \brief	Retrieves the first item in the collection.
   *
   * \param [in,out]	ppDbMod	Address of pointer to receive INktDbModule interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */
  [helpstring("Retrieves the first item in the collection"),
   id(dispidNktDbModulesEnumFirst)]
  HRESULT First([out, retval] INktDbModule **ppDbMod);

  /**
   * \fn	HRESULT INktDbModulesEnum::Last([out, retval] INktDbModule **ppDbMod);
   *
   * \brief	Retrieves the last item in the collection.
   *
   * \param [in,out]	ppDbMod	Address of pointer to receive INktDbObject interface. Cannot be NULL..
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   *
   * \return S_OK or E_FAIL.
   */

  [helpstring("Retrieves the last item in the collection"),
   id(dispidNktDbModulesEnumLast)]
  HRESULT Last([out, retval] INktDbModule **ppDbMod);

  /**
   * \fn	HRESULT INktDbModulesEnum::Next([out, retval] INktDbModule **ppDbMod);
   *
   * \brief	Retrieves the next item in the collection.
   *
   * \param [in,out]	ppDbMod	Address of pointer to receive INktDbObject interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_FAIL if item not found.
   */

  [helpstring("Retrieves the next item in the collection"),
   id(dispidNktDbModulesEnumNext)]
  HRESULT Next([out, retval] INktDbModule **ppDbMod);

  /**
   * \fn	HRESULT INktDbModulesEnum::Previous([out, retval] INktDbModule **ppDbMod);
   *
   * \brief	Retrieves the previous item in the collection.
   *
   * \param [in,out]	ppDbObject	Address of pointer to receive INktDbObject interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if argument is NULL.
   * \return \c E_FAIL if item not found (ppDbMod is set to NULL).
   */

  [helpstring("Retrieves the previous item in the collection"),
   id(dispidNktDbModulesEnumPrevious)]
  HRESULT Previous([out, retval] INktDbModule **ppDbMod);

  /**
   * \fn	HRESULT INktDbModulesEnum::GetById([in] LONG id, [out, retval] INktDbModule **ppDbMod);
   *
   * \brief	Find a database module object by id.
   *
   * \param	id				   	Deviare object identifier.
   * \param [in,out]	ppobj	Address of pointer to receive INktDbModule interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if devId is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppobj is set to NULL).
   */

  [helpstring("Find a database module by id"),
   id(dispidNktDbModulesEnumGetById)]
  HRESULT GetById([in] LONG id, [out, retval] INktDbModule **ppDbMod);

  /**
   * \fn	HRESULT INktDbModulesEnum::GetByName([in] BSTR name, [out,
   * 		retval] INktDbModule **ppDbMod);
   *
   * \brief	Find a database module by name.
   *
   * \param	name			   	The name.
   * \param [in,out]	ppDbObject	Address of pointer to receive INktDbObject interface. Cannot be NULL.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if devId is invalid.
   * \return \c NKTDV_ERR_NotFound if item not found (ppDbObject is set to NULL).
   */

  [helpstring("Find a database module by name"),
   id(dispidNktDbModulesEnumGetByName)]
  HRESULT GetByName([in] BSTR name, [out, retval] INktDbModule **ppDbMod);

  /**
   * \fn	HRESULT INktDbModulesEnum::_NewEnum([out, retval] IUnknown** ppUnk);
   *
   * \brief	Retrieves an enumerable collection object.
   *
   * \param [out, retval]	ppUnk	Address of an interface pointer that on return points to the IUnknown interface of an enumerator
   object.
   *
   * \return \c S_OK on success, 
   * \return \c E_POINTER if ppUnk is NULL.
   * \return \c E_FAIL on general failure.
   */

  [propget, helpstring("Retrieves an enumerable collection object"),
   id(DISPID_NEWENUM), restricted]
  HRESULT _NewEnum([out, retval] IUnknown** ppUnk);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface	INktTools
 *
 * \brief	Exposes methods to access miscellaneous functionality.
 *
 * 
 * 
 */

[
  object,
  uuid(D9C5FF67-2311-494f-BA9A-C7C5AAF14301),
  dual, local,
  nonextensible,
  helpstring("INktTools Interface"),
  pointer_default(unique)
]
interface INktTools : IDispatch
{
  /**
   * \fn	HRESULT ExtractIcon([in] BSTR executablePath, [in] LONG index, [out, retval] IPicture **ppIcon);
   *
   * \brief	Extract an icon from the given executable.
   *
   * \param [in]	executablePath	Executable or resource DLL filename.
   * \param [in]	index	Zero-based icon index.
   * \param [out]	ppIcon	A pointer to receive the extracted icon object. 
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if icon index is invalid.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Extract an icon from the given executable"),
   id(dispidNktToolsExtractIcon)]
  HRESULT ExtractIcon([in] BSTR executablePath, [in] LONG index, [out, retval] IPicture **ppIcon);

  /**
   * \fn	HRESULT GetFileNameFromHandle([in] my_ssize_t handle, [in] VARIANT procOrId, [out, retval] BSTR *pVal);
   *
   * \brief	Retrieves the name of a handle object from a specified process.
   *
   * \param [in]	handle      The handle to query.
   * \param [in]	procOrId    Variant specifying process to query. Can be either ::INktProcess pointer or numeric PID value.
   * \param [out]	pFileName	Pointer to string to receive the filename.
   *
   * \return \c S_OK on success.
   * \return \c E_POINTER if pointer argument is NULL.
   * \return \c E_INVALIDARG if VARIANT does not contain a supported type; or handle parameter is invalid.
   * \return \c E_OUTOFMEMORY if provided string buffer is insufficient.
   * \return \c E_FAIL on general error.
   */
  [helpstring("Retrieves the name of a handle object"),
   id(dispidNktToolsGetFileNameFromHandle)]
  HRESULT GetFileNameFromHandle([in] my_ssize_t _handle, [in] VARIANT procOrId, [out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT LocateFunctionSymbolInPdb([in] BSTR fileName, [in] BSTR functionName,
   * 		[in] BSTR symbolServerPath, [in] BSTR localCachePath,
   * 		[out, retval] INktPdbFunctionSymbol **ppSymbol);
   *
   * \brief	Locate a function symbol in an image or PDB file.
   *
   * \param [in]	fileName	Executable, DLL Library or Program Database file (PDB) to use.
   * \param [in]	functionName	Function name to locate.
   * \param [in]	symbolServerPath	Server folder or URL where the symbols can be located. 
   * \param [in]	localCachePath	Path to a local symbol cache.
   * \param [out]	ppSymbol	A pointer to receive the symbol, if found.
   *
   * \remarks To enable the Deviare engine to use debugging symbols, the following library files are required: \c symsrv.dll which can be obtained in the Debugging Tools for Windows package and \c msdiaXX.dll which is part of the DIA SDK, available in Microsoft Visual Studio installation folder, under DIA SDK/bin directory. The Recommended Debugging Tools for Windows version is 6.12.2633 or higher. Deviare was tested successfully with DIA SDK versions 9.0 (msdia90.dll), 10.0 (msdia100.dll) and 11.0 (msdia110.dll),and it should work with newer releases. 
   * \remarks The required debugging DLLs must be copied in the directory where the Deviare COM DLLs reside. 
   * \remarks For operating system and Microsoft-related products, you can use the standard "http://msdl.microsoft.com/download/symbols" online URL to download the required symbols.
   * \return \c S_OK on success.
   * \return \c E_INVALIDARG if functionName or fileName are invalid strings.
   * \return \c E_OUTOFMEMORY 
   * \return \c NKT_DVERR_NotFound if symbol cannot be found.
   * \return \c E_FAIL on general error.
   */

  [helpstring("Extract an icon from the given executable"),
   id(dispidNktToolsLocateFunctionSymbolInPdb)]
  HRESULT LocateFunctionSymbolInPdb([in] BSTR fileName, [in] BSTR functionName,
                                    [in] BSTR symbolServerPath, [in] BSTR localCachePath,
                                    [out, retval] INktPdbFunctionSymbol **ppSymbol);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface INktStructPEFileHeader
 *
 * \brief Exposes methods to access Portable Executable (PE) Header fields.
 */
[
  object,
  uuid(4192DDF7-FB9A-4de5-8AE5-ADCB5C986B8F),
  dual, local,
  nonextensible,
  helpstring("INktStructPEFileHeader Interface"),
  pointer_default(unique)
]
interface INktStructPEFileHeader : IDispatch
{
  /**
  * \brief Returns the machine architecture.
  * \param pVal Pointer to receive the machine architecture, from the following
  * values: IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_IA64 or IMAGE_FILE_MACHINE_AMD64.  
  */
  [propget, helpstring("Get machine type"),
   id(dispidNktStructPEFileHeaderMachine)]
  HRESULT Machine([out, retval] short *pVal);

  /**
  * \brief Returns the number of sections. 
  * \param pVal Pointer to receive the number of sections. This indicates the size of the section table, which immediately follows the headers. Note that the Windows loader limits the number of sections to 96.
  */
  [propget, helpstring("Get number of sections"),
   id(dispidNktStructPEFileHeaderNumberOfSections)]
  HRESULT NumberOfSections([out, retval] LONG *pVal);

  /**
  * \brief Returns the timestamp of the image.
  * \param pVal Pointer to receive the value. 	This represents the date and time the image was created by the linker. The value is represented in the number of seconds elapsed since midnight (00:00:00), January 1, 1970, Universal Coordinated Time, according to the system clock.
  */
  [propget, helpstring("Get Timedate stamp"),
   id(dispidNktStructPEFileHeaderTimeDateStamp)]
  HRESULT TimeDateStamp([out, retval] LONG *pVal);

  /**
  * \brief Returns the offset of the symbol table, in bytes, or zero if no COFF symbol table exists.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get pointer to symbol table"),
   id(dispidNktStructPEFileHeaderPointerToSymbolTable)]
  HRESULT PointerToSymbolTable([out, retval] LONG *pVal);

  /**
  * \brief Returns the number of symbols in the symbol table.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get number of symbols"),
   id(dispidNktStructPEFileHeaderNumberOfSymbols)]
  HRESULT NumberOfSymbols([out, retval] LONG *pVal);

  /**
  * \brief The size of the optional header, in bytes. 
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get size of optional header"),
   id(dispidNktStructPEFileHeaderSizeOfOptionalHeader)]
  HRESULT SizeOfOptionalHeader([out, retval] my_ssize_t *pVal);

/**
  * \brief Returns the image  characteristics.
  * \param pVal Pointer to receive the value.  See official MSDN documentation  http://msdn.microsoft.com/en-us/library/windows/desktop/ms680313(v=vs.85).aspx for available constants.
  * 
  */ 
  [propget, helpstring("Get characteristics"),
   id(dispidNktStructPEFileHeaderCharacteristics)]
  HRESULT Characteristics([out, retval] short *pVal);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface INktStructPEOptionalHeader
 *
 * \brief Exposes methods to access Portable Executable (PE) Optional header fields.
 */
[
  object,
  uuid(FE1FD754-7630-44db-BFAA-06505C445B59),
  dual, local,
  nonextensible,
  helpstring("INktStructPEOptionalHeader Interface"),
  pointer_default(unique)
]
interface INktStructPEOptionalHeader : IDispatch
{
/**
  * \brief The state of the image file. See http://msdn.microsoft.com/en-us/library/windows/desktop/ms680339(v=vs.85).aspx for details.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get magic value"),
   id(dispidNktStructPEOptionalHeaderMagic)]
  HRESULT Magic([out, retval] LONG *pVal);

  /**
  * \brief Returns the major version of the linker.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get major linker version"),
   id(dispidNktStructPEOptionalHeaderMajorLinkerVersion)]
  HRESULT MajorLinkerVersion([out, retval] short *pVal);

  /**
  * \brief Returns the minor version of the linker.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get minor linker version"),
   id(dispidNktStructPEOptionalHeaderMinorLinkerVersion)]
  HRESULT MinorLinkerVersion([out, retval] LONG *pVal);

  /**
  * \brief Returns the size of the code section, in bytes, or the sum of all such sections if there are multiple code sections.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get size ofcode"),
   id(dispidNktStructPEOptionalHeaderSizeOfCode)]
  HRESULT SizeOfCode([out, retval] LONG *pVal);

  /**
  * \brief Returns The size of the initialized data section, in bytes, or the sum of all such sections if there are multiple initialized data sections.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get size of initialized data"),
   id(dispidNktStructPEOptionalHeaderSizeOfInitializedData)]
  HRESULT SizeOfInitializedData([out, retval] LONG *pVal);

  /**
  * \brief Returns the size of the uninitialized data section, in bytes, or the sum of all such sections if there are multiple uninitialized data sections.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get size of uninitialized data"),
   id(dispidNktStructPEOptionalHeaderSizeOfUninitializedData)]
  HRESULT SizeOfUninitializedData([out, retval] LONG *pVal);

  /**
  * \brief Returns a pointer to the entry point function, relative to the image base address. For executable files, this is the starting address. For device drivers, this is the address of the initialization function. The entry point function is optional for DLLs. When no entry point is present, this member is zero.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get address of entrypoint"),
   id(dispidNktStructPEOptionalHeaderAddressOfEntryPoint)]
  HRESULT AddressOfEntryPoint([out, retval] LONG *pVal);

  /**
  * \brief The size of the optional header, in bytes. 
  * \param pVal Returns a pointer to the beginning of the code section, relative to the image base.
  */   
  [propget, helpstring("Get base of code"),
   id(dispidNktStructPEOptionalHeaderBaseOfCode)]
  HRESULT BaseOfCode([out, retval] LONG *pVal);

  /**
  * \brief Returns the preferred address of the first byte of the image when it is loaded in memory. This value is a multiple of 64K bytes. The default value for DLLs is 0x10000000. The default value for applications is 0x00400000, except on Windows CE where it is 0x00010000.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get image base"),
   id(dispidNktStructPEOptionalHeaderImageBase)]
  HRESULT ImageBase([out, retval] my_ssize_t *pVal);

  /**
  * \brief Returns the alignment of sections loaded in memory, in bytes. The default value is the page size for the system.
  * \param pVal Pointer to receive the value. 	
  */ 	  
  [propget, helpstring("Get Section alignment"),
   id(dispidNktStructPEOptionalHeaderSectionAlignment)]
  HRESULT SectionAlignment([out, retval] LONG *pVal);

 /**
  * \brief Returns the alignment of the raw data of sections in the image file, in bytes. 
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get file alignment"),
   id(dispidNktStructPEOptionalHeaderFileAlignment)]
  HRESULT FileAlignment([out, retval] LONG *pVal);

  /**
  * \brief Returns the major OS version.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get Major operating system version"),
   id(dispidNktStructPEOptionalHeaderMajorOperatingSystemVersion)]
  HRESULT MajorOperatingSystemVersion([out, retval] short *pVal);

  /**
  * \brief Returns the minor OS version.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get Minor operating system version"),
   id(dispidNktStructPEOptionalHeaderMinorOperatingSystemVersion)]
  HRESULT MinorOperatingSystemVersion([out, retval] short *pVal);

  /**
  * \brief Returns the major image version.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get MajorImage version"),
   id(dispidNktStructPEOptionalHeaderMajorImageVersion)]
  HRESULT MajorImageVersion([out, retval] short *pVal);

  /**
  * \brief Returns the minor image version.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get minor image version"),
   id(dispidNktStructPEOptionalHeaderMinorImageVersion)]
  HRESULT MinorImageVersion([out, retval] short *pVal);

  /**
  * \brief Returns the major subsystem version.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get major subsystem version"),
   id(dispidNktStructPEOptionalHeaderMajorSubsystemVersion)]
  HRESULT MajorSubsystemVersion([out, retval] short *pVal);

  /**
  * \brief Returns the minor subsystem version.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get minor subsystem version"),
   id(dispidNktStructPEOptionalHeaderMinorSubsystemVersion)]
  HRESULT MinorSubsystemVersion([out, retval] short *pVal);

  /**
  * \brief Returns Win32 version. This value is a reserved field and should return 0.
  * \param pVal Pointer to receive the value. 	
  */  
  [propget, helpstring("Get Win32 version value"),
   id(dispidNktStructPEOptionalHeaderWin32VersionValue)]
  HRESULT Win32VersionValue([out, retval] LONG *pVal);

  /**
  * \brief The size of the image, in bytes, including all headers.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get size of image"),
   id(dispidNktStructPEOptionalHeaderSizeOfImage)]
  HRESULT SizeOfImage([out, retval] LONG *pVal);

  /**
  * \brief Returns the combined size of the following items, rounded to a multiple of the value specified in the FileAlignment member: e_lfanew member of IMAGE_DOS_HEADER, 4 byte signature, size of IMAGE_FILE_HEADER, size of optional header, size of all section headers.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get size of headers"),
   id(dispidNktStructPEOptionalHeaderSizeOfHeaders)]
  HRESULT SizeOfHeaders([out, retval] LONG *pVal);

  /**
  * \brief Returns the image file checksum. The following files are validated at load time: all drivers, any DLL loaded at boot time, and any DLL loaded into a critical system process.
  * \param pVal Pointer to receive the value. 	
  */   
  [propget, helpstring("Get checksum"),
   id(dispidNktStructPEOptionalHeaderCheckSum)]
  HRESULT CheckSum([out, retval] LONG *pVal);

  /**
  * \brief Returns the subsystem required to run this image. See 	http://msdn.microsoft.com/en-us/library/windows/desktop/ms680339(v=vs.85).aspx for available constants.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get subsystem"),
   id(dispidNktStructPEOptionalHeaderSubsystem)]
  HRESULT Subsystem([out, retval] short *pVal);

  /**
  * \brief Returns the DLL characteristics of the image. See 	http://msdn.microsoft.com/en-us/library/windows/desktop/ms680339(v=vs.85).aspx for available constants.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get Dll characteristics"),
   id(dispidNktStructPEOptionalHeaderDllCharacteristics)]
  HRESULT DllCharacteristics([out, retval] short *pVal);

  /**
  * \brief Returns the number of bytes to reserve for the stack. 
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get size of stack reserve"),
   id(dispidNktStructPEOptionalHeaderSizeOfStackReserve)]
  HRESULT SizeOfStackReserve([out, retval] my_ssize_t *pVal);

  /**
  * \brief Returns the number of bytes to commit for the stack.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get size of stack commit"),
   id(dispidNktStructPEOptionalHeaderSizeOfStackCommit)]
  HRESULT SizeOfStackCommit([out, retval] my_ssize_t *pVal);

  /**
  * \brief Returns the number of bytes to reserve for heap.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get size of heap reserve"),
   id(dispidNktStructPEOptionalHeaderSizeOfHeapReserve)]
  HRESULT SizeOfHeapReserve([out, retval] my_ssize_t *pVal);

  /**
  * \brief Returns the number of bytes to commit for the local heap. 
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get size of heap commit"),
   id(dispidNktStructPEOptionalHeaderSizeOfHeapCommit)]
  HRESULT SizeOfHeapCommit([out, retval] my_ssize_t *pVal);

  /**
  * \brief Returns the loader flags. This field is obsolete.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get loader flags"),
   id(dispidNktStructPEOptionalHeaderLoaderFlags)]
  HRESULT LoaderFlags([out, retval] LONG *pVal);

  /**
  * \brief Returns the number of directory entries in the remainder of the optional header. Each entry describes a location and size.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get number of rva and sizes"),
   id(dispidNktStructPEOptionalHeaderNumberOfRvaAndSizes)]
  HRESULT NumberOfRvaAndSizes([out, retval] LONG *pVal);

  /**
  * \brief Returns a pointer to the start of IMAGE_DATA_DIRECTORY structure.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get data directory start"),
   id(dispidNktStructPEOptionalHeaderDataDirectoryStart)]
  HRESULT DataDirectoryStart([in] LONG index, [out, retval] my_ssize_t *pVal);

  /**
  * \brief Returns a pointer to the end of IMAGE_DATA_DIRECTORY structure.
  * \param pVal Pointer to receive the value. 	
  */ 
  [propget, helpstring("Get data directory end"),
   id(dispidNktStructPEOptionalHeaderDataDirectoryEnd)]
  HRESULT DataDirectoryEnd([in] LONG index, [out, retval] my_ssize_t *pVal);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

/**
 * \interface INktStructPESections
 *
 * \brief Exposes methods to access Portable Executable (PE) sections.
 */
 [
  object,
  uuid(5BF7BC52-7158-4e0f-857E-F7FDB137249F),
  dual, local,
  nonextensible,
  helpstring("INktStructPESections Interface"),
  pointer_default(unique)
]
interface INktStructPESections : IDispatch
{  
  [propget, helpstring("Get total section's count"),
   id(dispidNktStructPESectionsCount)]
  HRESULT Count([out, retval] LONG *pVal);

  [propget, helpstring("Get section name"),
   id(dispidNktStructPESectionsName)]
  HRESULT Name([in] LONG index, [out, retval] BSTR *pVal);

  [propget, helpstring("Get start address"),
   id(dispidNktStructPESectionsStartAddress)]
  HRESULT StartAddress([in] LONG index, [out, retval] my_ssize_t *pVal);

  [propget, helpstring("Get end address"),
   id(dispidNktStructPESectionsEndAddress)]
  HRESULT EndAddress([in] LONG index, [out, retval] my_ssize_t *pVal);

  [propget, helpstring("Get characteristics"),
   id(dispidNktStructPESectionsCharacteristics)]
  HRESULT Characteristics([in] LONG index, [out, retval] LONG *pVal);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

[
  object,
  uuid(21403F16-B370-4bc7-9D7E-0DEDA54EAD01),
  dual, local,
  nonextensible,
  helpstring("INktPdbFunctionSymbol Interface"),
  pointer_default(unique)
]
interface INktPdbFunctionSymbol : INktObject
{
  /**
   * \fn	HRESULT INktPdbFunctionSymbol::AddrOffset([out, retval] my_ssize_t *pVal);
   *
   * \brief	Get the offset of the function inside the containing module.
   *
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return S_OK or E_FAIL.
   */

  [propget, helpstring("Get the offset of the function inside the containing module"),
   id(dispidNktPdbFunctionSymbolAddrOffset)]
  HRESULT AddrOffset([out, retval] my_ssize_t *pVal);

  /**
   * \fn	HRESULT INktPdbFunctionSymbol::PlatformBits([out, retval] LONG *pVal);
   *
   * \brief	Get the platform bits of the symbol.
   *
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return S_OK or E_FAIL.
   */

  [propget, helpstring("Get the platform bits of the symbol"),
   id(dispidNktPdbFunctionSymbolPlatformBits)]
  HRESULT PlatformBits([out, retval] LONG *pVal);

  /**
   * \fn	HRESULT INktPdbFunctionSymbol::Name([out, retval] BSTR *pVal);
   *
   * \brief	Get the function's name.
   *
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return S_OK or E_FAIL.
   */

  [propget, helpstring("Get the function's name"),
   id(dispidNktPdbFunctionSymbolName)]
  HRESULT Name([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktPdbFunctionSymbol::ModuleName([out, retval] BSTR *pVal);
   *
   * \brief	Get the name of the module where this function resides.
   *
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return S_OK or E_FAIL.
   */

  [propget, helpstring("Get the name of the module where this function resides"),
   id(dispidNktPdbFunctionSymbolModuleName)]
  HRESULT ModuleName([out, retval] BSTR *pVal);

  /**
   * \fn	HRESULT INktPdbFunctionSymbol::CompleteName([out, retval] BSTR *pVal);
   *
   * \brief	Get the complete name of the function.
   *
   * \param [in,out]	pVal	If non-null, the value.
   *
   * \return S_OK or E_FAIL.
   */

  [propget, helpstring("Get the complete name of the function"),
   id(dispidNktPdbFunctionSymbolCompleteName)]
  HRESULT CompleteName([out, retval] BSTR *pVal);
};

//-----------------------------------------------------------
//-----------------------------------------------------------

[
  uuid(6E5EC37D-CF01-49B1-96C7-5E8ECF21A14C),
  version(2.0),
  helpstring("DeviareCOM 2.0 Type Library")
]
library Deviare2
{
  importlib("stdole2.tlb");

  //---------------------------------------------------------
  //---------------------------------------------------------

  [v1_enum] enum eNktErrorCodes;
  [v1_enum] enum eNktHookState;
  [v1_enum] enum eNktHookFlags;
  [v1_enum] enum eNktHookCustomHandlerFlags;
  [v1_enum] enum eNktSearchMode;
  [v1_enum] enum eNktRegister;
  [v1_enum] enum eNktProtection;
  [v1_enum] enum eNktDboFundamentalType;
  [v1_enum] enum eNktDboClass;
  [v1_enum] enum eNktDboCallingConvention;
  [v1_enum] enum eNktDboFunctionFlags;
  [v1_enum] enum eNktDboStructUnionFlags;
  [v1_enum] enum eNktDboItemFlags;
  [v1_enum] enum eNktDboItemMemberType;
  [v1_enum] enum eNktDispIds;

  //---------------------------------------------------------
  //---------------------------------------------------------

  /**
  NktObject.<br>
  Implements INktObject.
  */
  
  [
    uuid(6C58E03D-ACFF-426F-95AC-56C1FA8B0C73),
    helpstring("NktObject Class")
  ]
  coclass NktObject
  {
    [default] interface INktObject;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

  /**
   * \interface	DNktProcessEvents
   *
   * \brief	Gets the nkt process events.
   *
   */

  [
    uuid(07F5FFF7-4801-41c5-827F-91198104D81D),
    helpstring("DNktProcessEvents Interface")
  ]
  dispinterface DNktProcessEvents
  {
  properties:
  methods:

    /**
     * \fn	HRESULT OnCustomDllLoad([in] INktProcess *proc, [in] LONG actionId,
     * 		[in] LONG actionResult);
     *
     * \brief	Called when a custom dll is loaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	actionId		Identifier for the action.
     * \param	actionResult	The action result.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a custom dll is loaded"),
     id(dispidNktProcessEventsOnCustomDllLoad)]
    HRESULT OnCustomDllLoad([in] INktProcess *proc, [in] LONG actionId, [in] LONG actionResult);

    /**
     * \fn	HRESULT OnCustomDllUnload([in] INktProcess *proc, [in] LONG actionId,
     * 		[in] LONG actionResult);
     *
     * \brief	Called when a custom dll is unloaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	actionId		Identifier for the action.
     * \param	actionResult	The action result.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a custom dll is unloaded"),
     id(dispidNktProcessEventsOnCustomDllUnload)]
    HRESULT OnCustomDllUnload([in] INktProcess *proc, [in] LONG actionId, [in] LONG actionResult);

    /**
     * \fn	HRESULT OnCustomApiCall([in] INktProcess *proc, [in] LONG actionId,
     * 		[in] LONG actionResult, [in] LONG apiResult);
     *
     * \brief	Called when a custom api is called.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	actionId		Identifier for the action.
     * \param	actionResult	The action result.
     * \param	apiResult   	The api result.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a custom api is called"),
     id(dispidNktProcessEventsOnCustomApiCall)]
    HRESULT OnCustomApiCall([in] INktProcess *proc, [in] LONG actionId, [in] LONG actionResult,
                            [in] LONG apiResult);

    /**
     * \fn	HRESULT OnHookStateChanged([in] INktHook *hook, [in] INktProcess *proc,
     * 		[in] eNktHookState newState, [in] eNktHookState oldState);
     *
     * \brief	Called when the state of a hook object in a process changes.
     *
     * 
     * 
     *
     * \param [in,out]	hook	If non-null, the hook.
     * \param [in,out]	proc	If non-null, the proc.
     * \param	newState		State of the new.
     * \param	oldState		State of the old.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when the state of a hook object in a process changes"),
     id(dispidNktProcessEventsOnHookStateChanged)]
    HRESULT OnHookStateChanged([in] INktHook *hook, [in] INktProcess *proc, [in] eNktHookState newState,
                               [in] eNktHookState oldState);

    /**
     * \fn	HRESULT OnFunctionCalled([in] INktHook *hook, [in] INktProcess *proc,
     * 		[in] INktHookCallInfo *callInfo);
     *
     * \brief	Called when a hook is called.
     *
     * 
     * 
     *
     * \param [in,out]	hook		If non-null, the hook.
     * \param [in,out]	proc		If non-null, the proc.
     * \param [in,out]	callInfo	If non-null, information describing the call.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a hook is called"),
     id(dispidNktProcessEventsOnFunctionCalled)]
    HRESULT OnFunctionCalled([in] INktHook *hook, [in] INktProcess *proc, [in] INktHookCallInfo *callInfo);

    /**
     * \fn	HRESULT OnCreateProcessCall([in] INktProcess *proc, [in] LONG childPid,
     * 		[in] LONG mainThreadId, [in] VARIANT_BOOL is64BitProcess, [in] VARIANT_BOOL canHookNow);
     *
     * \brief	Called when a process is created within a hooked process.
     *
     * 
     * 
     *
     * \param [in,out]	proc  	If non-null, the proc.
     * \param	childPid	  	The child pid.
     * \param	mainThreadId  	Identifier for the main thread.
     * \param	is64BitProcess	The is 64 bit process.
     * \param	canHookNow	  	The can hook now.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a process is created within a hooked process"),
     id(dispidNktProcessEventsOnCreateProcessCall)]
    HRESULT OnCreateProcessCall([in] INktProcess *proc, [in] LONG childPid, [in] LONG mainThreadId,
                                [in] VARIANT_BOOL is64BitProcess, [in] VARIANT_BOOL canHookNow);

    /**
     * \fn	HRESULT OnLoadLibraryCall([in] INktProcess *proc, [in] BSTR dllName,
     * 		[in] VARIANT moduleHandle);
     *
     * \brief	Called when a dynamic link library is loaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	dllName			Name of the dll.
     * \param	moduleHandle	Handle of the module.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is loaded"),
     id(dispidNktProcessEventsOnLoadLibraryCall)]
    HRESULT OnLoadLibraryCall([in] INktProcess *proc, [in] BSTR dllName, [in] VARIANT moduleHandle);

#ifdef IDL_CSHARP_EVENTS_SUPPORTED
    /**
     * \fn	HRESULT OnLoadLibraryCall2([in] INktProcess *proc, [in] BSTR dllName,
     * 		[in] my_ssize_t moduleHandle);
     *
     * \brief	Called when a dynamic link library is loaded. Better for usage in languages like C#.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	dllName			Name of the dll.
     * \param	moduleHandle	Handle of the module.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is loaded (Better for usage in languages like C#)"),
     id(dispidNktProcessEventsOnLoadLibraryCall2)]
    HRESULT OnLoadLibraryCall2([in] INktProcess *proc, [in] BSTR dllName, [in] my_ssize_t moduleHandle);
#endif //IDL_CSHARP_EVENTS_SUPPORTED

    /**
     * \fn	HRESULT OnFreeLibraryCall([in] INktProcess *proc, [in] VARIANT moduleHandle);
     *
     * \brief	Called when a dynamic link library is unloaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	moduleHandle	Handle of the module.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is unloaded"),
     id(dispidNktProcessEventsOnFreeLibraryCall)]
    HRESULT OnFreeLibraryCall([in] INktProcess *proc, [in] VARIANT moduleHandle);

#ifdef IDL_CSHARP_EVENTS_SUPPORTED
    /**
     * \fn	HRESULT OnFreeLibraryCall2([in] INktProcess *proc, [in] my_ssize_t moduleHandle);
     *
     * \brief	Called when a dynamic link library is unloaded. Better for usage in languages like C#.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	moduleHandle	Handle of the module.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is unloaded (Better for usage in languages like C#)"),
     id(dispidNktProcessEventsOnFreeLibraryCall2)]
    HRESULT OnFreeLibraryCall2([in] INktProcess *proc, [in] my_ssize_t moduleHandle);
#endif //IDL_CSHARP_EVENTS_SUPPORTED

    /**
     * \fn	HRESULT OnAgentLoad([in] INktProcess *proc, [in] LONG errorCode);
     *
     * \brief	Called when an agent is loaded into a process.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	errorCode   	The error code.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when an agent is loaded into a process"),
     id(dispidNktProcessEventsOnAgentLoad)]
    HRESULT OnAgentLoad([in] INktProcess *proc, [in] LONG errorCode);

    /**
     * \fn	HRESULT OnAgentUnload([in] INktProcess *proc);
     *
     * \brief	Called when an agent is unloaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when an agent is unloaded"),
     id(dispidNktProcessEventsOnAgentUnload)]
    HRESULT OnAgentUnload([in] INktProcess *proc);

   /**
     * \fn	HRESULT OnCustomMessage([in] INktProcess *proc, [in] VARIANT msgCode, [in] VARIANT msgParam,
     * [in,out] VARIANT *retVal);
     *
     * \brief	Called when a custom message is sent from a plugin.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	msgCode	Message code.
     * \param	msgParam	Message parameter.
     * \param	retVal	The value to return to the caller.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is unloaded"),
     id(dispidNktProcessEventsOnCustomMessage)]
    HRESULT OnCustomMessage([in] INktProcess *proc, [in] VARIANT msgCode, [in] VARIANT msgParam,
                            [in,out] VARIANT *retVal);

#ifdef IDL_CSHARP_EVENTS_SUPPORTED
    /**
      * \fn	HRESULT OnCustomMessage2([in] INktProcess *proc, [in] my_ssize_t msgCode,
      * [in] my_ssize_t msgParam, [in,out] my_ssize_t *retVal);
      *
      * \brief	Called when a custom message is sent from a plugin.
      *
      * 
      * 
      *
      * \param [in,out]	proc	If non-null, the proc.
      * \param	msgCode	Message code.
      * \param	msgParam	Message parameter.
      * \param	retVal	The value to return to the caller.
      *
      * \return S_OK or E_FAIL.
      */

     [helpstring("Called when a dynamic link library is unloaded (Better for usage in languages like C#)"),
      id(dispidNktProcessEventsOnCustomMessage2)]
     HRESULT OnCustomMessage2([in] INktProcess *proc, [in] my_ssize_t msgCode, [in] my_ssize_t msgParam,
                              [in,out] my_ssize_t *retVal);
#endif //IDL_CSHARP_EVENTS_SUPPORTED

    /**
     * \fn	HRESULT OnHookOverwritten([in] INktHook *hook, [in] INktProcess *proc);
     *
     * \brief	Called when a hook is overwritten by an external hook.
     *
     *
     * \param [in,out]	hook		If non-null, the hook.
     * \param [in,out]	proc		If non-null, the proc.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a hook is overwritten by an external hook"),
     id(dispidNktProcessEventsOnHookOverwritten)]
    HRESULT OnHookOverwritten([in] INktHook *hook, [in] INktProcess *proc);
  };

  //---------------------------------------------------------

    /**
  NktProcess.<br>
  Implements INktProcess and DNktProcessEvents.
  */
  
  [
    uuid(E5FD693D-4E04-4058-BBBA-8D60BAAEE16C),
    helpstring("NktProcess Class")
  ]
  coclass NktProcess
  {
    [default] interface INktProcess;
    [default, source] interface DNktProcessEvents;
  };

  //---------------------------------------------------------

    /**
  NktProcessesEnum.<br>
  Implements INktProcessesEnum.
  */ 
  
  [
    uuid(6D477BF3-F521-475f-ACF5-536D160486B1),
    helpstring("NktProcessesEnum Class")
  ]
  coclass NktProcessesEnum
  {
    [default] interface INktProcessesEnum;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

    /**
  NktModule.<br>
  Implements INktModule.
  */ 
  
  [
    uuid(5D36944B-2FBA-4CA1-A888-C5D926593D20),
    helpstring("NktModule Class")
  ]
  coclass NktModule
  {
    [default] interface INktModule;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

    /**
  NktModulesEnum.<br>
  Implements INktModulesEnum.
  */ 
  
  [
    uuid(4207729B-B2F5-4628-9885-23C0D0B1935B),
    helpstring("NktModulesEnum Class")
  ]
  coclass NktModulesEnum
  {
    [default] interface INktModulesEnum;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

    /**
  NktExportedFunction.<br>
  Implements INktExportedFunction.
  */ 
  
  [
    uuid(D901F1D6-FC59-4dca-9DAD-E9C1EE7A3280),
    helpstring("NktExportedFunction Class")
  ]
  coclass NktExportedFunction
  {
    [default] interface INktExportedFunction;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

    /**
  NktExportedFunctionsEnum.<br>
  Implements INktExportedFunctionsEnum.
  */
  
  [
    uuid(BD246936-6FDD-4e9c-9CD4-E3A8EF7392DC),
    helpstring("NktExportedFunctionsEnum Class")
  ]
  coclass NktExportedFunctionsEnum
  {
    [default] interface INktExportedFunctionsEnum;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

  /**
   * \interface DNktHookEvents
   *
   * \brief	Gets the nkt hook events.
   *
   */

  [
    uuid(B497652A-056C-46b1-820F-AB15D9A458C3),
    helpstring("DNktHookEvents Interface")
  ]
  dispinterface DNktHookEvents
  {
  properties:
  methods:

    /**
     * \fn	HRESULT OnStateChanged([in] INktHook *hook, [in] INktProcess *proc,
     * 		[in] eNktHookState newState, [in] eNktHookState oldState);
     *
     * \brief	Called when the state of a hook object in a process changes.
     *
     * 
     * 
     *
     * \param [in,out]	hook	If non-null, the hook.
     * \param [in,out]	proc	If non-null, the proc.
     * \param	newState		State of the new.
     * \param	oldState		State of the old.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when the state of a hook object in a process changes"),
     id(dispidNktHookEventsOnStateChanged)]
    HRESULT OnStateChanged([in] INktHook *hook, [in] INktProcess *proc, [in] eNktHookState newState,
                           [in] eNktHookState oldState);

    /**
     * \fn	HRESULT OnFunctionCalled([in] INktHook *hook, [in] INktProcess *proc,
     * 		[in] INktHookCallInfo *callInfo);
     *
     * \brief	Called when a hook is called.
     *
     * 
     * 
     *
     * \param [in,out]	hook		If non-null, the hook.
     * \param [in,out]	proc		If non-null, the proc.
     * \param [in,out]	callInfo	If non-null, information describing the call.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a hook is called"),
     id(dispidNktHookEventsOnFunctionCalled)]
    HRESULT OnFunctionCalled([in] INktHook *hook, [in] INktProcess *proc, [in] INktHookCallInfo *callInfo);

    /**
     * \fn	HRESULT OnHookOverwritten([in] INktHook *hook, [in] INktProcess *proc);
     *
     * \brief	Called when a hook is overwritten by an external hook.
     *
     * 
     * 
     *
     * \param [in,out]	hook		If non-null, the hook.
     * \param [in,out]	proc		If non-null, the proc.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a hook is overwritten by an external hook"),
     id(dispidNktHookEventsOnHookOverwritten)]
    HRESULT OnHookOverwritten([in] INktHook *hook, [in] INktProcess *proc);
  };

  //---------------------------------------------------------

  /**
  NktHook.<br>
  Implements INktHook and DNktHookEvents.
  */
  
  [
    uuid(4C71C5D5-B510-465a-B2E4-EAC7B271C164),
    helpstring("NktHook Class")
  ]
  coclass NktHook
  {
    [default] interface INktHook;
    [default, source] dispinterface DNktHookEvents;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

    /**
  NktHooksEnum.<br>
  Implements INktHooksEnum.
  */
  
  [
    uuid(329BE071-4C82-4106-B7B1-E4A668EAFC1E),
    helpstring("NktHooksEnum Class")
  ]
  coclass NktHooksEnum
  {
    [default] interface INktHooksEnum;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------
  
    /**
  NktParam.<br>
  Implements INktParam.
  */
  
  [
    uuid(5DA31131-A1AD-40b2-A526-876F61E1DF48),
    helpstring("NktParam Class")
  ]
  coclass NktParam
  {
    [default] interface INktParam;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

    /**
  NktParamsEnum.<br>
  Implements INktParamsEnum.
  */
  
  [
    uuid(51BFF27D-9E5F-47e6-AAB8-76BFD2592F43),
    helpstring("NktParamsEnum Class")
  ]
  coclass NktParamsEnum
  {
    [default] interface INktParamsEnum;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

    /**
  NktHookCallInfo.<br>
  Implements INktHookCallInfo.
  */
  
  [
    uuid(D41D1782-E887-4c10-8DCF-9A25D9DDA888),
    helpstring("NktHookCallInfo Class")
  ]
  coclass NktHookCallInfo
  {
    [default] interface INktHookCallInfo;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

  /**
  NktHookInfo.<br>
  Implements INktHookInfo.
  */
  
  [
    uuid(B0506A96-1E21-4da4-9177-B85546756B8C),
    helpstring("NktHookInfo Class")
  ]
  coclass NktHookInfo
  {
    [default] interface INktHookInfo;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------
  
  /**
  NktProcessMemory.<br>
  Implements INktProcessMemory.
  */
  
  [
    uuid(D9706C19-23F1-435c-97FB-1D21378ECC88),
    helpstring("NktProcessMemory Class")
  ]
  coclass NktProcessMemory
  {
    [default] interface INktProcessMemory;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

  /**
  NktStackTrace.<br>
  Implements INktStackTrace.
  */
  
  [
    uuid(ABF7E938-AF08-47ab-9857-CFF16E6C3215),
    helpstring("NktStackTrace Class")
  ]
  coclass NktStackTrace
  {
    [default] interface INktStackTrace;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

  /**
   * \interface DNktSpyMgrEvents
   *
   * \brief	Gets the nkt spy manager events.
   *
   */

  [
    uuid(71BF517D-533B-473C-A3B8-63FD9887C195),
    helpstring("DNktSpyMgrEvents Interface")
  ]
  dispinterface DNktSpyMgrEvents
  {
  properties:
  methods:

    /**
     * \fn	HRESULT OnCustomDllLoad([in] INktProcess *proc, [in] LONG actionId,
     * 		[in] LONG actionResult);
     *
     * \brief	Called when a custom dll is loaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	actionId		Identifier for the action.
     * \param	actionResult	The action result.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a custom dll is loaded"),
     id(dispidNktSpyMgrEventsOnCustomDllLoad)]
    HRESULT OnCustomDllLoad([in] INktProcess *proc, [in] LONG actionId, [in] LONG actionResult);

    /**
     * \fn	HRESULT OnCustomDllUnload([in] INktProcess *proc, [in] LONG actionId,
     * 		[in] LONG actionResult);
     *
     * \brief	Called when a custom dll is unloaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	actionId		Identifier for the action.
     * \param	actionResult	The action result.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a custom dll is unloaded"),
     id(dispidNktSpyMgrEventsOnCustomDllUnload)]
    HRESULT OnCustomDllUnload([in] INktProcess *proc, [in] LONG actionId, [in] LONG actionResult);

    /**
     * \fn	HRESULT OnCustomApiCall([in] INktProcess *proc, [in] LONG actionId,
     * 		[in] LONG actionResult, [in] LONG apiResult);
     *
     * \brief	Called when a custom api is called.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	actionId		Identifier for the action.
     * \param	actionResult	The action result.
     * \param	apiResult   	The api result.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a custom api is called"),
     id(dispidNktSpyMgrEventsOnCustomApiCall)]
    HRESULT OnCustomApiCall([in] INktProcess *proc, [in] LONG actionId, [in] LONG actionResult,
                            [in] LONG apiResult);

    /**
     * \fn	HRESULT OnHookStateChanged([in] INktHook *hook, [in] INktProcess *proc,
     * 		[in] eNktHookState newState, [in] eNktHookState oldState);
     *
     * \brief	Called when the state of a hook object in a process changes.
     *
     * 
     * 
     *
     * \param [in,out]	hook	If non-null, the hook.
     * \param [in,out]	proc	If non-null, the proc.
     * \param	newState		State of the new.
     * \param	oldState		State of the old.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when the state of a hook object in a process changes"),
     id(dispidNktSpyMgrEventsOnHookStateChanged)]
    HRESULT OnHookStateChanged([in] INktHook *hook, [in] INktProcess *proc, [in] eNktHookState newState,
                               [in] eNktHookState oldState);

    /**
     * \fn	HRESULT OnFunctionCalled([in] INktHook *hook, [in] INktProcess *proc,
     * 		[in] INktHookCallInfo *callInfo);
     *
     * \brief	Called when a hook is called.
     *
     * 
     * 
     *
     * \param [in,out]	hook		If non-null, the hook.
     * \param [in,out]	proc		If non-null, the proc.
     * \param [in,out]	callInfo	If non-null, information describing the call.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a hook is called"),
     id(dispidNktSpyMgrEventsOnFunctionCalled)]
    HRESULT OnFunctionCalled([in] INktHook *hook, [in] INktProcess *proc,
                             [in] INktHookCallInfo *callInfo);

    /**
     * \fn	HRESULT OnCreateProcessCall([in] INktProcess *proc, [in] LONG childPid, [in] LONG mainThreadId,
     * 		[in] VARIANT_BOOL is64BitProcess, [in] VARIANT_BOOL canHookNow);
     *
     * \brief	Called when a process is created within a hooked process.
     *
     * 
     * 
     *
     * \param	[in]	proc  	If non-null, the proc.
     * \param	childPid		The created process pid.
     * \param	mainThreadId  	Identifier for the main thread.
     * \param	is64BitProcess	The is 64 bit process.
     * \param	canHookNow	  	The can hook now.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a process is created within a hooked process"),
     id(dispidNktSpyMgrEventsOnCreateProcessCall)]
    HRESULT OnCreateProcessCall([in] INktProcess *proc, [in] LONG childPid, [in] LONG mainThreadId,
                             [in] VARIANT_BOOL is64BitProcess, [in] VARIANT_BOOL canHookNow);

    /**
     * \fn	HRESULT OnLoadLibraryCall([in] INktProcess *proc, [in] BSTR dllName,
     * 		[in] VARIANT moduleHandle);
     *
     * \brief	Called when a dynamic link library is loaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	dllName			Name of the dll.
     * \param	moduleHandle	Handle of the module.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is loaded"),
     id(dispidNktSpyMgrEventsOnLoadLibraryCall)]
    HRESULT OnLoadLibraryCall([in] INktProcess *proc, [in] BSTR dllName, [in] VARIANT moduleHandle);

#ifdef IDL_CSHARP_EVENTS_SUPPORTED
    /**
     * \fn	HRESULT OnLoadLibraryCall2([in] INktProcess *proc, [in] BSTR dllName,
     * 		[in] my_ssize_t moduleHandle);
     *
     * \brief	Called when a dynamic link library is loaded. Better for usage in languages like C#.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	dllName			Name of the dll.
     * \param	moduleHandle	Handle of the module.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is loaded (Better for usage in languages like C#)"),
     id(dispidNktSpyMgrEventsOnLoadLibraryCall2)]
    HRESULT OnLoadLibraryCall2([in] INktProcess *proc, [in] BSTR dllName, [in] my_ssize_t moduleHandle);
#endif //IDL_CSHARP_EVENTS_SUPPORTED

    /**
     * \fn	HRESULT OnFreeLibraryCall([in] INktProcess *proc, [in] VARIANT moduleHandle);
     *
     * \brief	Called when a dynamic link library is unloaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	moduleHandle	Handle of the module.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is unloaded"),
     id(dispidNktSpyMgrEventsOnFreeLibraryCall)]
    HRESULT OnFreeLibraryCall([in] INktProcess *proc, [in] VARIANT moduleHandle);

#ifdef IDL_CSHARP_EVENTS_SUPPORTED
    /**
     * \fn	HRESULT OnFreeLibraryCall2([in] INktProcess *proc, [in] my_ssize_t moduleHandle);
     *
     * \brief	Called when a dynamic link library is unloaded. Better for usage in languages like C#.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	moduleHandle	Handle of the module.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is unloaded (Better for usage in languages like C#)"),
     id(dispidNktSpyMgrEventsOnFreeLibraryCall2)]
    HRESULT OnFreeLibraryCall2([in] INktProcess *proc, [in] my_ssize_t moduleHandle);
#endif //IDL_CSHARP_EVENTS_SUPPORTED

    /**
     * \fn	HRESULT OnProcessStarted([in] INktProcess *proc);
     *
     * \brief	Called when a new process is created.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a new process is created"),
     id(dispidNktSpyMgrEventsOnProcessStarted)]
    HRESULT OnProcessStarted([in] INktProcess *proc);

    /**
     * \fn	HRESULT OnProcessTerminated([in] INktProcess *proc);
     *
     * \brief	Called when a process has finished.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a process has finished"),
     id(dispidNktSpyMgrEventsOnProcessTerminated)]
    HRESULT OnProcessTerminated([in] INktProcess *proc);

    /**
     * \fn	HRESULT OnAgentLoad([in] INktProcess *proc, [in] LONG errorCode);
     *
     * \brief	Called when an agent is loaded into a process.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	errorCode   	The error code.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when an agent is loaded into a process"),
     id(dispidNktSpyMgrEventsOnAgentLoad)]
    HRESULT OnAgentLoad([in] INktProcess *proc, [in] LONG errorCode);

    /**
     * \fn	HRESULT OnAgentUnload([in] INktProcess *proc);
     *
     * \brief	Called when an agent is unloaded.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when an agent is unloaded"),
     id(dispidNktSpyMgrEventsOnAgentUnload)]
    HRESULT OnAgentUnload([in] INktProcess *proc);

   /**
     * \fn	HRESULT OnCustomMessage([in] INktProcess *proc, [in] VARIANT msgCode, [in] VARIANT msgParam,
     * [in,out] VARIANT *retVal);
     *
     * \brief	Called when a custom message is sent from a plugin.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	msgCode	Message code.
     * \param	msgParam	Message parameter.
     * \param	retVal	The value to return to the caller.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is unloaded"),
     id(dispidNktSpyMgrEventsOnCustomMessage)]
    HRESULT OnCustomMessage([in] INktProcess *proc, [in] VARIANT msgCode, [in] VARIANT msgParam,
                            [in,out] VARIANT *retVal);

#ifdef IDL_CSHARP_EVENTS_SUPPORTED
    /**
     * \fn	HRESULT OnCustomMessage2([in] INktProcess *proc, [in] my_ssize_t msgCode,
     * [in] my_ssize_t msgParam, [in,out] my_ssize_t *retVal);
     *
     * \brief	Called when a custom message is sent from a plugin.
     *
     * 
     * 
     *
     * \param [in,out]	proc	If non-null, the proc.
     * \param	msgCode	Message code.
     * \param	msgParam	Message parameter.
     * \param	retVal	The value to return to the caller.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a dynamic link library is unloaded (Better for usage in languages like C#)"),
     id(dispidNktSpyMgrEventsOnCustomMessage2)]
    HRESULT OnCustomMessage2([in] INktProcess *proc, [in] my_ssize_t msgCode, [in] my_ssize_t msgParam,
                             [in,out] my_ssize_t *retVal);
#endif //IDL_CSHARP_EVENTS_SUPPORTED

   /**
     * \fn	HRESULT OnHookOverwritten([in] INktHook *hook, [in] INktProcess *proc);
     *
     * \brief	Called when a hook is overwritten by an external hook.
     *
     * 
     * 
     *
     * \param [in,out]	hook		If non-null, the hook.
     * \param [in,out]	proc		If non-null, the proc.
     *
     * \return S_OK or E_FAIL.
     */

    [helpstring("Called when a hook is overwritten by an external hook"),
     id(dispidNktSpyMgrEventsOnHookOverwritten)]
    HRESULT OnHookOverwritten([in] INktHook *hook, [in] INktProcess *proc);
  };

  //---------------------------------------------------------

  /**
  NktSpyMgr.<br>
  Implements INktSpyMgr and DNktSpyMgrEvents.
  */
  
  [
    uuid(4C7A99AA-560C-4f75-885E-3AF6CBD3CF32),
    helpstring("NktSpyMgr Class")
  ]
  coclass NktSpyMgr
  {
    [default] interface INktSpyMgr;
    [default, source] dispinterface DNktSpyMgrEvents;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

    /**
  NktDbObject.<br>
  Implements INktDbObject.
  */
  
  [
    uuid(CA025A96-CE32-45b6-BD88-14D342E15314),
    helpstring("NktDbObject Class")
  ]
  coclass NktDbObject
  {
    [default] interface INktDbObject;
  };


  //-----------------------------------------------------------
  //-----------------------------------------------------------
  
    /**
  NktDbObjectsEnum.<br>
  Implements INktDbObjectsEnum.
  */
  
  [
    uuid(1505BE0D-8C51-4362-B7A1-784F2C8462D0),
    helpstring("NktDbObjectsEnum Class")
  ]
  coclass NktDbObjectsEnum
  {
    [default] interface INktDbObjectsEnum;
  };

  //-----------------------------------------------------------
  //-----------------------------------------------------------
  
    /**
  NktDbModule.<br>
  Implements INktDbModule.
  */
  
  [
    uuid(2D6F0D5D-0265-4a2e-8190-1788C7CAF081),
    helpstring("NktDbModule Class")
  ]
  coclass NktDbModule
  {
    [default] interface INktDbModule;
  };

  //-----------------------------------------------------------
  //-----------------------------------------------------------

    /**
  NktDbModulesEnum.<br>
  Implements INktDbModule.
  */
  
  [
    uuid(534B629F-0C66-4479-82CC-F7E5743FC65F),
    helpstring("NktDbModulesEnum Class")
  ]
  coclass NktDbModulesEnum
  {
    [default] interface INktDbModulesEnum;
  };

  //---------------------------------------------------------
  //---------------------------------------------------------

  /**
  NktTools.<br>
  Implements INktTools.
  */
  
  [
    uuid(46071676-3D4D-40b2-9088-55354732414B),
    helpstring("NktTools Class")
  ]
  coclass NktTools
  {
    [default] interface INktTools;
  };

  //---------------------------------------------------------

  /**
  NktHookCallInfoPlugin.<br>
  Implements INktHookCallInfoPlugin.
  */
  
  [
    uuid(10BBBE7A-A01F-45fd-BB27-92CBDCE738E4),
    helpstring("NktHookCallInfoPlugin Class")
  ]
  coclass NktHookCallInfoPlugin
  {
    [default] interface INktHookCallInfoPlugin;
  };

  //---------------------------------------------------------

  /**
  NktStructPEFileHeader.<br>
  Implements INktStructPEFileHeader.
  */
  
  [
    uuid(B51A9270-C6BF-47c5-A71C-E4617A4C413A),
    helpstring("NktStructPEFileHeader Class")
  ]
  coclass NktStructPEFileHeader
  {
    [default] interface INktStructPEFileHeader;
  };

  //---------------------------------------------------------

  /**
  NktStructPEOptionalHeader.<br>
  Implements INktStructPEOptionalHeader.
  */
  
  [
    uuid(EE31335B-46A8-4e52-B00E-9576E56DBB27),
    helpstring("NktStructPEOptionalHeader Class")
  ]
  coclass NktStructPEOptionalHeader
  {
    [default] interface INktStructPEOptionalHeader;
  };

  //---------------------------------------------------------

  /**
  NktStructPESections.<br>
  Implements NktStructPESections.
  */
  
  [
    uuid(36238075-92D6-4573-AF09-76BE12CE3369),
    helpstring("NktStructPESections Class")
  ]
  coclass NktStructPESections
  {
    [default] interface INktStructPESections;
  };

  //---------------------------------------------------------

  /**
  NktPdbFunctionSymbol.<br>
  Implements INktPdbFunctionSymbol.
  */
  
  [
    uuid(913602A6-9390-4cca-84F2-7CBB53F46689),
    helpstring("NktPdbFunctionSymbol Class")
  ]
  coclass NktPdbFunctionSymbol
  {
    [default] interface INktPdbFunctionSymbol;
  };

};
